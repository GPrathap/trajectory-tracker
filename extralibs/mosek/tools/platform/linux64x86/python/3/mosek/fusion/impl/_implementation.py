import numpy
import types
import io
import sys
import mosek

def _():
  import types

  class Enum:
    @staticmethod
    def __inst(c,name):
      o = c()
      o.name  = name
      o.value = len(c.__members__)
      c.__members__.append(o)
      setattr(c, name, o)

    @classmethod
    def fromInt(c,value):
      return c.members[value]

    @staticmethod
    def new(name,membernames):
      members = []
      c = type(name, (Enum,),{ '__members__' : members })
      for n in membernames:
        Enum.__inst(c,n)
      return c
    @classmethod
    def members(c):
      return iter(c.__members__)

    def __str__(self):
      return self.__class__.__name__ + "." + self.name
    def __repr__(self):
      return self.__class__.__name__ + "." + self.name
  return Enum

class _monty:
  Enum = _()
  @staticmethod
  def deduceShape(l,dim):
    def _deduceShape(l,dim):
      if dim > 1:
        shplst = [ _deduceShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          shplst[0].append(len(l))
          return shplst[0]
        else:
          raise TypeError("Irregular array shape")
      else:
        return [len(dim)]
    return tuple(reversed(_deduceShape(l,dim)))
  @staticmethod
  def checkShape(l,dim):
    def _checkShape(l,dim):
      if dim > 1:
        shplst = [ _checkShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          pass
        else:
          raise TypeError("Irregular array shape")
        return len(l)
      else:
        try:
          return len(l)
        except TypeError:
          raise TypeError("Wrong or irregular array shape")
    _checkShape(l,dim)
    return dim

  @staticmethod
  def initJaggedArray(data, nd):
    dims = []
    d = data
    for i in range(nd):
      dims.append(len(d))
      d = d[0]

    res = numpy.zeros(dims,dtype=object)
    res.__setitem__(tuple([ slice(d) for d in dims ]), data)

    return res


  @staticmethod
  def makeJaggedArray(src,ndims,dtype):
    if src is None:
      return None
    elif len(ndims) == 1:
      if ndims[0] == 1:
        r = numpy.zeros((len(src),),dtype=dtype)
        r[:] = src
      else:
        d = _monty.deduceDims(src,ndims[0])
        r = numpy.zeros(d,dtype=dtype)
        r.__setitem__(tuple([slice(None)]*ndims[0]),src) # basically: r[:,...,:] = src
      return r
    elif ndims[0] == 1:
      r = numpy.zeros((len(src),),dtype=numpy.dtype(object))
      # Note: This is a bit tricky to do reliably with numpy as it
      # tends to think we are dealing with multidimensional arrays and
      # explode
      for i,s in enumerate(src):
        r[i] = _monty.makeJaggedArray(s,ndims[1:],dtype)

      #r[:] = [ _monty.makeJaggedArray(s,ndims[1:],dtype) for s in src ]
      return r
    else:
      d = _monty.deduceDims(src,ndims[0])
      def _(src,nd):
        if nd == 0:
          return _monty.makeJaggedArray(src)
        else:
          return [ _(s,nd-1) for s in src ]

      r = numpy.zeros(d,dtype=numpy.dtype(object))
      r.__setitem__(tuple([slice(None)]*ndims[0]),_(src,ndims[0])) # basically: r[:,...,:] = convert(src)
      return r

  @staticmethod
  def copyArray(src,dst,dim):
    if dim == 1:
      src[:] = dst[:]
    else:
      for i in range(len(src)):
        _monty.copyArray(src[i],dst[i],dim-1)
  @staticmethod
  def arg_match_sloppy_array(v,elmmatch,dim,l=None):
    if dim == 0:
      elmmatch(v)
    elif dim == 1:
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      for e in v:
        if not elmmatch(e): return False
      return True
    elif isinstance(v,list) or isinstance(v,numpy.ndarray):
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      elif not (isinstance(v[0],list) or isinstance(v[0],numpy.ndarray)): return False

      top_len = len(v[0])
      for e in v:
        if not _monty.arg_match_sloppy_array(e,elmmatch,dim-1,top_len): return False
      return True
    else:
      return False

del _

mosek_fusion_RelationKey=_monty.Enum.new('RelationKey',['EqualsTo','LessThan','GreaterThan','IsFree','InRange'])
mosek_fusion_PSDKey=_monty.Enum.new('PSDKey',['IsSymPSD','IsTrilPSD'])
mosek_fusion_QConeKey=_monty.Enum.new('QConeKey',['InQCone','InRotatedQCone','InPExpCone','InPPowCone','InDExpCone','InDPowCone'])
mosek_fusion_ObjectiveSense=_monty.Enum.new('ObjectiveSense',['Undefined','Minimize','Maximize'])
mosek_fusion_SolutionStatus=_monty.Enum.new('SolutionStatus',['Undefined','Unknown','Optimal','Feasible','Certificate','IllposedCert'])
mosek_fusion_AccSolutionStatus=_monty.Enum.new('AccSolutionStatus',['Anything','Optimal','Feasible','Certificate'])
mosek_fusion_ProblemStatus=_monty.Enum.new('ProblemStatus',['Unknown','PrimalAndDualFeasible','PrimalFeasible','DualFeasible','PrimalInfeasible','DualInfeasible','PrimalAndDualInfeasible','IllPosed','PrimalInfeasibleOrUnbounded'])
mosek_fusion_SolutionType=_monty.Enum.new('SolutionType',['Default','Basic','Interior','Integer'])
mosek_fusion_StatusKey=_monty.Enum.new('StatusKey',['Unknown','Basic','SuperBasic','OnBound','Infinity'])
#BEFORE CLASS
def __mk_mosek_fusion_Expression():
 class Expression:
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Expression._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Expression._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Expression._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.index(int32)\n\tmosek.fusion.Expression.index(array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Expression._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.toString()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_Expression._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_Expression._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getDim(int32)')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Expression._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getSize()')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Expression._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.pick(array(int32,ndim=1))\n\tmosek.fusion.Expression.pick(array(int32,ndim=2))')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Expression._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Expression._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Expression._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.slice(int32,int32)\n\tmosek.fusion.Expression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Expression._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getND()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expression._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getShape()')
  def __repr__(self): return 'mosek.fusion.Expression'
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
 return Expression
mosek_fusion_Expression=__mk_mosek_fusion_Expression()
del __mk_mosek_fusion_Expression
#BEFORE CLASS
def __mk_mosek_fusion_Variable():
 class Variable(mosek_fusion_Expression):
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_Variable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.asExpr()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Variable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.toString()')
  def fromTril(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_fromTril_I(*args): # int32
      return self._fromTril_I(*args)
    elif mosek_fusion_Variable._match_alt_fromTril_I(*args): # int32
      return self._fromTril_alt_I(*args)
    else:
      raise ValueError('Invalid argument list fromTril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.fromTril(int32)')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Variable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Variable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Variable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_Variable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_Variable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_Variable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_Variable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.index(int32)\n\tmosek.fusion.Variable.index(array(int32,ndim=1))\n\tmosek.fusion.Variable.index(int32,int32)\n\tmosek.fusion.Variable.index(int32,int32,int32)')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Variable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.dual()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Variable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getModel()')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_Variable._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.remove()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_Variable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_integer()')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_Variable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_Variable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_Variable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.diag()\n\tmosek.fusion.Variable.diag(int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Variable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Variable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.slice(int32,int32)\n\tmosek.fusion.Variable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_Variable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.setLevel(array(double,ndim=1))')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Variable._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getSize()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_Variable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_Variable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_Variable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.Variable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_Variable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.antidiag()\n\tmosek.fusion.Variable.antidiag(int32)')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_Variable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeInteger()')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Variable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.pick(array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=2))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_Variable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.set_values(array(double,ndim=1),bool)')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Variable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.transpose()')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_Variable._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    elif mosek_fusion_Variable._match_reshape_I(*args): # int32
      return self._reshape_I(*args)
    elif mosek_fusion_Variable._match_alt_reshape_I(*args): # int32
      return self._reshape_alt_I(*args)
    elif mosek_fusion_Variable._match_reshape_II(*args): # int32,int32
      return self._reshape_II(*args)
    elif mosek_fusion_Variable._match_alt_reshape_II(*args): # int32,int32
      return self._reshape_alt_II(*args)
    elif mosek_fusion_Variable._match_reshape_III(*args): # int32,int32,int32
      return self._reshape_III(*args)
    elif mosek_fusion_Variable._match_alt_reshape_III(*args): # int32,int32,int32
      return self._reshape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.reshape(array(int32,ndim=1))\n\tmosek.fusion.Variable.reshape(int32)\n\tmosek.fusion.Variable.reshape(int32,int32)\n\tmosek.fusion.Variable.reshape(int32,int32,int32)')
  def tril(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_tril_(*args): # 
      return self._tril_(*args)
    elif mosek_fusion_Variable._match_alt_tril_(*args): # 
      return self._tril_alt_(*args)
    else:
      raise ValueError('Invalid argument list tril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.tril()')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_Variable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.numInst()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Variable._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getND()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Variable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getShape()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Variable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.level()')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_Variable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeContinuous()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_Variable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_continuous()')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.values(int32,array(double,ndim=1),bool)')
  def __repr__(self): return 'mosek.fusion.Variable'
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   pass
  @staticmethod
  def _match_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match__3J__(_3))
  @staticmethod
  def _match_alt_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match__3J__(_3))
  def _inst_alt_I_3JI_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3JI_3J(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3JI_3J(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   pass
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_fromTril_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_fromTril_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _fromTril_alt_I(self,_t__0):
    return self._fromTril_I(numpy.int32(__0))
  def _fromTril_I(self,_0):
   pass
  @staticmethod
  def _match_tril_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_tril_(*args):
    if len(args) != 0: return False
    return True
  def _tril_alt_(self,):
    return self._tril_()
  def _tril_(self,):
   pass
  @staticmethod
  def _match_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _reshape_alt_III(self,_t__0,_t__1,_t__2):
    return self._reshape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _reshape_III(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _reshape_alt_II(self,_t__0,_t__1):
    return self._reshape_II(numpy.int32(__0),numpy.int32(__1))
  def _reshape_II(self,_0,_1):
   pass
  @staticmethod
  def _match_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _reshape_alt_I(self,_t__0):
    return self._reshape_I(numpy.int32(__0))
  def _reshape_I(self,_0):
   pass
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   pass
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   pass
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   pass
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   pass
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   pass
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   pass
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
 return Variable
mosek_fusion_Variable=__mk_mosek_fusion_Variable()
del __mk_mosek_fusion_Variable
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricVariable():
 class SymmetricVariable(mosek_fusion_Variable):
  def __repr__(self): return 'mosek.fusion.SymmetricVariable'
 return SymmetricVariable
mosek_fusion_SymmetricVariable=__mk_mosek_fusion_SymmetricVariable()
del __mk_mosek_fusion_SymmetricVariable
#BEFORE CLASS
def __mk_mosek_fusion_Parameter():
 class Parameter(mosek_fusion_Expression):
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_Parameter._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.isSparse()')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_Parameter._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.asExpr()')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_clone_Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Model
      return self._clone_Lmosek_4fusion_4Model_2(*args)
    elif mosek_fusion_Parameter._match_alt_clone_Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Model
      return self._clone_alt_Lmosek_4fusion_4Model_2(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.clone(mosek.fusion.Model)')
  def getNumNonzero(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getNumNonzero_(*args): # 
      return self._getNumNonzero_(*args)
    elif mosek_fusion_Parameter._match_alt_getNumNonzero_(*args): # 
      return self._getNumNonzero_alt_(*args)
    else:
      raise ValueError('Invalid argument list getNumNonzero('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getNumNonzero()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Parameter._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getShape()')
  def getAllIndexes(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getAllIndexes__3II(*args): # []int32,int32
      return self._getAllIndexes__3II(*args)
    elif mosek_fusion_Parameter._match_alt_getAllIndexes__3II(*args): # []int32,int32
      return self._getAllIndexes_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list getAllIndexes('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getAllIndexes(array(int32,ndim=1),int32)')
  def getSp(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getSp__3JI(*args): # []int64,int32
      return self._getSp__3JI(*args)
    elif mosek_fusion_Parameter._match_alt_getSp__3JI(*args): # []int64,int32
      return self._getSp_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list getSp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getSp(array(int64,ndim=1),int32)')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Parameter._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getND()')
  def setValue(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_setValue_D(*args): # double
      return self._setValue_D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue_D(*args): # double
      return self._setValue_alt_D(*args)
    elif mosek_fusion_Parameter._match_setValue__3D(*args): # []double
      return self._setValue__3D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue__3D(*args): # []double
      return self._setValue_alt__3D(*args)
    elif mosek_fusion_Parameter._match_setValue__3_5D(*args): # [,]double
      return self._setValue__3_5D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue__3_5D(*args): # [,]double
      return self._setValue_alt__3_5D(*args)
    else:
      raise ValueError('Invalid argument list setValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.setValue(double)\n\tmosek.fusion.Parameter.setValue(array(double,ndim=1))\n\tmosek.fusion.Parameter.setValue(array(double,ndim=2))')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_Parameter._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.reshape(array(int32,ndim=1))')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getIndex_I(*args): # int32
      return self._getIndex_I(*args)
    elif mosek_fusion_Parameter._match_alt_getIndex_I(*args): # int32
      return self._getIndex_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getIndex(int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Parameter._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Parameter._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Parameter._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.slice(int32,int32)\n\tmosek.fusion.Parameter.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getValue(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getValue_(*args): # 
      return self._getValue_(*args)
    elif mosek_fusion_Parameter._match_alt_getValue_(*args): # 
      return self._getValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list getValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getValue()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Parameter._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getSize()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Parameter._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getModel()')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_Parameter._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getDim(int32)')
  def __repr__(self): return 'mosek.fusion.Parameter'
  @staticmethod
  def _match_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0))
  @staticmethod
  def _match_alt_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  def _getAllIndexes_alt__3II(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = self._getAllIndexes__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getAllIndexes__3II(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_getIndex_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getIndex_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getIndex_alt_I(self,_t__0):
    return self._getIndex_I(numpy.int32(__0))
  def _getIndex_I(self,_0):
   pass
  @staticmethod
  def _match_getSp__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_getSp__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1))
  def _getSp_alt__3JI(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _1 = self._getSp__3JI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getSp__3JI(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  def _getNumNonzero_alt_(self,):
    return self._getNumNonzero_()
  def _getNumNonzero_(self,):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
  @staticmethod
  def _match_getValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getValue_(*args):
    if len(args) != 0: return False
    return True
  def _getValue_alt_(self,):
    return self._getValue_()
  def _getValue_(self,):
   pass
  @staticmethod
  def _match_setValue__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_setValue__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  def _setValue_alt__3_5D(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = self._setValue__3_5D(_0)
   return _1
  def _setValue__3_5D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_setValue__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setValue__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setValue_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setValue__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setValue__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_setValue_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_setValue_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _setValue_alt_D(self,_t__0):
    return self._setValue_D(numpy.float64(__0))
  def _setValue_D(self,_0):
   pass
 return Parameter
mosek_fusion_Parameter=__mk_mosek_fusion_Parameter()
del __mk_mosek_fusion_Parameter
#BEFORE CLASS
def __mk_mosek_fusion_FusionException():
 class FusionException(Exception):
  __slots__ = ['_FusionException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionException.__new__(FusionException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionException
mosek_fusion_FusionException=__mk_mosek_fusion_FusionException()
del __mk_mosek_fusion_FusionException
#BEFORE CLASS
def __mk_mosek_fusion_SolutionError():
 class SolutionError(mosek_fusion_FusionException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionError.ctor()\n\tmosek.fusion.SolutionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SolutionError'
  @staticmethod
  def _ctor_():
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionException._ctor_init_S(self,"Solution is invalid or undefined")
  @staticmethod
  def _ctor_S(msg):
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionException._ctor_init_S(self,msg)
 return SolutionError
mosek_fusion_SolutionError=__mk_mosek_fusion_SolutionError()
del __mk_mosek_fusion_SolutionError
#BEFORE CLASS
def __mk_mosek_fusion_UnimplementedError():
 class UnimplementedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnimplementedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnimplementedError'
  @staticmethod
  def _ctor_S(msg):
    o = UnimplementedError.__new__(UnimplementedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnimplementedError
mosek_fusion_UnimplementedError=__mk_mosek_fusion_UnimplementedError()
del __mk_mosek_fusion_UnimplementedError
#BEFORE CLASS
def __mk_mosek_fusion_FatalError():
 class FatalError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FatalError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.FatalError'
  @staticmethod
  def _ctor_S(msg):
    o = FatalError.__new__(FatalError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return FatalError
mosek_fusion_FatalError=__mk_mosek_fusion_FatalError()
del __mk_mosek_fusion_FatalError
#BEFORE CLASS
def __mk_mosek_fusion_UnexpectedError():
 class UnexpectedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FusionException_2(*args): # mosek.fusion.FusionException
      self._ctor_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):# mosek.fusion.FusionException
      self._ctor_alt_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnexpectedError.ctor(mosek.fusion.FusionException)\n\tmosek.fusion.UnexpectedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnexpectedError'
  @staticmethod
  def _ctor_Lmosek_4fusion_4FusionException_2(e):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_Lmosek_4fusion_4FusionException_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FusionException_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FusionException_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FusionException_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FusionException_2(e)
  def _ctor_init_Lmosek_4fusion_4FusionException_2(self,e):
   Exception.__init__(self,e._toString_())
  @staticmethod
  def _ctor_S(msg):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnexpectedError
mosek_fusion_UnexpectedError=__mk_mosek_fusion_UnexpectedError()
del __mk_mosek_fusion_UnexpectedError
#BEFORE CLASS
def __mk_mosek_fusion_FusionRuntimeException():
 class FusionRuntimeException(Exception):
  __slots__ = ['_FusionRuntimeException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionRuntimeException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionRuntimeException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionRuntimeException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionRuntimeException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionRuntimeException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionRuntimeException.__new__(FusionRuntimeException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionRuntimeException
mosek_fusion_FusionRuntimeException=__mk_mosek_fusion_FusionRuntimeException()
del __mk_mosek_fusion_FusionRuntimeException
#BEFORE CLASS
def __mk_mosek_fusion_SparseFormatError():
 class SparseFormatError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SparseFormatError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SparseFormatError'
  @staticmethod
  def _ctor_S(msg):
    o = SparseFormatError.__new__(SparseFormatError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SparseFormatError
mosek_fusion_SparseFormatError=__mk_mosek_fusion_SparseFormatError()
del __mk_mosek_fusion_SparseFormatError
#BEFORE CLASS
def __mk_mosek_fusion_SliceError():
 class SliceError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SliceError.ctor()\n\tmosek.fusion.SliceError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SliceError'
  @staticmethod
  def _ctor_():
    o = SliceError.__new__(SliceError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Invalid slice range")
  @staticmethod
  def _ctor_S(msg):
    o = SliceError.__new__(SliceError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SliceError
mosek_fusion_SliceError=__mk_mosek_fusion_SliceError()
del __mk_mosek_fusion_SliceError
#BEFORE CLASS
def __mk_mosek_fusion_UpdateError():
 class UpdateError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UpdateError.ctor()\n\tmosek.fusion.UpdateError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UpdateError'
  @staticmethod
  def _ctor_():
    o = UpdateError.__new__(UpdateError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Cannot update parameterized item")
  @staticmethod
  def _ctor_S(msg):
    o = UpdateError.__new__(UpdateError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return UpdateError
mosek_fusion_UpdateError=__mk_mosek_fusion_UpdateError()
del __mk_mosek_fusion_UpdateError
#BEFORE CLASS
def __mk_mosek_fusion_SetDefinitionError():
 class SetDefinitionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SetDefinitionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SetDefinitionError'
  @staticmethod
  def _ctor_S(msg):
    o = SetDefinitionError.__new__(SetDefinitionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SetDefinitionError
mosek_fusion_SetDefinitionError=__mk_mosek_fusion_SetDefinitionError()
del __mk_mosek_fusion_SetDefinitionError
#BEFORE CLASS
def __mk_mosek_fusion_OptimizeError():
 class OptimizeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.OptimizeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.OptimizeError'
  @staticmethod
  def _ctor_S(msg):
    o = OptimizeError.__new__(OptimizeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return OptimizeError
mosek_fusion_OptimizeError=__mk_mosek_fusion_OptimizeError()
del __mk_mosek_fusion_OptimizeError
#BEFORE CLASS
def __mk_mosek_fusion_NameError():
 class NameError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.NameError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.NameError'
  @staticmethod
  def _ctor_S(msg):
    o = NameError.__new__(NameError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return NameError
mosek_fusion_NameError=__mk_mosek_fusion_NameError()
del __mk_mosek_fusion_NameError
#BEFORE CLASS
def __mk_mosek_fusion_DeletionError():
 class DeletionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DeletionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DeletionError'
  @staticmethod
  def _ctor_S(msg):
    o = DeletionError.__new__(DeletionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DeletionError
mosek_fusion_DeletionError=__mk_mosek_fusion_DeletionError()
del __mk_mosek_fusion_DeletionError
#BEFORE CLASS
def __mk_mosek_fusion_ModelError():
 class ModelError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ModelError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ModelError'
  @staticmethod
  def _ctor_S(msg):
    o = ModelError.__new__(ModelError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ModelError
mosek_fusion_ModelError=__mk_mosek_fusion_ModelError()
del __mk_mosek_fusion_ModelError
#BEFORE CLASS
def __mk_mosek_fusion_MatrixError():
 class MatrixError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.MatrixError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.MatrixError'
  @staticmethod
  def _ctor_S(msg):
    o = MatrixError.__new__(MatrixError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return MatrixError
mosek_fusion_MatrixError=__mk_mosek_fusion_MatrixError()
del __mk_mosek_fusion_MatrixError
#BEFORE CLASS
def __mk_mosek_fusion_DimensionError():
 class DimensionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DimensionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DimensionError'
  @staticmethod
  def _ctor_S(msg):
    o = DimensionError.__new__(DimensionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DimensionError
mosek_fusion_DimensionError=__mk_mosek_fusion_DimensionError()
del __mk_mosek_fusion_DimensionError
#BEFORE CLASS
def __mk_mosek_fusion_LengthError():
 class LengthError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LengthError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.LengthError'
  @staticmethod
  def _ctor_S(msg):
    o = LengthError.__new__(LengthError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return LengthError
mosek_fusion_LengthError=__mk_mosek_fusion_LengthError()
del __mk_mosek_fusion_LengthError
#BEFORE CLASS
def __mk_mosek_fusion_RangeError():
 class RangeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RangeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.RangeError'
  @staticmethod
  def _ctor_S(msg):
    o = RangeError.__new__(RangeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return RangeError
mosek_fusion_RangeError=__mk_mosek_fusion_RangeError()
del __mk_mosek_fusion_RangeError
#BEFORE CLASS
def __mk_mosek_fusion_IndexError():
 class IndexError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IndexError'
  @staticmethod
  def _ctor_S(msg):
    o = IndexError.__new__(IndexError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IndexError
mosek_fusion_IndexError=__mk_mosek_fusion_IndexError()
del __mk_mosek_fusion_IndexError
#BEFORE CLASS
def __mk_mosek_fusion_DomainError():
 class DomainError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DomainError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DomainError'
  @staticmethod
  def _ctor_S(msg):
    o = DomainError.__new__(DomainError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DomainError
mosek_fusion_DomainError=__mk_mosek_fusion_DomainError()
del __mk_mosek_fusion_DomainError
#BEFORE CLASS
def __mk_mosek_fusion_ValueConversionError():
 class ValueConversionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ValueConversionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ValueConversionError'
  @staticmethod
  def _ctor_S(msg):
    o = ValueConversionError.__new__(ValueConversionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ValueConversionError
mosek_fusion_ValueConversionError=__mk_mosek_fusion_ValueConversionError()
del __mk_mosek_fusion_ValueConversionError
#BEFORE CLASS
def __mk_mosek_fusion_ParameterError():
 class ParameterError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ParameterError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ParameterError'
  @staticmethod
  def _ctor_S(msg):
    o = ParameterError.__new__(ParameterError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ParameterError
mosek_fusion_ParameterError=__mk_mosek_fusion_ParameterError()
del __mk_mosek_fusion_ParameterError
#BEFORE CLASS
def __mk_mosek_fusion_ExpressionError():
 class ExpressionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExpressionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ExpressionError'
  @staticmethod
  def _ctor_S(msg):
    o = ExpressionError.__new__(ExpressionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ExpressionError
mosek_fusion_ExpressionError=__mk_mosek_fusion_ExpressionError()
del __mk_mosek_fusion_ExpressionError
#BEFORE CLASS
def __mk_mosek_fusion_IOError():
 class IOError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IOError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IOError'
  @staticmethod
  def _ctor_S(msg):
    o = IOError.__new__(IOError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IOError
mosek_fusion_IOError=__mk_mosek_fusion_IOError()
del __mk_mosek_fusion_IOError
def __mk_mosek_fusion_BaseModel():
  import threading
  import mosek
  import mosek.fusion
  import numpy
  
  
  class BaseModel(object):
    _lock = threading.Lock()
    _global_env = None
    _global_env_counter = 0
  
    @classmethod
    def _globalEnv(self):
      self._lock.acquire()
      try:
        if BaseModel._global_env is None:
          try:
            env = mosek.Env()
            BaseModel._global_env = env
            BaseModel._global_env_counter += 1
          except mosek.Exception as e:
            raise UnexpectedError(e)
        return BaseModel._global_env
      finally:
        self._lock.release()
  
    @classmethod
    def _env_1putlicensecode__3I(self,code):
      self._globalEnv().putlicensecode(code)
  
    @classmethod
    def _env_1putlicensepath_S(self,path):
      self._globalEnv().putlicensepath(path)
  
    @classmethod
    def _env_1putlicensewait_Z(self,yn):
      if yn:
        self._globalEnv().putlicensewait(1)
      else:
        self._globalEnv().putlicensewait(0)
  
    @classmethod
    def _env_1getversion_(self):
      return ".".join([str(_) for _ in mosek.Env.getversion()])
  
    def __callback(self,callbackkey,dinf,iinf,liinf):
      if self.__user_cb is not None:
        try:
          if self.__user_cb(callbackkey,dinf,iinf,liinf):
            self.__break = True
        except:
          self.__break = True
      if self.__user_pgs is not None:
        try:
          if self.__user_pgs(callbackkey):
            self.__break = True
        except:
          self.__break = True
      return 1 if self.__break else 0
  
    def _ctor_init_SS(self,name,licfile):
      env = self._globalEnv()
      self.__modelname = name
      self.__break = False
      task = mosek.Task(self._global_env, 0, 0);
      self.__user_cb = None
      self.__user_pgs = None
      finished = False
      try:
        task.putintparam(mosek.iparam.log_expand,0);
        self.__task = task
        if name is not None:
          task.puttaskname(name)
  
        self._synched = mosek_fusion_SolutionStatus.Optimal;
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None
  
        self.__objname = None
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def _ctor_init_Lmosek_4fusion_4BaseModel_2(self,m):
      env = self._globalEnv()
      self.__modelname = m.__modelname
      self.__break = False
      self.__user_cb = None
      self.__user_pgs = None
      task = mosek.Task(m.__task)
      finished = False
      try:
        self.__task = task
        self._synched = m._synched
  
        self._sol_itr = m._sol_itr._clone_() if m._sol_itr is not None else None
        self._sol_bas = m._sol_bas._clone_() if m._sol_bas is not None else None
        self._sol_itg = m._sol_itg._clone_() if m._sol_itg is not None else None
  
        self.__objname = m.__objname
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def __del__(self):
        lock = self._lock
        if hasattr(self,'_BaseModel__task'):
          lock.acquire()
          try:
            task = self.__task
            BaseModel._global_env_counter -= 1
            task.__del__()
  
            for a in self.__class__.__slots__ + ['_sol_itr','_sol_bas','_sol_itg',
                                                 '_BaseModel__user_cb','_BaseModel__user_pgs','_BaseModel__loghandler','_BaseModel__logwriter','_BaseModel__task']:
              try: delattr(self,a)
              except AttributeError: pass
          finally:
            lock.release()
  
    def __enter__(self):
      return self
    def __exit__(self,exc_type,exc_val,exc_tb):
      self.__del__()
    def _dispose_(self):
      self.__del__()
  
    def _task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,handler):
      self.__user_cb = handler
    def _task_1setCallbackHandler_LSystem_4CallbackHandler_2(self,handler):
      self.__user_pgs = handler
  
    def _task_1setLogHandler_LSystem_4StreamWriter_2(self,handler):
      """
      Set the object to handle log output from the solver.
  
      The handler object must have a write method accepting a string.
      """
      self.__logwriter = handler
  
    def _task_1put_1param_SS(self,name,value):
      self.__task.putnastrparam(name,value)
    def _task_1put_1param_SD(self,name,value):
      self.__task.putnadouparam(name,value)
    def _task_1put_1param_SI(self,name,value):
      self.__task.putnaintparam(name,value)
  
    def _task_1get_1dinf_S(self,name):
      key = mosek_fusion_SolverInfo._getdouinf(name)
      if key is None:
        raise NameError("Invalid double info name '%s'" % name)
      else:
        return self.__task.getdouinf(key)
  
    def _task_1get_1iinf_S(self,name):
      key = mosek_fusion_SolverInfo._getintinf(name)
      if key is None:
        raise NameError("Invalid integer info name '%s'" % name)
      else:
        return self.__task.getintinf(key)
  
    def _task_1get_1liinf_S(self,name):
      key = mosek_fusion_SolverInfo._getlintinf(name)
      if key is None:
        raise NameError("Invalid long integer info name '%s'" % name)
      else:
        return self.__task.getlintinf(key)
  
    def _numVariables_ (self):
      return len(self.__vars)
    def _numConstraints_ (self):
      return len(self.__cons)
  
    def _task_1format_1var_1names__3IS_3I_3J(self,subj,fmt,dims,sp):  self.__task.generatevarnames(subj,fmt,dims,sp)
    def _task_1format_1con_1names__3IS_3I_3J(self,subj,fmt,dims,sp):  self.__task.generateconnames(subj,fmt,dims,sp)
    def _task_1format_1cone_1names__3IS_3I_3J(self,subj,fmt,dims,sp): self.__task.generateconenames(subj,fmt,dims,sp)
  
    def _task_1con_1name_IS(self,idx,name):
      self.__task.putconname(idx,name)
    def _task_1var_1name_IS(self,idx, name):
      self.__task.putvarname(idx,name)
  
    def _task_1cone_1name_IS(self,idx,name):
      self.__task.putconename(idx,name)
  
    def _task_1numcon_(self):
      return self.__task.getnumcon()
    def _task_1numvar_(self):
      return self.__task.getnumvar()
    def _task_1numcone_(self):
      return self.__task.getnumcone()
  
    def __task_putvarboundlist(self,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putvarboundlist(idxs,bka,bl,bu)
  
    def __task_putconboundlist(self,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putconboundlist(idxs,bka,bl,bu)
  
    def _task_1con_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.fx);
  
    def _task_1con_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.lo);
  
    def _task_1con_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.up);
  
    def _task_1con_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putconboundlist( idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1con_1putboundlist_1fr__3I(self,idxs):
      self.__task_putconboundlist( idxs, None, None, mosek.boundkey.fr);
  
  
    def _task_1var_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.fx);
  
    def _task_1var_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.lo);
  
    def _task_1var_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.up);
  
    def _task_1var_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putvarboundlist( idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1var_1putboundlist_1fr__3I(self,idxs):
      self.__task_putvarboundlist( idxs, None, None, mosek.boundkey.fr);
  
    def _task_1var_1putintlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_int] * len(idxs))
    def _task_1var_1putcontlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_cont] * len(idxs))
  
  
    def _task_1task_1optimize_ (self):
      try:
        self.__task.optimize()
        self.__task.solutionsummary(streamtype.log)
      except mosek.Error as e:
        raise OptimizeError("Error occurred while optimizing")
  
    def __task_appendvars(self,num):
      idx = self.__task.getnumvar()
      self.__task.appendvars(num)
      return idx
  
    def __task_appendcons(self,num):
      idx = self.__task.getnumcon()
      self.__task.appendcons(num)
      return idx
  
    def _task_1append_1var_I(self,num):
      return self.__task_appendvars(num)
  
    def _task_1append_1con_I(self,num):
      return self.__task_appendcons(num)
  
    def _task_1append_1zerocones_I(self, numcone):
      self.__task.appendconesseq([mosek.conetype.zero for i in range(numcone)], numpy.zeros(numcone),numpy.zeros(numcone,int), 0)
    def _task_1clear_1cones__3I(self, idxs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.zero, 0.0, 0,[])
    def _task_1put_1zerocones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.zero, 0.0, membs[i*conesize:(i+1)*conesize])
    def _task_1put_1quadcones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.quad, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1rquadcones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.rquad, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1pexpcones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.pexp, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1ppowcones__3III_3I_3D(self, idxs, conesize, numcone, membs, alpha):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.ppow, alpha[i], membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1dexpcones__3III_3I(self, idxs, conesize, numcone, membs):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.dexp, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1put_1dpowcones__3III_3I_3D(self, idxs, conesize, numcone, membs, alpha):
      for i,k in enumerate(idxs):
        self.__task.putcone(k,mosek.conetype.dpow, alpha[i], membs[i*conesize:(i+1)*conesize])
  
    def _task_1putarowlist__3I_3J_3I_3D(self,sub, ptrb, subj, cof):
      num   = len(sub)
      self.__task.putarowlist(sub, ptrb[:-1], ptrb[1:], subj, cof);
  
    def _task_1cleararowlist__3I(self,sub):
      num  = len(sub)
      ptr = numpy.zeros(num,dtype=numpy.int64)
      self.__task.putarowlist(sub, ptr, ptr, numpy.zeros(0,dtype=numpy.int32), numpy.zeros(0,dtype=numpy.float64))
  
      # This is probably awfully slow
      nnz   = self.__task.getnumbaranz()
      if nnz > 0:
        idxij = numpy.zeros(nnz,dtype=numpy.int64)
        self.__task.getbarasparsity(idxij)
        sub = set(sub)
        for idx in idxij:
          i,j = self.__task.getbaraidxij(idx)
          if i in sub:
            self.__task.putbaraij(i,j,[],[])
  
    def _task_1clearacollist__3I(self,sub):
      num  = len(sub)
      ptr = numpy.zeros(num,dtype=numpy.int64)
      self.__task.putacollist(sub, ptr, ptr, numpy.zeros(0,dtype=numpy.int32), numpy.zeros(0,dtype=numpy.float64))
  
    def _task_1putaijlist__3I_3I_3DJ(self,subi,subj,cof,num):
      self.__task.putaijlist(subi[:num],subj[:num],cof[:num])
  
    def _task_1putobjectivename_S(self,name):
      self.__task.putobjname("" if name is None else name)
  
    def _task_1putobjective_Z_3I_3DD(self,maximize,subj,cof,cfix):
      c = numpy.zeros(self.__task.getnumvar(),numpy.float64)
      idxs = numpy.arange(0,len(c),dtype=numpy.int32)
      for i in range(len(subj)):
        c[subj[i]] += cof[i]
      self.__task.putclist(idxs,c)
      self.__task.putcfix(cfix)
      self.__task.putobjsense(mosek.objsense.maximize if maximize else mosek.objsense.minimize)
  
    def _task_1putclist__3I_3D(self,subj,cof):
      self.__task.putclist(subj,cof)
  
  
    def _task_1appendsymmatlist__3I_3J_3I_3I_3D(self,dim,nz,subi,subj,cof):
      r = numpy.zeros(len(dim),numpy.int64)
      self.__task.appendsparsesymmatlist(dim,nz,subi,subj,cof,r)
      return r
  
    def _task_1putbarc__3I_3I_3I_3D(self,subj,subk,subl,val):
      self.__task.putbarcblocktriplet(len(subj),subj,subk,subl,val)
  
    def _task_1putbaraijlist__3I_3I_3J(self,subi,subj,matidx):
      alpha = numpy.ones(len(subi),numpy.float64)
      ptr = numpy.arange(0,len(subi)+1,dtype=numpy.int64)
      self.__task.putbaraijlist(subi,subj,ptr[:-1],ptr[1:],matidx,alpha)
  
    def _task_1putbararowlist__3I_3J_3I_3J(self,subi,ptr,subj,matidx):
      alpha = numpy.ones(len(subj),numpy.float64)
      nummat = numpy.ones(len(subj),numpy.int64)
      self.__task.putbararowlist(subi,ptr[:-1],ptr[1:],subj,nummat,matidx,alpha)
  
  
    def _task_1barvardim_I(self,index):
      return self.__task.getdimbarvarj(index)
  
    def _task_1numbarvar_(self):
      return self.__task.getnumbarvar()
  
    def _task_1barvar_1name_IS(self, idx, name):
      self.__task.putbarvarname(idx,name)
  
    def _task_1append_1barvar_II(self,size, num):
      res = self.__task.getnumbarvar()
      self.__task.appendbarvars([size] * num)
      return res
  
    def _task_1setnumvar_I(self,num):
      numvar = self.__task.getnumvar()
      if numvar > num:
        self.__task.removevars(range(num,numvar))
  
  
    def _task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(self,whichsol,first,last,xx):
      if   whichsol == mosek_fusion_SolutionType.Interior:
        self.__task.putxxslice(mosek.soltype.itr, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Integer:
        self.__task.putxxslice(mosek.soltype.itg, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Basic:
        self.__task.putxxslice(mosek.soltype.bas, first,last,xx)
  
    def _task_1cleanup_IIII(self,inumvar,inumcon,inumcone,inumbarvar):
      numvar  = self.__task.getnumvar()
      numcon  = self.__task.getnumcon()
      numcone = self.__task.getnumcone()
      numbarvar = self.__task.getnumbarvar()
  
      if inumcone < numcone:
        self.__task.removecones(range(inumcone,numcone))
  
      if inumvar < numvar:
        n = numvar-inumvar
        vals = numpy.zeros((n,), numpy.float64)
        bk   = [ mosek.boundkey.fx for i in range(n) ]
        self.__task.putvarboundslice(inumvar,numvar,bk, vals, vals)
        #idxs = range(inumvar,numvar)
        #self.__task.removevars(idxs)
  
      if (inumcon < numcon):
        idxs = range(inumcon,numcon)
        self.__task.removecons(idxs)
  
      if (inumbarvar < numbarvar):
        self.__task.removebarvars(range(inumbarvar,numbarvar))
  
    @staticmethod
    def __convertSolutionStatus(soltype,sol,status,prosta):
      pd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
      }
  
      dd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
      }
  
      psd = {
          mosek.prosta.unknown  :                   mosek_fusion_ProblemStatus.Unknown,
          mosek.prosta.prim_and_dual_feas :         mosek_fusion_ProblemStatus.PrimalAndDualFeasible,
          mosek.prosta.prim_feas :                  mosek_fusion_ProblemStatus.PrimalFeasible,
          mosek.prosta.dual_feas :                  mosek_fusion_ProblemStatus.DualFeasible,
          mosek.prosta.prim_infeas :                mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.dual_infeas :                mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_and_dual_infeas :       mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.ill_posed :                  mosek_fusion_ProblemStatus.IllPosed,
          mosek.prosta.prim_infeas_or_unbounded :   mosek_fusion_ProblemStatus.PrimalInfeasibleOrUnbounded,
        }
  
      try: sol.pstatus = pd[status]
      except KeyError: sol.pstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.dstatus = dd[status]
      except KeyError: sol.dstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.probstatus = psd[prosta]
      except KeyError: sol.probstatus = mosek_fusion_SolutionStatus.Unknown
  
  
    @staticmethod
    def _matchargs_task_1write_S(self,*args):
        return True
    def _task_1write_S(self,filename):
        self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
        self.__task.putintparam(mosek.iparam.write_ignore_incompatible_items, 1)
        self.__task.writedata(filename)
  
    def _task_1write(self,filename):
      return self._writeProblem_S(filename)
  
    def _task_1get_(self):
      return self.__task
  
    def _task_1break_1solve_(self):
      self.__break = True
  
    def _task_1putoptserver_1host_S(self, addr):
      self.__task.putoptserverhost(addr)
  
    @staticmethod
    def _matchargs_task_1solve_(self,*args):
      return True
    def _task_1solve_ZSS(self, remote, server, port):
      task = self.__task
      ok = False
      try:
        trmcode = mosek.rescode.ok
        try:
          self.__break = False
          if remote:
            trmcode = task.optimizermt(server, port)
          else:
            trmcode = task.optimize()
          task.solutionsummary(mosek.streamtype.log)
        except mosek.Error as e:
          raise mosek_fusion_OptimizeError(str(e))
  
        numcon  = task.getnumcon()
        numvar  = task.getnumvar()
        numcone = task.getnumcone()
        numbarvar = task.getnumbarvar()
        barvarveclen = 0
        for j in range(numbarvar):
          barxjdim = task.getdimbarvarj(j)
          barvarveclen += barxjdim * (1+barxjdim)/2
        barvarveclen = numpy.int32(barvarveclen)
  
        sol_bas_def = 0 != task.solutiondef(mosek.soltype.bas)
        sol_itr_def = 0 != task.solutiondef(mosek.soltype.itr)
        sol_itg_def = 0 != task.solutiondef(mosek.soltype.itg)
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None
  
        if sol_itr_def:
          self._sol_itr = mosek_fusion_SolutionStruct(numvar,numcon,numcone,barvarveclen)
          sol_itr = self._sol_itr
          prosta,solsta = task.getsolution(
            mosek.soltype.itr,
            #sol_itr.skc,sol_itr.skx,sol_itr.skn,
            None,None,None,
            sol_itr.xc,sol_itr.xx,sol_itr.y,
            sol_itr.slc,sol_itr.suc,
            sol_itr.slx,sol_itr.sux,
            sol_itr.snx)
  
          if (numvar > 0):
            if sol_itr.snx is not None:
              sol_itr.yx[:] = sol_itr.slx - sol_itr.sux + sol_itr.snx
            else:
              sol_itr.yx[:] = sol_itr.slx - sol_itr.sux
  
          if barvarveclen > 0:
            task.getbarxslice(mosek.soltype.itr, 0, numbarvar, barvarveclen, self._sol_itr.barx)
            task.getbarsslice(mosek.soltype.itr, 0, numbarvar, barvarveclen, self._sol_itr.bars)
  
          sol_itr.pobj = task.getprimalobj(mosek.soltype.itr)
          sol_itr.dobj = task.getdualobj  (mosek.soltype.itr)
          self.__convertSolutionStatus(mosek.soltype.itr, sol_itr, solsta,prosta);
          #print "got itr sol, stat = %s/%s" % (sol_itr.pstatus,sol_itr.dstatus)
  
        if sol_bas_def:
          self._sol_bas = mosek_fusion_SolutionStruct(numvar,numcon,numcone,barvarveclen);
          sol_bas = self._sol_bas
          prosta,solsta = task.getsolution(
            mosek.soltype.bas,
            #sol_bas.skc,sol_bas.skx,sol_bas.skn,
            None,None,None,
            sol_bas.xc,sol_bas.xx,sol_bas.y,
            sol_bas.slc,sol_bas.suc,
            sol_bas.slx,sol_bas.sux,
            sol_bas.snx)
  
          if (numvar > 0):
            sol_bas.yx[:] = sol_bas.slx - sol_bas.sux
  
          # NOTE: this probably never happens:
          if numbarvar > 0:
            task.getbarxslice(mosek.soltype.bas, 0, numbarvar, barvarveclen, self._sol_bas.barx)
            task.getbarsslice(mosek.soltype.bas, 0, numbarvar, barvarveclen, self._sol_bas.bars)
  
          sol_bas.pobj = task.getprimalobj(mosek.soltype.bas)
          sol_bas.dobj = task.getdualobj  (mosek.soltype.bas)
          self.__convertSolutionStatus(mosek.soltype.bas, sol_bas, solsta,prosta);
  
          #print "got bas sol, stat = %s/%s" % (sol_bas.pstatus,sol_bas.dstatus)
  
        if sol_itg_def:
          self._sol_itg = mosek_fusion_SolutionStruct(numvar,numcon,numcone,barvarveclen);
          sol_itg = self._sol_itg
          prosta,solsta = task.getsolution(
            mosek.soltype.itg,
            #sol_itg.skc,sol_itg.skx,sol_itg.skn,
            None,None,None,
            sol_itg.xc,sol_itg.xx,sol_itg.y,
            sol_itg.slc,sol_itg.suc,
            sol_itg.slx,sol_itg.sux,
            sol_itg.snx)
  
          # NOTE: this probably wont happen for a long time:
          if barvarveclen > 0:
            task.getbarxslice(mosek.soltype.itg, 0, numbarvar, barvarveclen, self._sol_itg.barx)
            task.getbarsslice(mosek.soltype.itg, 0, numbarvar, barvarveclen, self._sol_itg.bars)
  
          sol_itg.pobj = task.getprimalobj(mosek.soltype.itg)
          self.__convertSolutionStatus(mosek.soltype.itg, sol_itg, solsta,prosta);
        ok = True
  
      finally:
        if not ok: # means exception
          self._sol_itr = None
          self._sol_bas = None
          self._sol_itg = None
  
    @staticmethod
    def _env_1syeig_I_3D_3D(n,a,w): BaseModel._globalEnv().syeig(n,a,w)
    @staticmethod
    def _env_1syevd_I_3D_3D(n,a,w): BaseModel._globalEnv().syevd(n,a,w)
    #@staticmethod
    #def _env_1potrf_I_3D(n,a):      BaseModel._globalEnv().potrf(n,a)
  
  return BaseModel
mosek_fusion_BaseModel=__mk_mosek_fusion_BaseModel()
#BEFORE CLASS
def __mk_mosek_fusion_Model():
 class Model(mosek_fusion_BaseModel):
  __slots__ = ['_Model__xs','_Model__ws','_Model__rs','_Model__con_map','_Model__cons','_Model__natconmap_objcconst','_Model__natconmap_objcode','_Model__natconmap_objcodeptr','_Model__natconmap_objcodenidx','_Model__natconmap_cconst','_Model__natconmap_code','_Model__natconmap_codeptr','_Model__natconmap_codenidx','_Model__natconmap_coderowptre','_Model__natconmap_coderowptrb','_Model__natconmap_codeatomtop','_Model__natconmap_codenztop','_Model__natconmap_numparameterized','_Model__param_value','_Model__param_num','_Model__par_map','_Model__numparameter','_Model__parameters','_Model__natconmap_type','_Model__natconmap_idx','_Model__natconmap_slackidx','_Model__natconmap_blockid','_Model__natconmap','_Model__initsol_xx_flag','_Model__initsol_xx','_Model__var_map','_Model__barvars','_Model__natbarvarmap_ptr','_Model__natbarvarmap_num','_Model__natbarvarmap_nblock','_Model__natbarvar_dim','_Model__natbarvar_ptr','_Model__natbarvar_numbarvarelm','_Model__natbarvar_j','_Model__natbarvar_i','_Model__natbarvar_idx','_Model__natvarmap_type','_Model__natconemap_dim','_Model__natconemap','_Model__vars','_Model__bfixidx','_Model__natvarmap_idx','_Model__natvarmap_blockid','_Model__natvarmap','_Model__solutionptr','_Model__acceptable_sol','_Model__model_name']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Model.ctor()\n\tmosek.fusion.Model.ctor(string)')
  def getVariableValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariableValues_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableValues_Z_3J_3DI(*args)
    elif mosek_fusion_Model._match_alt_getVariableValues_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableValues_alt_Z_3J_3DI(*args)
    else:
      raise ValueError('Invalid argument list getVariableValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariableValues(bool,array(int64,ndim=1),array(double,ndim=1),int32)')
  def acceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_Model._match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list acceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)')
  def dispose(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dispose_(*args): # 
      return self._dispose_(*args)
    elif mosek_fusion_Model._match_alt_dispose_(*args): # 
      return self._dispose_alt_(*args)
    else:
      raise ValueError('Invalid argument list dispose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dispose()')
  def hasConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasConstraint_S(*args): # string
      return self._hasConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_hasConstraint_S(*args): # string
      return self._hasConstraint_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasConstraint(string)')
  def getSolverIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverIntInfo(string)')
  def flushNames(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushNames_(*args): # 
      return self._flushNames_(*args)
    elif mosek_fusion_Model._match_alt_flushNames_(*args): # 
      return self._flushNames_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushNames('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushNames()')
  def selectedSolution(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list selectedSolution('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.selectedSolution(mosek.fusion.SolutionType)')
  def parameter(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_parameter_(*args): # 
      return self._parameter_(*args)
    elif mosek_fusion_Model._match_alt_parameter_(*args): # 
      return self._parameter_alt_(*args)
    elif mosek_fusion_Model._match_parameter_S(*args): # string
      return self._parameter_S(*args)
    elif mosek_fusion_Model._match_alt_parameter_S(*args): # string
      return self._parameter_alt_S(*args)
    elif mosek_fusion_Model._match_parameter_I(*args): # int32
      return self._parameter_I(*args)
    elif mosek_fusion_Model._match_alt_parameter_I(*args): # int32
      return self._parameter_alt_I(*args)
    elif mosek_fusion_Model._match_parameter__3I(*args): # []int32
      return self._parameter__3I(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I(*args): # []int32
      return self._parameter_alt__3I(*args)
    elif mosek_fusion_Model._match_parameter_SI(*args): # string,int32
      return self._parameter_SI(*args)
    elif mosek_fusion_Model._match_alt_parameter_SI(*args): # string,int32
      return self._parameter_alt_SI(*args)
    elif mosek_fusion_Model._match_parameter__3I_3J(*args): # []int32,[]int64
      return self._parameter__3I_3J(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I_3J(*args): # []int32,[]int64
      return self._parameter_alt__3I_3J(*args)
    elif mosek_fusion_Model._match_parameter__3I_3_5I(*args): # []int32,[,]int32
      return self._parameter__3I_3_5I(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I_3_5I(*args): # []int32,[,]int32
      return self._parameter_alt__3I_3_5I(*args)
    elif mosek_fusion_Model._match_parameter_S_3I(*args): # string,[]int32
      return self._parameter_S_3I(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I(*args): # string,[]int32
      return self._parameter_alt_S_3I(*args)
    elif mosek_fusion_Model._match_parameter_II(*args): # int32,int32
      return self._parameter_II(*args)
    elif mosek_fusion_Model._match_alt_parameter_II(*args): # int32,int32
      return self._parameter_alt_II(*args)
    elif mosek_fusion_Model._match_parameter_S_3I_3J(*args): # string,[]int32,[]int64
      return self._parameter_S_3I_3J(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I_3J(*args): # string,[]int32,[]int64
      return self._parameter_alt_S_3I_3J(*args)
    elif mosek_fusion_Model._match_parameter_III(*args): # int32,int32,int32
      return self._parameter_III(*args)
    elif mosek_fusion_Model._match_alt_parameter_III(*args): # int32,int32,int32
      return self._parameter_alt_III(*args)
    elif mosek_fusion_Model._match_parameter_SII(*args): # string,int32,int32
      return self._parameter_SII(*args)
    elif mosek_fusion_Model._match_alt_parameter_SII(*args): # string,int32,int32
      return self._parameter_alt_SII(*args)
    elif mosek_fusion_Model._match_parameter_S_3I_3_5I(*args): # string,[]int32,[,]int32
      return self._parameter_S_3I_3_5I(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I_3_5I(*args): # string,[]int32,[,]int32
      return self._parameter_alt_S_3I_3_5I(*args)
    elif mosek_fusion_Model._match_parameter_SIII(*args): # string,int32,int32,int32
      return self._parameter_SIII(*args)
    elif mosek_fusion_Model._match_alt_parameter_SIII(*args): # string,int32,int32,int32
      return self._parameter_alt_SIII(*args)
    else:
      raise ValueError('Invalid argument list parameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.parameter()\n\tmosek.fusion.Model.parameter(string)\n\tmosek.fusion.Model.parameter(int32)\n\tmosek.fusion.Model.parameter(array(int32,ndim=1))\n\tmosek.fusion.Model.parameter(string,int32)\n\tmosek.fusion.Model.parameter(array(int32,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Model.parameter(array(int32,ndim=1),array(int32,ndim=2))\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1))\n\tmosek.fusion.Model.parameter(int32,int32)\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Model.parameter(int32,int32,int32)\n\tmosek.fusion.Model.parameter(string,int32,int32)\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1),array(int32,ndim=2))\n\tmosek.fusion.Model.parameter(string,int32,int32,int32)')
  def breakSolver(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_breakSolver_(*args): # 
      return self._breakSolver_(*args)
    elif mosek_fusion_Model._match_alt_breakSolver_(*args): # 
      return self._breakSolver_alt_(*args)
    else:
      raise ValueError('Invalid argument list breakSolver('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.breakSolver()')
  def constraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list constraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.RangeDomain)')
  def getConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraint_S(*args): # string
      return self._getConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_S(*args): # string
      return self._getConstraint_alt_S(*args)
    elif mosek_fusion_Model._match_getConstraint_I(*args): # int32
      return self._getConstraint_I(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_I(*args): # int32
      return self._getConstraint_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraint(string)\n\tmosek.fusion.Model.getConstraint(int32)')
  def setLogHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_LSystem_4StreamWriter_2(*args)
    elif mosek_fusion_Model._match_alt_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_alt_LSystem_4StreamWriter_2(*args)
    else:
      raise ValueError('Invalid argument list setLogHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setLogHandler(System.StreamWriter)')
  def getVariableDuals(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariableDuals_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableDuals_Z_3J_3DI(*args)
    elif mosek_fusion_Model._match_alt_getVariableDuals_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableDuals_alt_Z_3J_3DI(*args)
    else:
      raise ValueError('Invalid argument list getVariableDuals('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariableDuals(bool,array(int64,ndim=1),array(double,ndim=1),int32)')
  def primalObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_primalObjValue_(*args): # 
      return self._primalObjValue_(*args)
    elif mosek_fusion_Model._match_alt_primalObjValue_(*args): # 
      return self._primalObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list primalObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.primalObjValue()')
  def writeTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_writeTask_S(*args): # string
      return self._writeTask_S(*args)
    elif mosek_fusion_Model._match_alt_writeTask_S(*args): # string
      return self._writeTask_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTask(string)')
  def getSolverDoubleInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverDoubleInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverDoubleInfo(string)')
  def flushParameters(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushParameters_(*args): # 
      return self._flushParameters_(*args)
    elif mosek_fusion_Model._match_alt_flushParameters_(*args): # 
      return self._flushParameters_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushParameters('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushParameters()')
  def getAcceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAcceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getAcceptedSolutionStatus()')
  def objective(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_objective_D(*args): # double
      return self._objective_D(*args)
    elif mosek_fusion_Model._match_alt_objective_D(*args): # double
      return self._objective_alt_D(*args)
    elif mosek_fusion_Model._match_objective_SD(*args): # string,double
      return self._objective_SD(*args)
    elif mosek_fusion_Model._match_alt_objective_SD(*args): # string,double
      return self._objective_alt_SD(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list objective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.objective(double)\n\tmosek.fusion.Model.objective(string,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)')
  def flushSolutions(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushSolutions_(*args): # 
      return self._flushSolutions_(*args)
    elif mosek_fusion_Model._match_alt_flushSolutions_(*args): # 
      return self._flushSolutions_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushSolutions('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushSolutions()')
  def getTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getTask_(*args): # 
      return self._getTask_(*args)
    elif mosek_fusion_Model._match_alt_getTask_(*args): # 
      return self._getTask_alt_(*args)
    else:
      raise ValueError('Invalid argument list getTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getTask()')
  def setCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_LSystem_4CallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_alt_LSystem_4CallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setCallbackHandler(System.CallbackHandler)')
  def getConstraintDuals(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraintDuals_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintDuals_Z_3I_3DI(*args)
    elif mosek_fusion_Model._match_alt_getConstraintDuals_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintDuals_alt_Z_3I_3DI(*args)
    else:
      raise ValueError('Invalid argument list getConstraintDuals('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraintDuals(bool,array(int32,ndim=1),array(double,ndim=1),int32)')
  @staticmethod
  def putlicensewait(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_Z(*args)
    elif mosek_fusion_Model._match_alt_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_alt_Z(*args)
    else:
      raise ValueError('Invalid argument list putlicensewait('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensewait(bool)')
  def solve(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_solve_(*args): # 
      return self._solve_(*args)
    elif mosek_fusion_Model._match_alt_solve_(*args): # 
      return self._solve_alt_(*args)
    elif mosek_fusion_Model._match_solve_SS(*args): # string,string
      return self._solve_SS(*args)
    elif mosek_fusion_Model._match_alt_solve_SS(*args): # string,string
      return self._solve_alt_SS(*args)
    else:
      raise ValueError('Invalid argument list solve('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.solve()\n\tmosek.fusion.Model.solve(string,string)')
  @staticmethod
  def getVersion(*args):
    if False: pass
    elif mosek_fusion_Model._match_getVersion_(*args): # 
      return mosek_fusion_Model._getVersion_(*args)
    elif mosek_fusion_Model._match_alt_getVersion_(*args): # 
      return mosek_fusion_Model._getVersion_alt_(*args)
    else:
      raise ValueError('Invalid argument list getVersion('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVersion()')
  def getPrimalSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getPrimalSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getPrimalSolutionStatus()\n\tmosek.fusion.Model.getPrimalSolutionStatus(mosek.fusion.SolutionType)')
  @staticmethod
  def putlicensepath(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_S(*args)
    elif mosek_fusion_Model._match_alt_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_alt_S(*args)
    else:
      raise ValueError('Invalid argument list putlicensepath('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensepath(string)')
  def optserverHost(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_optserverHost_S(*args): # string
      return self._optserverHost_S(*args)
    elif mosek_fusion_Model._match_alt_optserverHost_S(*args): # string
      return self._optserverHost_alt_S(*args)
    else:
      raise ValueError('Invalid argument list optserverHost('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.optserverHost(string)')
  def dualObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dualObjValue_(*args): # 
      return self._dualObjValue_(*args)
    elif mosek_fusion_Model._match_alt_dualObjValue_(*args): # 
      return self._dualObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list dualObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dualObjValue()')
  def getName(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getName_(*args): # 
      return self._getName_(*args)
    elif mosek_fusion_Model._match_alt_getName_(*args): # 
      return self._getName_alt_(*args)
    else:
      raise ValueError('Invalid argument list getName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getName()')
  def getConstraintValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraintValues_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintValues_Z_3I_3DI(*args)
    elif mosek_fusion_Model._match_alt_getConstraintValues_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintValues_alt_Z_3I_3DI(*args)
    else:
      raise ValueError('Invalid argument list getConstraintValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraintValues(bool,array(int32,ndim=1),array(double,ndim=1),int32)')
  def variable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_variable_(*args): # 
      return self._variable_(*args)
    elif mosek_fusion_Model._match_alt_variable_(*args): # 
      return self._variable_alt_(*args)
    elif mosek_fusion_Model._match_variable_S(*args): # string
      return self._variable_S(*args)
    elif mosek_fusion_Model._match_alt_variable_S(*args): # string
      return self._variable_alt_S(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.LinPSDDomain
      return self._variable_Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinPSDDomain_2(*args): # mosek.fusion.LinPSDDomain
      return self._variable_alt_Lmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_I(*args): # int32
      return self._variable_I(*args)
    elif mosek_fusion_Model._match_alt_variable_I(*args): # int32
      return self._variable_alt_I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return self._variable_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return self._variable_alt_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3I(*args): # []int32
      return self._variable__3I(*args)
    elif mosek_fusion_Model._match_alt_variable__3I(*args): # []int32
      return self._variable_alt__3I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_alt_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable_alt__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3I(*args): # string,[]int32
      return self._variable_S_3I(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3I(*args): # string,[]int32
      return self._variable_alt_S_3I(*args)
    elif mosek_fusion_Model._match_variable_SI(*args): # string,int32
      return self._variable_SI(*args)
    elif mosek_fusion_Model._match_alt_variable_SI(*args): # string,int32
      return self._variable_alt_SI(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable_alt__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinPSDDomain_2(*args): # int32,mosek.fusion.LinPSDDomain
      return self._variable_ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinPSDDomain_2(*args): # int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4ConeDomain_2(*args): # []int32,mosek.fusion.ConeDomain
      return self._variable__3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4ConeDomain_2(*args): # []int32,mosek.fusion.ConeDomain
      return self._variable_alt__3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_alt_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_alt_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.LinPSDDomain
      return self._variable_SLmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinPSDDomain_2(*args): # string,mosek.fusion.LinPSDDomain
      return self._variable_alt_SLmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_alt_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.ConeDomain
      return self._variable_SLmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.ConeDomain
      return self._variable_alt_SLmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_alt_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_alt_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4ConeDomain_2(*args): # int32,mosek.fusion.ConeDomain
      return self._variable_ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4ConeDomain_2(*args): # int32,mosek.fusion.ConeDomain
      return self._variable_alt_ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_alt_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args): # string,[]int32,mosek.fusion.ConeDomain
      return self._variable_S_3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args): # string,[]int32,mosek.fusion.ConeDomain
      return self._variable_alt_S_3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_alt_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_alt_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args): # string,[]int32,mosek.fusion.LinPSDDomain
      return self._variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args): # string,[]int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4ConeDomain_2(*args): # string,int32,mosek.fusion.ConeDomain
      return self._variable_SILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4ConeDomain_2(*args): # string,int32,mosek.fusion.ConeDomain
      return self._variable_alt_SILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,mosek.fusion.LinPSDDomain
      return self._variable_SILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_SILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4LinPSDDomain_2(*args): # int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_IILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4LinPSDDomain_2(*args): # int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_IILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_SIILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args): # string,int32,int32,mosek.fusion.LinPSDDomain
      return self._variable_alt_SIILmosek_4fusion_4LinPSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_SIILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SIILmosek_4fusion_4PSDDomain_2(*args)
    else:
      raise ValueError('Invalid argument list variable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.variable()\n\tmosek.fusion.Model.variable(string)\n\tmosek.fusion.Model.variable(mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32)\n\tmosek.fusion.Model.variable(mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1))\n\tmosek.fusion.Model.variable(mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1))\n\tmosek.fusion.Model.variable(string,int32)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.LinPSDDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.PSDDomain)')
  def hasParameter(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasParameter_S(*args): # string
      return self._hasParameter_S(*args)
    elif mosek_fusion_Model._match_alt_hasParameter_S(*args): # string
      return self._hasParameter_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasParameter(string)')
  def hasVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasVariable_S(*args): # string
      return self._hasVariable_S(*args)
    elif mosek_fusion_Model._match_alt_hasVariable_S(*args): # string
      return self._hasVariable_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasVariable(string)')
  def setDataCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setDataCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setDataCallbackHandler(System.DataCallbackHandler)')
  def setVariableValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setVariableValues_Z_3J_3D(*args): # bool,[]int64,[]double
      return self._setVariableValues_Z_3J_3D(*args)
    elif mosek_fusion_Model._match_alt_setVariableValues_Z_3J_3D(*args): # bool,[]int64,[]double
      return self._setVariableValues_alt_Z_3J_3D(*args)
    else:
      raise ValueError('Invalid argument list setVariableValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setVariableValues(bool,array(int64,ndim=1),array(double,ndim=1))')
  def getProblemStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getProblemStatus_(*args): # 
      return self._getProblemStatus_(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_(*args): # 
      return self._getProblemStatus_alt_(*args)
    elif mosek_fusion_Model._match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getProblemStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getProblemStatus()\n\tmosek.fusion.Model.getProblemStatus(mosek.fusion.SolutionType)')
  def getDualSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getDualSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getDualSolutionStatus()\n\tmosek.fusion.Model.getDualSolutionStatus(mosek.fusion.SolutionType)')
  def getVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariable_S(*args): # string
      return self._getVariable_S(*args)
    elif mosek_fusion_Model._match_alt_getVariable_S(*args): # string
      return self._getVariable_alt_S(*args)
    elif mosek_fusion_Model._match_getVariable_I(*args): # int32
      return self._getVariable_I(*args)
    elif mosek_fusion_Model._match_alt_getVariable_I(*args): # int32
      return self._getVariable_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariable(string)\n\tmosek.fusion.Model.getVariable(int32)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_Model._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.clone()')
  def writeTaskNoFlush(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_writeTaskNoFlush_S(*args): # string
      return self._writeTaskNoFlush_S(*args)
    elif mosek_fusion_Model._match_alt_writeTaskNoFlush_S(*args): # string
      return self._writeTaskNoFlush_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTaskNoFlush('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTaskNoFlush(string)')
  def getSolverLIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverLIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverLIntInfo(string)')
  def setSolverParam(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_SS(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_alt_SS(*args)
    elif mosek_fusion_Model._match_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_SI(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_alt_SI(*args)
    elif mosek_fusion_Model._match_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_SD(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_alt_SD(*args)
    else:
      raise ValueError('Invalid argument list setSolverParam('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setSolverParam(string,string)\n\tmosek.fusion.Model.setSolverParam(string,int32)\n\tmosek.fusion.Model.setSolverParam(string,double)')
  def updateObjective(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_alt_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._updateObjective_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list updateObjective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.updateObjective(mosek.fusion.Expression,mosek.fusion.Variable)')
  @staticmethod
  def putlicensecode(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode__3I(*args)
    elif mosek_fusion_Model._match_alt_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list putlicensecode('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensecode(array(int32,ndim=1))')
  def getParameter(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getParameter_S(*args): # string
      return self._getParameter_S(*args)
    elif mosek_fusion_Model._match_alt_getParameter_S(*args): # string
      return self._getParameter_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getParameter(string)')
  def __repr__(self): return 'mosek.fusion.Model'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2(m):
    o = Model.__new__(Model)
    o._ctor_init_Lmosek_4fusion_4Model_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Model_2(m)
  def _ctor_init_Lmosek_4fusion_4Model_2(self,m):
   mosek_fusion_BaseModel._ctor_init_Lmosek_4fusion_4BaseModel_2(self,m)
   _0=self
   self.__model_name = (m.__model_name)
   self.__acceptable_sol = (m.__acceptable_sol)
   self.__solutionptr = (m.__solutionptr)
   self.__natvarmap_blockid = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natvarmap_blockid))
   self.__natvarmap_idx = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natvarmap_idx))
   self.__natvarmap_type = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natvarmap_type))
   self.__natvarmap = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__natvarmap))
   self.__vars = numpy.array([((m.__vars)[_1]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__vars)[_1] is not None) ) else None) for _1 in range(0,int(((m.__vars)).shape[0]))], dtype=numpy.dtype(object))
   self.__natconemap = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__natconemap))
   self.__natconemap_dim = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconemap_dim))
   self.__natbarvar_numbarvarelm = (m.__natbarvar_numbarvarelm)
   self.__natbarvar_ptr = mosek.fusion.Utils.Tools._arraycopy__3J((m.__natbarvar_ptr))
   self.__natbarvar_i = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvar_i))
   self.__natbarvar_j = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvar_j))
   self.__natbarvar_idx = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvar_idx))
   self.__natbarvarmap_nblock = (m.__natbarvarmap_nblock)
   self.__natbarvar_dim = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvar_dim))
   self.__natbarvarmap_num = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvarmap_num))
   self.__natbarvarmap_ptr = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natbarvarmap_ptr))
   self.__barvars = numpy.array([((m.__barvars)[_2]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__barvars)[_2] is not None) ) else None) for _2 in range(0,int(((m.__barvars)).shape[0]))], dtype=numpy.dtype(object))
   self.__var_map = (m.__var_map)._clone_()
   self.__natconmap_blockid = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_blockid))
   self.__natconmap_slackidx = mosek.fusion.Utils.Tools._arraycopy__3J((m.__natconmap_slackidx))
   self.__natconmap_idx = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_idx))
   self.__natconmap_type = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_type))
   self.__natconmap = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__natconmap))
   self.__cons = numpy.array([((m.__cons)[_3]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__cons)[_3] is not None) ) else None) for _3 in range(0,int(((m.__cons)).shape[0]))], dtype=numpy.dtype(object))
   self.__con_map = (m.__con_map)._clone_()
   self.__numparameter = (m.__numparameter)
   self.__parameters = (None if (((m.__parameters) is None) ) else numpy.array([((m.__parameters)[_4]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__parameters)[_4] is not None) ) else None) for _4 in range(0,int(((m.__parameters)).shape[0]))], dtype=numpy.dtype(object)))
   self.__par_map = (m.__par_map)._clone_()
   self.__param_num = (m.__param_num)
   self.__param_value = mosek.fusion.Utils.Tools._arraycopy__3D((m.__param_value))
   self.__natconmap_codenztop = (m.__natconmap_codenztop)
   self.__natconmap_codeatomtop = (m.__natconmap_codeatomtop)
   self.__natconmap_numparameterized = (m.__natconmap_numparameterized)
   self.__natconmap_coderowptrb = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_coderowptrb))
   self.__natconmap_coderowptre = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_coderowptre))
   self.__natconmap_codenidx = mosek.fusion.Utils.Tools._arraycopy__3J((m.__natconmap_codenidx))
   self.__natconmap_codeptr = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_codeptr))
   self.__natconmap_code = mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_code))
   self.__natconmap_cconst = mosek.fusion.Utils.Tools._arraycopy__3D((m.__natconmap_cconst))
   self.__natconmap_objcodenidx = (mosek.fusion.Utils.Tools._arraycopy__3J((m.__natconmap_objcodenidx)) if (((m.__natconmap_objcodenidx) is not None) ) else None)
   self.__natconmap_objcodeptr = (mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_objcodeptr)) if (((m.__natconmap_objcodeptr) is not None) ) else None)
   self.__natconmap_objcode = (mosek.fusion.Utils.Tools._arraycopy__3I((m.__natconmap_objcode)) if (((m.__natconmap_objcode) is not None) ) else None)
   self.__natconmap_objcconst = (mosek.fusion.Utils.Tools._arraycopy__3D((m.__natconmap_objcconst)) if (((m.__natconmap_objcconst) is not None) ) else None)
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self.__bfixidx = (m.__bfixidx)
   self.__rs = mosek_fusion_WorkStack._ctor_()
   self.__ws = mosek_fusion_WorkStack._ctor_()
   self.__xs = mosek_fusion_WorkStack._ctor_()
  @staticmethod
  def _ctor_S(name):
    o = Model.__new__(Model)
    o._ctor_init_S(name)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_match_S__(name))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_alt_match_S__(name))
  def _ctor_alt_init_S(self,name):
    self._ctor_init_S(name)
  def _ctor_init_S(self,name):
   mosek_fusion_BaseModel._ctor_init_SS(self,name,"")
   self.__model_name = name
   self.__acceptable_sol = mosek.fusion.AccSolutionStatus.Optimal
   self.__solutionptr = mosek.fusion.SolutionType.Default
   self.__natvarmap = mosek_fusion_LinkedBlocks._ctor_()
   self.__natvarmap_blockid = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_idx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap_type = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__vars = numpy.array([None for _0 in range(0,1024)], dtype=numpy.dtype(object))
   self.__natconemap = mosek_fusion_LinkedBlocks._ctor_()
   self.__natconemap_dim = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__barvars = numpy.zeros((0,), dtype=numpy.dtype(object))
   self.__natbarvar_ptr = numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   self.__natbarvar_numbarvarelm = 0
   self.__natbarvar_i = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvar_j = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvar_idx = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_nblock = 0
   self.__natbarvar_dim = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_num = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_ptr = numpy.array([0], dtype=numpy.dtype(numpy.int32))
   self.__barvars = numpy.zeros((0,), dtype=numpy.dtype(object))
   self.__var_map = mosek.fusion.Utils.StringIntMap()
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self.__natconmap = mosek_fusion_LinkedBlocks._ctor_()
   self.__natconmap_blockid = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_slackidx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int64))
   self.__natconmap_idx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_type = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_coderowptrb = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_coderowptre = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__cons = numpy.array([None for _1 in range(0,1024)], dtype=numpy.dtype(object))
   self.__con_map = mosek.fusion.Utils.StringIntMap()
   self.__numparameter = 0
   self.__parameters = None
   self.__par_map = mosek.fusion.Utils.StringIntMap()
   self.__param_num = 0
   self.__param_value = None
   self.__natconmap_numparameterized = 0
   self.__natconmap_codeatomtop = 0
   self.__natconmap_codenztop = 0
   self.__natconmap_codenidx = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int64))
   self.__natconmap_codeptr = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_code = numpy.zeros((1024,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap_cconst = numpy.zeros((1024,), dtype=numpy.dtype(numpy.float64))
   self.__natconmap_objcodenidx = None
   self.__natconmap_objcodeptr = None
   self.__natconmap_objcode = None
   self.__natconmap_objcconst = None
   self.__bfixidx = self.__natvarmap_1alloc_I(1)
   self._task_1var_1putboundlist_1fx__3I_3D(numpy.array([self.__bfixidx], dtype=numpy.dtype(numpy.int32)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)))
   self._task_1var_1name_IS(self.__bfixidx,"1.0")
   self.__rs = mosek_fusion_WorkStack._ctor_()
   self.__ws = mosek_fusion_WorkStack._ctor_()
   self.__xs = mosek_fusion_WorkStack._ctor_()
  @staticmethod
  def _ctor_():
    o = Model.__new__(Model)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_Model._ctor_init_S(self,"")
  def _formstConstr_alt_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._formstConstr_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _formstConstr_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (_0)
  def _connames_alt__3IS_3I_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._connames__3IS_3I_3J(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _connames__3IS_3I_3J(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   self._task_1format_1con_1names__3IS_3I_3J(_0,_1,_2,_3)
  def _varnames_alt__3IS_3I_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._varnames__3IS_3I_3J(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _varnames__3IS_3I_3J(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   self._task_1format_1var_1names__3IS_3I_3J(_0,_1,_2,_3)
  def _varname_alt_IS(self,_t__0,_t__1):
    return self._varname_IS(numpy.int32(__0),_1)
  def _varname_IS(self,_0,_1):
   self._task_1var_1name_IS(_0,_1)
  def __natbarvarmap_1get_alt_I_3I(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self.__natbarvarmap_1get_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __natbarvarmap_1get_I_3I(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   fragments._c_closure_0(self.__natbarvarmap_num,self.__natbarvarmap_ptr,_1,_0) # src/fusion/Model.mbi:4378:64-4383:7
  def __natbarvar_1get_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self.__natbarvar_1get_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __natbarvar_1get_I_3J(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   fragments._c_closure_1(self.__natbarvar_dim,self.__natbarvar_ptr,self.__natbarvarmap_num,self.__natbarvarmap_ptr,_1,_0) # src/fusion/Model.mbi:4367:61-4376:7
  def __natbarvarmap_1alloc_alt_II(self,_t__0,_t__1):
    return self.__natbarvarmap_1alloc_II(numpy.int32(__0),numpy.int32(__1))
  def __natbarvarmap_1alloc_II(self,_0,_1):
   _2=int((self.__natbarvar_idx).shape[0])
   _3=self._task_1numbarvar_()
   _4=((_1 * (_1 + 1)) // 2)
   _5=(_0 * _4)
   if ((self.__natbarvar_numbarvarelm + _5) >= _2): # src/fusion/Model.mbi:4311:12-56
    if (_5 < _2): # src/fusion/Model.mbi:4312:14-32
     _5 = _2
    self.__natbarvar_idx = mosek.fusion.CommonTools._resize__3II(self.__natbarvar_idx,(_2 + _5))
    self.__natbarvar_i = mosek.fusion.CommonTools._resize__3II(self.__natbarvar_i,(_2 + _5))
    self.__natbarvar_j = mosek.fusion.CommonTools._resize__3II(self.__natbarvar_j,(_2 + _5))
   if ((self.__natbarvarmap_nblock + 1) >= int((self.__natbarvarmap_num).shape[0])): # src/fusion/Model.mbi:4319:12-60
    _6=((int((self.__natbarvarmap_num).shape[0]) * 2) if ((int((self.__natbarvarmap_num).shape[0]) > 0) ) else 32)
    self.__natbarvarmap_num = mosek.fusion.CommonTools._resize__3II(self.__natbarvarmap_num,_6)
    self.__natbarvarmap_ptr = mosek.fusion.CommonTools._resize__3II(self.__natbarvarmap_ptr,(_6 + 1))
    _7=numpy.ndarray((_6,), dtype=numpy.dtype(object))
    for _8 in range(0,int((self.__barvars).shape[0])):
     _7[_8] = self.__barvars[_8]
    self.__barvars = _7
   if ((_3 + _0) > int((self.__natbarvar_dim).shape[0])): # src/fusion/Model.mbi:4328:12-44
    _9=((int((self.__natbarvar_dim).shape[0]) * 2) if (((_3 + _0) < (int((self.__natbarvar_dim).shape[0]) * 2)) ) else (_3 + _0))
    self.__natbarvar_dim = mosek.fusion.CommonTools._resize__3II(self.__natbarvar_dim,_9)
   if ((_3 + _0) >= int((self.__natbarvar_ptr).shape[0])): # src/fusion/Model.mbi:4332:12-45
    _10=(_0 if ((_0 > int((self.__natbarvar_ptr).shape[0])) ) else int((self.__natbarvar_ptr).shape[0]))
    self.__natbarvar_ptr = mosek.fusion.CommonTools._resize__3JI(self.__natbarvar_ptr,((int((self.__natbarvar_ptr).shape[0]) + _10) + 1))
   fragments._c_closure_2(_1,_0,self.__natbarvar_dim,_3) # src/fusion/Model.mbi:4337:8-60
   self.__natbarvarmap_num[self.__natbarvarmap_nblock] = _0
   self.__natbarvarmap_ptr[(self.__natbarvarmap_nblock + 1)] = (self.__natbarvarmap_ptr[self.__natbarvarmap_nblock] + _0)
   _11=self._task_1append_1barvar_II(_1,_0)
   _12=self.__natbarvarmap_ptr[self.__natbarvarmap_nblock]
   fragments._c_closure_3(_4,_1,_12,_0,self.__natbarvar_i,self.__natbarvar_idx,self.__natbarvar_j,self.__natbarvar_ptr,_3) # src/fusion/Model.mbi:4345:8-4359:9
   self.__natbarvarmap_nblock += 1
   self.__natbarvar_numbarvarelm += (_0 * _4)
   return numpy.int32((self.__natbarvarmap_nblock - 1))
  def __natvarmap_1alloc_alt_I(self,_t__0):
    return self.__natvarmap_1alloc_I(numpy.int32(__0))
  def __natvarmap_1alloc_I(self,_0):
   _1=self.__natvarmap._alloc_I(_0)
   _2=(self.__natvarmap._maxidx_I(_1) + 1)
   _3=self.__natvarmap._capacity_()
   _4=self.__natvarmap._numblocks_()
   if (int((self.__natvarmap_idx).shape[0]) < _3): # src/fusion/Model.mbi:4261:12-39
    _5=int((self.__natvarmap_idx).shape[0])
    self.__natvarmap_idx = mosek.fusion.CommonTools._resize__3II(self.__natvarmap_idx,_3)
    fragments._c_closure_4(self.__natvarmap_idx,_3,_5) # src/fusion/Model.mbi:4263:73-124
    self.__natvarmap_blockid = mosek.fusion.CommonTools._resize__3II(self.__natvarmap_blockid,_3)
   if (int((self.__vars).shape[0]) < _4): # src/fusion/Model.mbi:4266:12-35
    self.__natvarmap_type = mosek.fusion.CommonTools._resize__3II(self.__natvarmap_type,_4)
    _6=numpy.ndarray((_4,), dtype=numpy.dtype(object))
    for _7 in range(0,int((self.__vars).shape[0])):
     _6[_7] = self.__vars[_7]
    for _8 in range(int((self.__vars).shape[0]),int((_6).shape[0])):
     _6[_8] = None
    self.__vars = _6
   if (self._task_1numvar_() < _2): # src/fusion/Model.mbi:4277:12-37
    self._task_1append_1var_I((_2 - self._task_1numvar_()))
   return numpy.int32(_1)
  def __natconmap_1codealloc_alt_II(self,_t__0,_t__1):
    return self.__natconmap_1codealloc_II(numpy.int32(__0),numpy.int32(__1))
  def __natconmap_1codealloc_II(self,_0,_1):
   _2=(_0 + self.__natconmap_codenztop)
   _3=(_1 + self.__natconmap_codeatomtop)
   if (_2 > int((self.__natconmap_codenidx).shape[0])): # src/fusion/Model.mbi:4227:12-44
    if (_2 < (2 * int((self.__natconmap_codenidx).shape[0]))): # src/fusion/Model.mbi:4228:14-48
     _2 = (2 * int((self.__natconmap_codenidx).shape[0]))
    _4=self.__natconmap_codenidx
    _5=self.__natconmap_codeptr
    self.__natconmap_codenidx = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_4,0,self.__natconmap_codenidx,0,int((_4).shape[0]))
    self.__natconmap_codeptr = numpy.zeros(((_2 + 1),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_5,0,self.__natconmap_codeptr,0,int((_5).shape[0]))
   if (_3 > int((self.__natconmap_code).shape[0])): # src/fusion/Model.mbi:4235:12-46
    if (_3 < (2 * int((self.__natconmap_code).shape[0]))): # src/fusion/Model.mbi:4236:14-50
     _3 = (2 * int((self.__natconmap_code).shape[0]))
    _6=self.__natconmap_code
    _7=self.__natconmap_cconst
    self.__natconmap_code = numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_6,0,self.__natconmap_code,0,int((_6).shape[0]))
    self.__natconmap_cconst = numpy.zeros(((_3 + 1),), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_7,0,self.__natconmap_cconst,0,int((_7).shape[0]))
   self.__natconmap_codenztop += _0
   self.__natconmap_codeatomtop += _1
  def __natconmap_1alloc_alt_I(self,_t__0):
    return self.__natconmap_1alloc_I(numpy.int32(__0))
  def __natconmap_1alloc_I(self,_0):
   _1=self.__natconmap._alloc_I(_0)
   _2=(self.__natconmap._maxidx_I(_1) + 1)
   _3=self.__natconmap._capacity_()
   _4=self.__natconmap._numblocks_()
   if (int((self.__natconmap_idx).shape[0]) < _3): # src/fusion/Model.mbi:4200:12-39
    _5=int((self.__natconmap_idx).shape[0])
    self.__natconmap_idx = mosek.fusion.CommonTools._resize__3II(self.__natconmap_idx,_3)
    fragments._c_closure_5(self.__natconmap_idx,_3,_5) # src/fusion/Model.mbi:4202:77-128
    self.__natconmap_blockid = mosek.fusion.CommonTools._resize__3II(self.__natconmap_blockid,_3)
    self.__natconmap_slackidx = mosek.fusion.CommonTools._resize__3JI(self.__natconmap_slackidx,_3)
    self.__natconmap_coderowptrb = mosek.fusion.CommonTools._resize__3II(self.__natconmap_coderowptrb,_3)
    self.__natconmap_coderowptre = mosek.fusion.CommonTools._resize__3II(self.__natconmap_coderowptre,_3)
   if (int((self.__cons).shape[0]) < _4): # src/fusion/Model.mbi:4208:12-35
    self.__natconmap_type = mosek.fusion.CommonTools._resize__3II(self.__natconmap_type,_4)
    _6=numpy.ndarray((_4,), dtype=numpy.dtype(object))
    for _7 in range(0,int((self.__cons).shape[0])):
     _6[_7] = self.__cons[_7]
    for _8 in range(int((self.__cons).shape[0]),_4):
     _6[_8] = None
    self.__cons = _6
   if (_2 > self._task_1numcon_()): # src/fusion/Model.mbi:4217:12-37
    self._task_1append_1con_I((_2 - self._task_1numcon_()))
   return numpy.int32(_1)
  def __natconemap_1alloc_alt_I(self,_t__0):
    return self.__natconemap_1alloc_I(numpy.int32(__0))
  def __natconemap_1alloc_I(self,_0):
   _1=self.__natconemap._alloc_I(_0)
   _2=(self.__natconemap._maxidx_I(_1) + 1)
   if (_2 > self._task_1numcone_()): # src/fusion/Model.mbi:4181:12-39
    self._task_1append_1zerocones_I((_2 - self._task_1numcone_()))
   self.__natconemap_dim = mosek.fusion.CommonTools._resize__3II(self.__natconemap_dim,self.__natconemap._numblocks_())
   return numpy.int32(_1)
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=0
   _1 = fragments._c_closure_6(_1,_0) # src/fusion/Model.mbi:4160:23-75
   _1 = numpy.int32(_1) # postprocess
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _3=0
   _3 = fragments._c_closure_7(_0,_3,_2) # src/fusion/Model.mbi:4164:8-4168:11
   _3 = numpy.int32(_3) # postprocess
   self._task_1var_1putcontlist__3I(_2)
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=0
   _1 = fragments._c_closure_8(_1,_0) # src/fusion/Model.mbi:4148:23-75
   _1 = numpy.int32(_1) # postprocess
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _3=0
   _3 = fragments._c_closure_9(_0,_3,_2) # src/fusion/Model.mbi:4151:8-4155:11
   _3 = numpy.int32(_3) # postprocess
   self._task_1var_1putintlist__3I(_2)
  @staticmethod
  def _match_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Z__(_0))
  @staticmethod
  def _match_alt_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Z__(_0))
  @staticmethod
  def _putlicensewait_alt_Z(_t__0):
    return mosek_fusion_Model._putlicensewait_Z(_0)
  @staticmethod
  def _putlicensewait_Z(_0):
   mosek.fusion.BaseModel._env_1putlicensewait_Z(_0)
  @staticmethod
  def _match_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  @staticmethod
  def _putlicensepath_alt_S(_t__0):
    return mosek_fusion_Model._putlicensepath_S(_0)
  @staticmethod
  def _putlicensepath_S(_0):
   mosek.fusion.BaseModel._env_1putlicensepath_S(_0)
  @staticmethod
  def _match_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _putlicensecode_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model._putlicensecode__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _putlicensecode__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   mosek.fusion.BaseModel._env_1putlicensecode__3I(_0)
  @staticmethod
  def _match_dispose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dispose_(*args):
    if len(args) != 0: return False
    return True
  def _dispose_alt_(self,):
    return self._dispose_()
  def _dispose_(self,):
   for _0 in range(0,int((self.__vars).shape[0])):
    self.__vars[_0] = None
   for _1 in range(0,int((self.__cons).shape[0])):
    self.__cons[_1] = None
   for _2 in range(0,int((self.__barvars).shape[0])):
    self.__barvars[_2] = None
   if (self.__parameters is not None): # src/fusion/Model.mbi:4131:12-30
    for _3 in range(0,int((self.__parameters).shape[0])):
     self.__parameters[_3] = None
   mosek_fusion_BaseModel._dispose_(self)
  def _nativeVarToStr_alt_ILmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2(numpy.int32(__0),_1)
  def _nativeVarToStr_ILmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   if ((_0 < 0) or ((_0 >= int((self.__natvarmap_idx).shape[0])) or (self.__natvarmap_idx[_0] < 0))): # src/fusion/Model.mbi:4112:12-77
    raise mosek_fusion_IndexError._ctor_S("Native variable index is invalid")
   self.__vars[self.__natvarmap_blockid[_0]]._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self.__natvarmap_idx[_0],_1)
  @staticmethod
  def _match_getTask_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getTask_(*args):
    if len(args) != 0: return False
    return True
  def _getTask_alt_(self,):
    return self._getTask_()
  def _getTask_(self,):
   return (self._task_1get_())
  @staticmethod
  def _match_getConstraintDuals_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getConstraintDuals_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getConstraintDuals_alt_Z_3I_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getConstraintDuals_Z_3I_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getConstraintDuals_Z_3I_3DI(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=int((_1).shape[0])
   _5=self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _6=self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _7=self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _8=self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _9=self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   fragments._c_closure_10(_7,_0,_4,self.__natconmap_slackidx,_1,_3,_2,_8,_5,_9,_6) # src/fusion/Model.mbi:4067:8-4086:9
  @staticmethod
  def _match_getConstraintValues_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getConstraintValues_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getConstraintValues_alt_Z_3I_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getConstraintValues_Z_3I_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getConstraintValues_Z_3I_3DI(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=int((_1).shape[0])
   _5=(self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _6=(self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _7=(self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   fragments._c_closure_11(_6,_4,self.__natconmap_slackidx,_1,_3,_2,_7,_5) # src/fusion/Model.mbi:4042:8-4055:9
  @staticmethod
  def _match_getVariableDuals_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getVariableDuals_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getVariableDuals_alt_Z_3J_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getVariableDuals_Z_3J_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getVariableDuals_Z_3J_3DI(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=int((_1).shape[0])
   if _0: # src/fusion/Model.mbi:4003:12-17
    _5=self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_12(_4,_1,_3,_2,_5) # src/fusion/Model.mbi:4006:10-4013:11
   else:
    _6=self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_13(_4,_1,_3,_2,_6) # src/fusion/Model.mbi:4018:10-4025:11
  @staticmethod
  def _match_getVariableValues_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getVariableValues_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getVariableValues_alt_Z_3J_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getVariableValues_Z_3J_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getVariableValues_Z_3J_3DI(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _4=int((_1).shape[0])
   _5=(self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default))
   _6=((self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if (_0 ) else self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)) if ((self.__natbarvar_numbarvarelm > 0) ) else None)
   fragments._c_closure_14(_6,_4,_1,_3,_2,_5) # src/fusion/Model.mbi:3984:8-3995:9
  @staticmethod
  def _match_setVariableValues_Z_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_setVariableValues_Z_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2))
  def _setVariableValues_alt_Z_3J_3D(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._setVariableValues_Z_3J_3D(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setVariableValues_Z_3J_3D(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if _0: # src/fusion/Model.mbi:3953:12-18
    _3=0
    _3 = fragments._c_closure_15(_1,_3) # src/fusion/Model.mbi:3955:10-3956:44
    _3 = numpy.int32(_3) # postprocess
    _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _5=(_2 if ((_3==int((_1).shape[0])) ) else _2)
    _6=0
    _6 = fragments._c_closure_16(_6,_1,_4) # src/fusion/Model.mbi:3961:10-3965:13
    _6 = numpy.int32(_6) # postprocess
    self._setSolution_1xx__3I_3D(_4,_5)
   else:
    pass
  @staticmethod
  def _match_flushNames_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushNames_(*args):
    if len(args) != 0: return False
    return True
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   for _0 in range(0,int((self.__vars).shape[0])):
    if (self.__vars[_0] is not None): # src/fusion/Model.mbi:3936:14-29
     self.__vars[_0]._flushNames_()
   for _1 in range(0,int((self.__barvars).shape[0])):
    if (self.__barvars[_1] is not None): # src/fusion/Model.mbi:3939:14-32
     self.__barvars[_1]._flushNames_()
   for _2 in range(0,int((self.__cons).shape[0])):
    if (self.__cons[_2] is not None): # src/fusion/Model.mbi:3942:14-29
     self.__cons[_2]._flushNames_()
  @staticmethod
  def _match_writeTaskNoFlush_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_writeTaskNoFlush_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _writeTaskNoFlush_alt_S(self,_t__0):
    return self._writeTaskNoFlush_S(_0)
  def _writeTaskNoFlush_S(self,_0):
   self._flushNames_()
   self._task_1write_S(_0)
  @staticmethod
  def _match_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _writeTask_alt_S(self,_t__0):
    return self._writeTask_S(_0)
  def _writeTask_S(self,_0):
   self._flushNames_()
   self.__flush_1parameters_()
   self._task_1write_S(_0)
  @staticmethod
  def _match_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverLIntInfo_alt_S(self,_t__0):
    return self._getSolverLIntInfo_S(_0)
  def _getSolverLIntInfo_S(self,_0):
   return numpy.int64(self._task_1get_1liinf_S(_0))
  @staticmethod
  def _match_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverIntInfo_alt_S(self,_t__0):
    return self._getSolverIntInfo_S(_0)
  def _getSolverIntInfo_S(self,_0):
   return numpy.int32(self._task_1get_1iinf_S(_0))
  @staticmethod
  def _match_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverDoubleInfo_alt_S(self,_t__0):
    return self._getSolverDoubleInfo_S(_0)
  def _getSolverDoubleInfo_S(self,_0):
   return numpy.float64(self._task_1get_1dinf_S(_0))
  @staticmethod
  def _match_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4CallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4CallbackHandler_2__(_0))
  def _setCallbackHandler_alt_LSystem_4CallbackHandler_2(self,_t__0):
    return self._setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  def _setCallbackHandler_LSystem_4CallbackHandler_2(self,_0):
   self._task_1setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  @staticmethod
  def _match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4DataCallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4DataCallbackHandler_2__(_0))
  def _setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(self,_t__0):
    return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  def _setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,_0):
   self._task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  @staticmethod
  def _match_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4StreamWriter_2__(_0))
  @staticmethod
  def _match_alt_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4StreamWriter_2__(_0))
  def _setLogHandler_alt_LSystem_4StreamWriter_2(self,_t__0):
    return self._setLogHandler_LSystem_4StreamWriter_2(_0)
  def _setLogHandler_LSystem_4StreamWriter_2(self,_0):
   self._task_1setLogHandler_LSystem_4StreamWriter_2(_0)
  @staticmethod
  def _match_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _setSolverParam_alt_SD(self,_t__0,_t__1):
    return self._setSolverParam_SD(_0,numpy.float64(__1))
  def _setSolverParam_SD(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SD(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _setSolverParam_alt_SI(self,_t__0,_t__1):
    return self._setSolverParam_SI(_0,numpy.int32(__1))
  def _setSolverParam_SI(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SI(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_S__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_S__(_1))
  def _setSolverParam_alt_SS(self,_t__0,_t__1):
    return self._setSolverParam_SS(_0,_1)
  def _setSolverParam_SS(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SS(self,_0,_1)
  @staticmethod
  def _match_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  def _breakSolver_alt_(self,):
    return self._breakSolver_()
  def _breakSolver_(self,):
   self._task_1break_1solve_()
  @staticmethod
  def _match_optserverHost_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_optserverHost_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _optserverHost_alt_S(self,_t__0):
    return self._optserverHost_S(_0)
  def _optserverHost_S(self,_0):
   self._task_1putoptserver_1host_S(_0)
  @staticmethod
  def _match_solve_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_S__(_1))
  @staticmethod
  def _match_alt_solve_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_S__(_1))
  def _solve_alt_SS(self,_t__0,_t__1):
    return self._solve_SS(_0,_1)
  def _solve_SS(self,_0,_1):
   self._flushSolutions_()
   self.__flush_1parameters_()
   self._task_1solve_ZSS(True,_0,_1)
  @staticmethod
  def _match_solve_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_solve_(*args):
    if len(args) != 0: return False
    return True
  def _solve_alt_(self,):
    return self._solve_()
  def _solve_(self,):
   self._flushSolutions_()
   self.__flush_1parameters_()
   self._task_1solve_ZSS(False,"","")
  def __flush_1parameters_alt_(self,):
    return self.__flush_1parameters_()
  def __flush_1parameters_(self,):
   if (self.__natconmap_numparameterized > 0): # src/fusion/Model.mbi:3640:12-42
    _0=self._task_1numcon_()
    _1=numpy.zeros((self.__natconmap_numparameterized,), dtype=numpy.dtype(numpy.int32))
    _2=numpy.zeros((self.__natconmap_numparameterized,), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((self.__natconmap_numparameterized,), dtype=numpy.dtype(numpy.float64))
    _4=0
    _4 = fragments._c_closure_17(self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_0,_4,_1) # src/fusion/Model.mbi:3647:10-3653:11
    _4 = numpy.int32(_4) # postprocess
    self.__evaluate_1parameterized_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3D_3I_3D(self.__xs,_0,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,self.__natconmap_codenidx,self.__natconmap_codeptr,self.__natconmap_code,self.__natconmap_cconst,_2,_3)
    self._task_1putaijlist__3I_3I_3DJ(_1,_2,_3,self.__natconmap_numparameterized)
   if (self.__natconmap_objcodenidx is not None): # src/fusion/Model.mbi:3675:12-41
    _5=int((self.__natconmap_objcodenidx).shape[0])
    _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
    _7=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    _8=numpy.array([0], dtype=numpy.dtype(numpy.int32))
    _9=numpy.array([int((self.__natconmap_objcodenidx).shape[0])], dtype=numpy.dtype(numpy.int32))
    self.__evaluate_1parameterized_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3D_3I_3D(self.__xs,1,_8,_9,self.__natconmap_objcodenidx,self.__natconmap_objcodeptr,self.__natconmap_objcode,self.__natconmap_objcconst,_6,_7)
    self._task_1putclist__3I_3D(_6,_7)
  @staticmethod
  def _match_flushParameters_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushParameters_(*args):
    if len(args) != 0: return False
    return True
  def _flushParameters_alt_(self,):
    return self._flushParameters_()
  def _flushParameters_(self,):
   self.__flush_1parameters_()
  def __evaluate_1parameterized_alt_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3D_3I_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.float64))
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.int32))
   _9=numpy.array(_t__9,dtype=numpy.dtype(numpy.float64))
   _1 = self.__evaluate_1parameterized_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3D_3I_3D(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__9[:] = _9
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __evaluate_1parameterized_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3D_3I_3D(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   assert _8 is None or isinstance(_8,numpy.ndarray)
   assert _9 is None or isinstance(_9,numpy.ndarray)
   _10=_0._allocf64_I(int((_6).shape[0]))
   _11=0
   _12=(_0.f64)
   _13=0
   _13,_11 = fragments._c_closure_18(_7,_6,_4,_5,_13,_1,self.__param_value,_2,_3,_10,_11,_8,_9,_12) # src/fusion/Model.mbi:3584:8-3626:9
   _13 = numpy.int32(_13) # postprocess
   _11 = numpy.int32(_11) # postprocess
   _0._popf64_I(int((_6).shape[0]))
  @staticmethod
  def _match_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  def _flushSolutions_alt_(self,):
    return self._flushSolutions_()
  def _flushSolutions_(self,):
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
  def __flush_1initsol_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(__0)
  def __flush_1initsol_Emosek_4fusion_4SolutionType_2(self,_0):
   if (self.__initsol_xx is not None): # src/fusion/Model.mbi:3526:12-30
    _1=self._task_1numvar_()
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    try:
     _3=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True)
     if ((_3.xx) is not None): # src/fusion/Model.mbi:3531:16-30
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_3.xx),0,_2,0,(int(((_3.xx)).shape[0]) if ((int(((_3.xx)).shape[0]) <= _1) ) else _1))
    except mosek_fusion_SolutionError as _4:
     pass
    _5=(int((self.__initsol_xx).shape[0]) if ((int((self.__initsol_xx).shape[0]) <= _1) ) else _1)
    for _6 in range(0,_5):
     if self.__initsol_xx_flag[_6]: # src/fusion/Model.mbi:3538:16-34
      _2[_6] = self.__initsol_xx[_6]
    self._task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(_0,0,_1,_2)
  @staticmethod
  def _match_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getDualSolutionStatus_alt_(self,):
    return self._getDualSolutionStatus_()
  def _getDualSolutionStatus_(self,):
   return (self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_getProblemStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getProblemStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getProblemStatus_alt_(self,):
    return self._getProblemStatus_()
  def _getProblemStatus_(self,):
   return (self._getProblemStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getPrimalSolutionStatus_alt_(self,):
    return self._getPrimalSolutionStatus_()
  def _getPrimalSolutionStatus_(self,):
   return (self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _dualObjValue_alt_(self,):
    return self._dualObjValue_()
  def _dualObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,False).dobj))
  @staticmethod
  def _match_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _primalObjValue_alt_(self,):
    return self._primalObjValue_()
  def _primalObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,True).pobj))
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2ZZ(self,_t__0,_t__1,_t__2):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(__0,_1,_2)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(self,_0,_1,_2):
   _3=None
   _4=_0
   if (_4==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:3429:12-41
    _4 = self.__solutionptr
   if (_4==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:3431:12-41
    if (self._sol_itg is not None): # src/fusion/Model.mbi:3433:18-33
     _3 = self._sol_itg
    elif (self._sol_bas is not None): # src/fusion/Model.mbi:3434:18-33
     _3 = self._sol_bas
    else:
     _3 = self._sol_itr
   elif (_4==mosek.fusion.SolutionType.Interior): # src/fusion/Model.mbi:3437:16-46
    _3 = self._sol_itr
   elif (_4==mosek.fusion.SolutionType.Basic): # src/fusion/Model.mbi:3438:16-43
    _3 = self._sol_bas
   elif (_4==mosek.fusion.SolutionType.Integer): # src/fusion/Model.mbi:3439:16-45
    _3 = self._sol_itg
   if (_3 is None): # src/fusion/Model.mbi:3441:12-23
    raise mosek_fusion_SolutionError._ctor_S("Solution not available")
   else:
    if (_2 or ((_1 and _3._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)) or ((not _1) and _3._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)))): # src/fusion/Model.mbi:3447:14-3449:69
     return (_3)
    else:
     _5=mosek.fusion.Utils.StringBuffer()
     _6=(_3.pstatus)
     _7=(_3.probstatus)
     if (not _1): # src/fusion/Model.mbi:3458:16-26
      _6 = (_3.dstatus)
     _5._a_S("Solution status is ")
     if (_6==mosek.fusion.SolutionStatus.Undefined): # src/fusion/Model.mbi:3460:20-54
      _5._a_S("Undefined")
     elif (_6==mosek.fusion.SolutionStatus.Unknown): # src/fusion/Model.mbi:3461:20-52
      _5._a_S("Unknown")
     elif (_6==mosek.fusion.SolutionStatus.Optimal): # src/fusion/Model.mbi:3462:20-52
      _5._a_S("Optimal")
     elif (_6==mosek.fusion.SolutionStatus.Feasible): # src/fusion/Model.mbi:3463:20-53
      _5._a_S("Feasible")
     elif (_6==mosek.fusion.SolutionStatus.Certificate): # src/fusion/Model.mbi:3464:20-56
      _5._a_S("Certificate")
     elif (_6==mosek.fusion.SolutionStatus.IllposedCert): # src/fusion/Model.mbi:3465:20-57
      _5._a_S("IllposedCert")
     _5._a_S(" but ")
     if (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Anything): # src/fusion/Model.mbi:3467:20-64
      _5._a_S("Anything")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Optimal): # src/fusion/Model.mbi:3468:20-63
      _5._a_S("Optimal")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Feasible): # src/fusion/Model.mbi:3469:20-64
      _5._a_S("at least Feasible")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Certificate): # src/fusion/Model.mbi:3470:20-67
      _5._a_S("Certificate")
     _5._a_S(" is expected. Reason: Accessing ")
     if (_3 is self._sol_itr): # src/fusion/Model.mbi:3472:20-34
      _5._a_S("interior-point solution")
     elif (_3 is self._sol_bas): # src/fusion/Model.mbi:3473:20-34
      _5._a_S("basic solution")
     elif (_3 is self._sol_itg): # src/fusion/Model.mbi:3474:20-34
      _5._a_S("integer solution")
     _5._a_S(" whose problem status is ")
     if (_7==mosek.fusion.ProblemStatus.Unknown): # src/fusion/Model.mbi:3476:20-52
      _5._a_S("Unknown")
     elif (_7==mosek.fusion.ProblemStatus.PrimalAndDualFeasible): # src/fusion/Model.mbi:3477:20-66
      _5._a_S("PrimalAndDualFeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalFeasible): # src/fusion/Model.mbi:3478:20-59
      _5._a_S("PrimalFeasible")
     elif (_7==mosek.fusion.ProblemStatus.DualFeasible): # src/fusion/Model.mbi:3479:20-57
      _5._a_S("DualFeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalInfeasible): # src/fusion/Model.mbi:3480:20-61
      _5._a_S("PrimalInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.DualInfeasible): # src/fusion/Model.mbi:3481:20-59
      _5._a_S("DualInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalAndDualInfeasible): # src/fusion/Model.mbi:3482:20-68
      _5._a_S("PrimalAndDualInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.IllPosed): # src/fusion/Model.mbi:3483:20-53
      _5._a_S("IllPosed")
     elif (_7==mosek.fusion.ProblemStatus.PrimalInfeasibleOrUnbounded): # src/fusion/Model.mbi:3484:20-72
      _5._a_S("PrimalInfeasibleOrUnbounded")
     _5._a_S(".")
     raise mosek_fusion_SolutionError._ctor_S(_5._toString_())
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   return (self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,False))
  def _setSolution_1xx_alt__3I_3D(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._setSolution_1xx__3I_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setSolution_1xx__3I_3D(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._ensure_1initsol_1xx_()
   for _2 in range(0,int((_0).shape[0])):
    self.__initsol_xx[_0[_2]] = _1[_2]
    self.__initsol_xx_flag[_0[_2]] = True
  def _ensure_1initsol_1xx_alt_(self,):
    return self._ensure_1initsol_1xx_()
  def _ensure_1initsol_1xx_(self,):
   _0=int((self.__natvarmap_idx).shape[0])
   if (self.__initsol_xx is None): # src/fusion/Model.mbi:3383:12-30
    self.__initsol_xx = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.array([False for _1 in range(0,_0)], dtype=numpy.dtype(numpy.bool))
   elif (int((self.__initsol_xx).shape[0]) < _0): # src/fusion/Model.mbi:3388:16-47
    _2=self.__initsol_xx
    _3=self.__initsol_xx_flag
    self.__initsol_xx = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.zeros((_0,), dtype=numpy.dtype(numpy.bool))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_2,0,self.__initsol_xx,0,_0)
    for _4 in range(0,_0):
     self.__initsol_xx_flag[_4] = _3[_4]
  def _getSolution_1bars_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1bars_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).bars))
  def _getSolution_1barx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1barx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).barx))
  def _getSolution_1y_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1y_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1y_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).y))
  def _getSolution_1xc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xc))
  def _getSolution_1snx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1snx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1snx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).snx))
  def _getSolution_1suc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1suc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).suc))
  def _getSolution_1slc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slc))
  def _getSolution_1sux_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1sux_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).sux))
  def _getSolution_1slx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slx))
  def _getSolution_1yx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1yx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).yx))
  def _getSolution_1xx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xx))
  @staticmethod
  def _match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _selectedSolution_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._selectedSolution_Emosek_4fusion_4SolutionType_2(__0)
  def _selectedSolution_Emosek_4fusion_4SolutionType_2(self,_0):
   self.__solutionptr = _0
  @staticmethod
  def _match_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getAcceptedSolutionStatus_alt_(self,):
    return self._getAcceptedSolutionStatus_()
  def _getAcceptedSolutionStatus_(self,):
   return (self.__acceptable_sol)
  @staticmethod
  def _match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   self.__acceptable_sol = _0
  @staticmethod
  def _match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getProblemStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   _1=None
   if (_0==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:3267:12-41
    if (self._sol_itg is not None): # src/fusion/Model.mbi:3269:18-33
     _1 = self._sol_itg
    elif (self._sol_bas is not None): # src/fusion/Model.mbi:3270:18-33
     _1 = self._sol_bas
    else:
     _1 = self._sol_itr
   elif (_0==mosek.fusion.SolutionType.Interior): # src/fusion/Model.mbi:3273:16-46
    _1 = self._sol_itr
   elif (_0==mosek.fusion.SolutionType.Basic): # src/fusion/Model.mbi:3274:16-43
    _1 = self._sol_bas
   elif (_0==mosek.fusion.SolutionType.Integer): # src/fusion/Model.mbi:3275:16-45
    _1 = self._sol_itg
   if (_1 is None): # src/fusion/Model.mbi:3277:12-23
    return (mosek.fusion.ProblemStatus.Unknown)
   else:
    return ((_1.probstatus))
  @staticmethod
  def _match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,False))
  @staticmethod
  def _match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,True))
  def _getSolutionStatus_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   try:
    _2=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,True)
    if _1: # src/fusion/Model.mbi:3237:14-20
     return ((_2.pstatus))
    else:
     return ((_2.dstatus))
   except mosek_fusion_SolutionError as _3:
    return (mosek.fusion.SolutionStatus.Undefined)
  def _update_alt__3ILmosek_4fusion_4Expression_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._update__3ILmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3ILmosek_4fusion_4Expression_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   _2=(self.__ws.nd)
   _3=(self.__ws.shape_base)
   _4=(self.__ws.nelem)
   _5=(self.__ws.nnz)
   _6=(self.__ws.hassp)
   _7=(self.__ws.ncodeatom)
   _8=(self.__ws.ptr_base)
   _9=(self.__ws.sp_base)
   _10=(self.__ws.nidxs_base)
   _11=(self.__ws.cof_base)
   _12=(self.__ws.code_base)
   _13=(self.__ws.codeptr_base)
   _14=(self.__ws.cconst_base)
   _15=(self.__ws.i32)
   _16=(self.__ws.i64)
   _17=(self.__ws.f64)
   _18=0
   _18 = fragments._c_closure_19(_0,self.__natconmap_slackidx,_4,_18) # src/fusion/Model.mbi:3144:26-100
   _18 = numpy.int32(_18) # postprocess
   _19=_4
   _20=(_5 + _18)
   _21=numpy.zeros(((_4 + 1),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_20(_0,self.__natconmap_slackidx,_4,_10,_8,_21,_15,_16) # src/fusion/Model.mbi:3149:8-3155:9
   fragments._c_closure_21(_4,_21) # src/fusion/Model.mbi:3156:8-54
   _22=_21[_4]
   _23=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   _24=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
   _25=0
   _25 = fragments._c_closure_22(_11,_0,_25,self.__natconmap_slackidx,_4,_10,_8,_24,_23,_17,_15,_16) # src/fusion/Model.mbi:3163:8-3176:9
   _25 = numpy.int32(_25) # postprocess
   self._task_1putarowlist__3I_3J_3I_3D(_0,_21,_23,_24)
   if (_7==0): # src/fusion/Model.mbi:3180:12-26
    self.__natconmap_numparameterized = fragments._c_closure_23(_0,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,self.__natconmap_numparameterized,_4) # src/fusion/Model.mbi:3180:28-3185:9
    self.__natconmap_numparameterized = numpy.int32(self.__natconmap_numparameterized) # postprocess
   else:
    _26=True
    _27=0
    _28=0
    _28,_27 = fragments._c_closure_24(_28,_12,_13,_4,_8,_27,_15) # src/fusion/Model.mbi:3189:10-3196:15
    _28 = numpy.int32(_28) # postprocess
    _27 = numpy.int32(_27) # postprocess
    _29=self.__natconmap_codenztop
    _30=self.__natconmap_codeatomtop
    self.__natconmap_1codealloc_II(_28,_27)
    _31=_30
    _32=_29
    _32,_31,self.__natconmap_numparameterized,_26 = fragments._c_closure_25(_14,_32,_12,_31,_13,_0,self.__natconmap_cconst,self.__natconmap_code,self.__natconmap_codenidx,self.__natconmap_codeptr,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,self.__natconmap_numparameterized,_4,_10,_26,_8,_17,_15,_16) # src/fusion/Model.mbi:3203:10-3224:11
    _32 = numpy.int32(_32) # postprocess
    _31 = numpy.int32(_31) # postprocess
    self.__natconmap_numparameterized = numpy.int32(self.__natconmap_numparameterized) # postprocess
    self.__natconmap_numparameterized += _28
    if (not _26): # src/fusion/Model.mbi:3226:14-20
     raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
  def _update_alt__3ILmosek_4fusion_4Expression_2_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._update__3ILmosek_4fusion_4Expression_2_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3ILmosek_4fusion_4Expression_2_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _3 in range(0,int((_0).shape[0])):
    if (self.__natconmap_coderowptrb[_3] < self.__natconmap_coderowptre[_3]): # src/fusion/Model.mbi:3016:14-65
     raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized constraint")
   _4=(int((_0).shape[0]) * int((_2).shape[0]))
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.array([_0[_7] for _7 in range(0,int((_0).shape[0])) for _8 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _9=numpy.array([_2[_11] for _10 in range(0,int((_0).shape[0])) for _11 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   _12=(self.__ws.nd)
   _13=(self.__ws.nelem)
   _14=(self.__ws.nnz)
   _15=(self.__ws.hassp)
   _16=(self.__ws.ncodeatom)
   _17=(self.__ws.shape_base)
   _18=(self.__ws.ptr_base)
   _19=(self.__ws.sp_base)
   _20=(self.__ws.nidxs_base)
   _21=(self.__ws.cof_base)
   _22=(self.__ws.code_base)
   _23=(self.__ws.codeptr_base)
   _24=(self.__ws.cconst_base)
   _25=(self.__ws.i32)
   _26=(self.__ws.i64)
   _27=(self.__ws.f64)
   _28=0
   _28 = fragments._c_closure_26(_5,_21,_28,_13,_20,_18,_2,_27,_25,_26) # src/fusion/Model.mbi:3046:8-3061:9
   _28 = numpy.int32(_28) # postprocess
   self._task_1putaijlist__3I_3I_3DJ(_6,_9,_5,_4)
   if (_16==0): # src/fusion/Model.mbi:3068:12-26
    self.__natconmap_numparameterized = fragments._c_closure_27(_0,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,self.__natconmap_numparameterized,_13) # src/fusion/Model.mbi:3068:28-3073:9
    self.__natconmap_numparameterized = numpy.int32(self.__natconmap_numparameterized) # postprocess
   else:
    _29=True
    _30=0
    _31=0
    _30,_31 = fragments._c_closure_28(_30,_22,_23,_13,_18,_31,_25) # src/fusion/Model.mbi:3077:10-3084:15
    _30 = numpy.int32(_30) # postprocess
    _31 = numpy.int32(_31) # postprocess
    _32=self.__natconmap_codenztop
    _33=self.__natconmap_codeatomtop
    self.__natconmap_1codealloc_II(_30,_31)
    _34=_33
    _35=_32
    _35,_34,self.__natconmap_numparameterized,_29 = fragments._c_closure_29(_24,_35,_22,_34,_23,_0,self.__natconmap_cconst,self.__natconmap_code,self.__natconmap_codenidx,self.__natconmap_codeptr,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,self.__natconmap_numparameterized,_13,_20,_29,_18,_27,_25,_26) # src/fusion/Model.mbi:3091:10-3112:11
    _35 = numpy.int32(_35) # postprocess
    _34 = numpy.int32(_34) # postprocess
    self.__natconmap_numparameterized = numpy.int32(self.__natconmap_numparameterized) # postprocess
    self.__natconmap_numparameterized += _30
    if (not _29): # src/fusion/Model.mbi:3114:14-20
     raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
  @staticmethod
  def _match_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  def _updateObjective_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1):
    return self._updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  def _updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_0,_1):
   if (_0._getSize_()!=1): # src/fusion/Model.mbi:2931:12-31
    raise mosek_fusion_DimensionError._ctor_S("Invalid expression size for objective")
   if (self.__natconmap_objcodenidx is not None): # src/fusion/Model.mbi:2933:12-41
    raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized objective")
   _2=_1._numInst_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   if (_2 < _1._getSize_()): # src/fusion/Model.mbi:2938:12-28
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _1._inst_I_3JI_3J(0,_4,0,_3)
   else:
    _1._inst_I_3J(0,_3)
   for _5 in range(0,_2):
    if (_3[_5] < 0): # src/fusion/Model.mbi:2946:14-29
     raise mosek_fusion_UpdateError._ctor_S("Updating semidefinite terms is currently not possible")
   _6=True
   _6 = fragments._c_closure_30(_2,_3,_6) # src/fusion/Model.mbi:2950:8-2951:78
   _7=None
   if _6: # src/fusion/Model.mbi:2953:12-28
    _7 = numpy.array([numpy.int32(_3[_8]) for _8 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   else:
    _9=numpy.array([_10 for _10 in range((- 1),_2)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_9,_3,None,0,_2)
    _7 = numpy.array([numpy.int32(_3[_9[_11]]) for _11 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _12=int((_7).shape[0])
   _13=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
   _14=_7
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_0))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   pass
   _15=(self.__ws.nd)
   _16=(self.__ws.nelem)
   _17=(self.__ws.nnz)
   _18=(self.__ws.hassp)
   _19=(self.__ws.ncodeatom)
   _20=(self.__ws.shape_base)
   _21=(self.__ws.ptr_base)
   _22=(self.__ws.sp_base)
   _23=(self.__ws.nidxs_base)
   _24=(self.__ws.cof_base)
   _25=(self.__ws.code_base)
   _26=(self.__ws.codeptr_base)
   _27=(self.__ws.cconst_base)
   pass
   if (_19 > 0): # src/fusion/Model.mbi:2984:12-25
    raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized objective")
   _28=(self.__ws.i32)
   _29=(self.__ws.i64)
   _30=(self.__ws.f64)
   _31=0
   _31 = fragments._c_closure_31(_13,_24,_31,_16,_23,_21,_7,_30,_28,_29) # src/fusion/Model.mbi:2992:8-3007:9
   _31 = numpy.int32(_31) # postprocess
   self._task_1putclist__3I_3D(_14,_13)
  def __parameter_1unchecked_alt_S_3I_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self.__parameter_1unchecked_S_3I_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __parameter_1unchecked_S_3I_3J(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int(len(_0)) > 0) and self.__par_map._hasItem_S(_0)): # src/fusion/Model.mbi:2883:12-51
    raise mosek_fusion_NameError._ctor_S("Duplicate parameter name")
   _3=mosek.fusion.Set._size__3I(_1)
   _4=(int((_2).shape[0]) if ((_2 is not None) ) else numpy.int32(_3))
   if (self.__param_value is None): # src/fusion/Model.mbi:2889:12-31
    self.__param_value = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   else:
    if ((self.__param_num + _4) > int((self.__param_value).shape[0])): # src/fusion/Model.mbi:2892:17-51
     _5=self.__param_value
     _6=((2 * int((_5).shape[0])) if (((2 * int((_5).shape[0])) > (int((_5).shape[0]) + _4)) ) else (int((_5).shape[0]) + _4))
     self.__param_value = numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
     if (self.__param_num > 0): # src/fusion/Model.mbi:2896:14-27
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_5,0,self.__param_value,0,self.__param_num)
   _7=mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self,_1,_2,numpy.array([(self.__param_num + _8) for _8 in range(0,numpy.int32(_4))], dtype=numpy.dtype(numpy.int32)))
   self.__param_num += _4
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2903:12-25
    if ((self.__parameters is None) or (self.__numparameter==int((self.__parameters).shape[0]))): # src/fusion/Model.mbi:2904:14-67
     _9=self.__parameters
     self.__parameters = numpy.array([None for _10 in range(0,((self.__numparameter * 2) + 64))], dtype=numpy.dtype(object))
     for _11 in range(0,self.__numparameter):
      self.__parameters[_11] = _9[_11]
    self.__parameters[self.__numparameter] = _7
    self.__par_map._setItem_SI(_0,self.__numparameter)
    self.__numparameter += 1
   return (_7)
  def __parameter_1_alt_S_3I_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self.__parameter_1_S_3I_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __parameter_1_S_3I_3J(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=True
   _4=int((_1).shape[0])
   if ((_2 is not None) and (int((_2).shape[0]) > 0)): # src/fusion/Model.mbi:2870:12-36
    _5=(_2[(int((_2).shape[0]) - 1)] < mosek.fusion.Set._size__3I(_1))
    _5 = fragments._c_closure_32(_5,_2) # src/fusion/Model.mbi:2872:10-2873:40
    if (not _5): # src/fusion/Model.mbi:2875:14-20
     raise mosek_fusion_IndexError._ctor_S("Unordered sparsity pattern")
   return (self.__parameter_1unchecked_S_3I_3J(_0,_1,_2))
  def __parameter_1_alt_S_3I_3_5I(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,ndmin=_monty.checkShape(_t__2,2),dtype=numpy.dtype(numpy.int32))
   _1 = self.__parameter_1_S_3I_3_5I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __parameter_1_S_3I_3_5I(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=int((_2).shape[0])
   _4=int((_2).shape[1])
   if (int((_1).shape[0])!=_4): # src/fusion/Model.mbi:2847:12-27
    raise mosek_fusion_LengthError._ctor_S("Invalid sparsity")
   if (_2 is None): # src/fusion/Model.mbi:2850:12-28
    return (self.__parameter_1unchecked_S_3I_3J(_0,_1,None))
   else:
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
    _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
    _6[(_4 - 1)] = 1
    fragments._c_closure_33(_4,_1,_6) # src/fusion/Model.mbi:2856:10-72
    fragments._c_closure_34(_4,_3,_5,_2,_6) # src/fusion/Model.mbi:2857:10-2860:11
    return (self.__parameter_1_S_3I_3J(_0,_1,_5))
  @staticmethod
  def _match_parameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_parameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _parameter_alt_S(self,_t__0):
    return self._parameter_S(_0)
  def _parameter_S(self,_0):
   _1=None
   return (self.__parameter_1_S_3I_3J(_0,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_parameter_SIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_parameter_SIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3))
  def _parameter_alt_SIII(self,_t__0,_t__1,_t__2,_t__3):
    return self._parameter_SIII(_0,numpy.int32(__1),numpy.int32(__2),numpy.int32(__3))
  def _parameter_SIII(self,_0,_1,_2,_3):
   _4=None
   return (self.__parameter_1_S_3I_3J(_0,numpy.array([_1,_2,_3], dtype=numpy.dtype(numpy.int32)),_4))
  @staticmethod
  def _match_parameter_SII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_parameter_SII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _parameter_alt_SII(self,_t__0,_t__1,_t__2):
    return self._parameter_SII(_0,numpy.int32(__1),numpy.int32(__2))
  def _parameter_SII(self,_0,_1,_2):
   _3=None
   return (self.__parameter_1_S_3I_3J(_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_parameter_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_parameter_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _parameter_alt_SI(self,_t__0,_t__1):
    return self._parameter_SI(_0,numpy.int32(__1))
  def _parameter_SI(self,_0,_1):
   _2=None
   return (self.__parameter_1_S_3I_3J(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_parameter_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_parameter_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1))
  def _parameter_alt_S_3I(self,_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._parameter_S_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter_S_3I(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=None
   return (self.__parameter_1_S_3I_3J(_0,_1,_2))
  @staticmethod
  def _match_parameter_S_3I_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_parameter_S_3I_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2))
  def _parameter_alt_S_3I_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._parameter_S_3I_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter_S_3I_3J(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (self.__parameter_1_S_3I_3J(_0,_1,_2))
  @staticmethod
  def _match_parameter_S_3I_3_5I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match__3_5I__(_2))
  @staticmethod
  def _match_alt_parameter_S_3I_3_5I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3_5I__(_2))
  def _parameter_alt_S_3I_3_5I(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,ndmin=_monty.checkShape(_t__2,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._parameter_S_3I_3_5I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter_S_3I_3_5I(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (self.__parameter_1_S_3I_3_5I(_0,_1,_2))
  @staticmethod
  def _match_parameter_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_parameter_(*args):
    if len(args) != 0: return False
    return True
  def _parameter_alt_(self,):
    return self._parameter_()
  def _parameter_(self,):
   _0=None
   return (self.__parameter_1_S_3I_3J("",numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),_0))
  @staticmethod
  def _match_parameter_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_parameter_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _parameter_alt_III(self,_t__0,_t__1,_t__2):
    return self._parameter_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _parameter_III(self,_0,_1,_2):
   _3=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_parameter_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_parameter_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _parameter_alt_II(self,_t__0,_t__1):
    return self._parameter_II(numpy.int32(__0),numpy.int32(__1))
  def _parameter_II(self,_0,_1):
   _2=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_parameter_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_parameter_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _parameter_alt_I(self,_t__0):
    return self._parameter_I(numpy.int32(__0))
  def _parameter_I(self,_0):
   _1=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_parameter__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_parameter__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _parameter_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._parameter__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=None
   return (self.__parameter_1_S_3I_3J("",_0,_1))
  @staticmethod
  def _match_parameter__3I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_parameter__3I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3J__(_1))
  def _parameter_alt__3I_3J(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._parameter__3I_3J(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter__3I_3J(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__parameter_1_S_3I_3J("",_0,_1))
  @staticmethod
  def _match_parameter__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_parameter__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1))
  def _parameter_alt__3I_3_5I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._parameter__3I_3_5I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter__3I_3_5I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__parameter_1_S_3I_3_5I("",_0,_1))
  def __objective_1_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def __objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self._task_1putobjectivename_S(_0)
   _3=mosek_fusion_WorkStack._ctor_()
   _4=mosek_fusion_WorkStack._ctor_()
   _5=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_2)))
   _5._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_3,_4,self.__xs)
   _3._pop_1expr_()
   _6=(_3.i32)
   _7=(_3.i64)
   _8=(_3.f64)
   _9=(_3.nd)
   _10=(_3.nelem)
   _11=(_3.nnz)
   _12=(_3.hassp)
   _13=(_3.ncodeatom)
   _14=(_3.ptr_base)
   _15=(_3.shape_base)
   _16=(_3.nidxs_base)
   _17=(_3.cof_base)
   _18=(_3.code_base)
   _19=(_3.codeptr_base)
   _20=(_3.cconst_base)
   _21=1
   _9 = fragments._c_closure_35(_9,_6,_15) # src/fusion/Model.mbi:2708:29-74
   _9 = numpy.int32(_9) # postprocess
   if (_21!=1): # src/fusion/Model.mbi:2710:12-26
    raise mosek_fusion_LengthError._ctor_S("Invalid expression size for objective")
   if (_10!=1): # src/fusion/Model.mbi:2712:12-22
    raise mosek_fusion_LengthError._ctor_S("Invalid expression for objective")
   _22=0
   _23=0
   _22,_23 = fragments._c_closure_36(_22,_16,_11,_23,_7) # src/fusion/Model.mbi:2718:8-2720:51
   _22 = numpy.int32(_22) # postprocess
   _23 = numpy.int32(_23) # postprocess
   _24=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   _25=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_37(_25,_17,_16,_11,_8,_7,_24) # src/fusion/Model.mbi:2725:8-2734:9
   self._task_1putobjective_Z_3I_3DD((_1==mosek.fusion.ObjectiveSense.Maximize),_24,_25,0.0)
   if (_23 > 0): # src/fusion/Model.mbi:2739:12-21
    _26=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
    _27=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
    _28=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
    _29=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_38(_17,self.__natbarvar_i,self.__natbarvar_idx,self.__natbarvar_j,_16,_23,_8,_7,_26,_27,_28,_29) # src/fusion/Model.mbi:2745:10-2751:11
    self._task_1putbarc__3I_3I_3I_3D(_26,_27,_28,_29)
   if (_13==0): # src/fusion/Model.mbi:2758:12-26
    for _30 in range(0,_10):
     self.__natconmap_objcodenidx = None
     self.__natconmap_objcodeptr = None
     self.__natconmap_objcode = None
     self.__natconmap_objcconst = None
   else:
    _31=True
    _32=0
    _33=0
    _33,_32 = fragments._c_closure_39(_33,_18,_19,_14,_6,_32) # src/fusion/Model.mbi:2769:10-2776:11
    _33 = numpy.int32(_33) # postprocess
    _32 = numpy.int32(_32) # postprocess
    if (_33 > 0): # src/fusion/Model.mbi:2778:14-22
     _34=numpy.zeros((_33,), dtype=numpy.dtype(numpy.int64))
     _35=numpy.zeros(((_33 + 1),), dtype=numpy.dtype(numpy.int32))
     _36=numpy.zeros((_32,), dtype=numpy.dtype(numpy.int32))
     _37=numpy.zeros((_32,), dtype=numpy.dtype(numpy.float64))
     _31 = fragments._c_closure_40(_20,_18,_19,_16,_31,_14,_37,_36,_34,_35,_8,_6,_7) # src/fusion/Model.mbi:2784:12-2801:13
     self.__natconmap_objcodenidx = _34
     self.__natconmap_objcodeptr = _35
     self.__natconmap_objcode = _36
     self.__natconmap_objcconst = _37
    else:
     self.__natconmap_objcodenidx = None
     self.__natconmap_objcodeptr = None
     self.__natconmap_objcode = None
     self.__natconmap_objcconst = None
    if (not _31): # src/fusion/Model.mbi:2816:14-20
     raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
  @staticmethod
  def _match_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _objective_alt_D(self,_t__0):
    return self._objective_D(numpy.float64(__0))
  def _objective_D(self,_0):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_0))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2D(__0,numpy.float64(__1))
  def _objective_Emosek_4fusion_4ObjectiveSense_2D(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(__0,_1)
  def _objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,_1)
  @staticmethod
  def _match_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_SD(self,_t__0,_t__1):
    return self._objective_SD(_0,numpy.float64(__1))
  def _objective_SD(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_D__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(_0,__1,numpy.float64(__2))
  def _objective_SEmosek_4fusion_4ObjectiveSense_2D(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,mosek.fusion.Expr._constTerm_D(_2))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def _objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinPSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinPSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinPSDDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2("",(_0._shape),_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4LinPSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2("",numpy.array([_1,((_0 * (_0 + 1)) // 2)], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinPSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2("",numpy.array([((_0 * (_0 + 1)) // 2)], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinPSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinPSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4LinPSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,numpy.array([_2,((_1 * (_1 + 1)) // 2)], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinPSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,numpy.array([((_1 * (_1 + 1)) // 2)], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinPSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4PSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4PSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4PSDDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",(_0._shape),_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",numpy.array([_1,_0,_0], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4PSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,numpy.array([_2,_1,_1], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,numpy.array([_1,_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4ConeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4ConeDomain_2(_0)
  def _variable_Lmosek_4fusion_4ConeDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4RangeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4RangeDomain_2(_0)
  def _variable_Lmosek_4fusion_4RangeDomain_2(self,_0):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinearDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinearDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinearDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",None,_0))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4ConeDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4ConeDomain_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4RangeDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4LinearDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _variable_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",_0,mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4ConeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4RangeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinearDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _variable_alt_I(self,_t__0):
    return self._variable_I(numpy.int32(__0))
  def _variable_I(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_variable_(*args):
    if len(args) != 0: return False
    return True
  def _variable_alt_(self,):
    return self._variable_()
  def _variable_(self,):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4ConeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4RangeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinearDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1))
  def _variable_alt_S_3I(self,_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable_S_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3I(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4ConeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4RangeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinearDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _variable_alt_SI(self,_t__0,_t__1):
    return self._variable_SI(_0,numpy.int32(__1))
  def _variable_SI(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _variable_alt_S(self,_t__0):
    return self._variable_S(_0)
  def _variable_S(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  def _removeConstraintBlock_alt_I(self,_t__0):
    return self._removeConstraintBlock_I(numpy.int32(__0))
  def _removeConstraintBlock_I(self,_0):
   _1=self.__natconmap._blocksize_I(_0)
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   if (self.__natconmap_slackidx[_2[0]]!=0): # src/fusion/Model.mbi:2585:12-45
    _3=self.__natvarmap_idx[self.__natconmap_slackidx[_2[0]]]
    self._removeVariableBlock_J(_3)
   self.__natconmap._get_I_3II(_0,_2,0)
   self.__natconmap._free_I(_0)
   self.__natconmap_numparameterized = fragments._c_closure_41(self.__natconmap_blockid,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,self.__natconmap_idx,self.__natconmap_numparameterized,self.__natconmap_slackidx,_2,_1) # src/fusion/Model.mbi:2593:8-2602:9
   self.__natconmap_numparameterized = numpy.int32(self.__natconmap_numparameterized) # postprocess
   self._task_1con_1putboundlist_1fr__3I(_2)
   self._task_1cleararowlist__3I(_2)
  def _removeVariableBlock_alt_J(self,_t__0):
    return self._removeVariableBlock_J(numpy.int64(__0))
  def _removeVariableBlock_J(self,_0):
   if (self.__natconmap_numparameterized > 0): # src/fusion/Model.mbi:2544:12-42
    raise mosek_fusion_DeletionError._ctor_S("Cannot remove variables in parameterized model")
   if (_0 < 0): # src/fusion/Model.mbi:2547:12-23
    raise mosek_fusion_DeletionError._ctor_S("PSD variables cannot be removed")
   else:
    _1=numpy.int32(_0)
    _2=self.__natvarmap._blocksize_I(_1)
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    self.__natvarmap._get_I_3II(_1,_3,0)
    self.__natvarmap._free_I(_1)
    if (self.__natvarmap_type[_1] > 5): # src/fusion/Model.mbi:2558:14-39
     _4=(self.__natvarmap_type[_1] - 6)
     _5=self.__natconemap._blocksize_I(_4)
     _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
     self.__natconemap._get_I_3II(_4,_6,0)
     self.__natconemap._free_I(_4)
     self.__natconemap_dim[_4] = 0
     self._task_1clear_1cones__3I(_6)
    self.__natvarmap_type[_1] = 0
    fragments._c_closure_42(self.__natvarmap_blockid,self.__natvarmap_idx,_2) # src/fusion/Model.mbi:2570:10-2573:11
    self._task_1var_1putboundlist_1fr__3I(_3)
    self._task_1clearacollist__3I(_3)
  def __ranged_1variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:2406:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=(_1 if ((_1 is not None) ) else (_2._shape))
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I((_2._shape),_3))): # src/fusion/Model.mbi:2411:12-64
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   if (_3 is None): # src/fusion/Model.mbi:2413:12-25
    _3 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   _4=int((_3).shape[0])
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_43(_4,_3,_5) # src/fusion/Model.mbi:2417:36-135
   _6=1
   _6 = fragments._c_closure_44(_6,_3) # src/fusion/Model.mbi:2418:25-73
   _6 = numpy.int32(_6) # postprocess
   _7=None
   if (_7 is not None): # src/fusion/Model.mbi:2421:12-28
    if (int(((_2._sparsity)).shape[1])!=_4): # src/fusion/Model.mbi:2422:14-39
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
    _7 = numpy.zeros((int(((_2._sparsity)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    for _8 in range(0,int(((_2._sparsity)).shape[0])):
     for _9 in range(0,int(((_2._sparsity)).shape[1])):
      if (((_2._sparsity)[_8,_9] < 0) or ((_2._sparsity)[_8,_9] >= _3[_9])): # src/fusion/Model.mbi:2429:18-72
       raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
     _10=0
     for _11 in range(0,int(((_2._sparsity)).shape[1])):
      _10 += (_5[_11] * (_2._sparsity)[_8,_11])
     _7[_8] = _10
   _12=(int((_7).shape[0]) if ((_7 is not None) ) else _6)
   if (_2._scalable): # src/fusion/Model.mbi:2440:12-24
    _13 = numpy.array([(_2._lb)[0] for _15 in range(0,_12)], dtype=numpy.dtype(numpy.float64))
    _14 = numpy.array([(_2._ub)[0] for _16 in range(0,_12)], dtype=numpy.dtype(numpy.float64))
   else:
    _13 = (_2._lb)
    _14 = (_2._ub)
   _17=self.__natvarmap_1alloc_I(_12)
   _18=numpy.zeros((self.__natvarmap._blocksize_I(_17),), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap._get_I_3II(_17,_18,0)
   fragments._c_closure_45(_18,self.__natvarmap_idx,_12,_17) # src/fusion/Model.mbi:2453:8-2454:52
   self._task_1var_1putboundlist_1ra__3I_3D_3D(_18,_13,_14)
   _19=mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,_0,_17,_3,_7,_18)
   if (_2._cardinal_flag): # src/fusion/Model.mbi:2459:12-29
    self._task_1var_1putintlist__3I(_18)
   self.__vars[_17] = _19
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2463:12-25
    self.__var_map._setItem_SI(_0,_17)
   return (_19)
  def __variable_1_alt_S_3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=(_1 if ((_1 is not None) ) else (_2._shape))
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:2315:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   if (_3 is None): # src/fusion/Model.mbi:2318:17-30
    raise mosek_fusion_DimensionError._ctor_S("Missing shape")
   elif (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_3,(_2._shape)))): # src/fusion/Model.mbi:2320:17-69
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   elif (_2._getAxis_() >= int((_3).shape[0])): # src/fusion/Model.mbi:2322:17-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone dimension")
   _4=(_2._getAxis_() if (((_2._shape) is not None) ) else (int((_3).shape[0]) - 1))
   _5=_3[_4]
   _6=int((_3).shape[0])
   _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _7[(_6 - 1)] = 1
   fragments._c_closure_46(_6,_3,_7) # src/fusion/Model.mbi:2329:55-119
   _8=_3[0]
   _8 = fragments._c_closure_47(_8,_3) # src/fusion/Model.mbi:2330:32-80
   _8 = numpy.int32(_8) # postprocess
   _9=1
   _9 = fragments._c_closure_48(_4,_9,_3) # src/fusion/Model.mbi:2332:26-70
   _9 = numpy.int32(_9) # postprocess
   _10=1
   _10 = fragments._c_closure_49(_4,_10,_6,_3) # src/fusion/Model.mbi:2333:26-70
   _10 = numpy.int32(_10) # postprocess
   _11=(_9 * _10)
   if ((((_2._key)==mosek.fusion.QConeKey.InQCone) and (_5 < 2)) or ((((_2._key)==mosek.fusion.QConeKey.InRotatedQCone) and (_5 < 3)) or ((((_2._key)==mosek.fusion.QConeKey.InPExpCone) and (_5!=3)) or ((((_2._key)==mosek.fusion.QConeKey.InPPowCone) and (_5 < 2)) or ((((_2._key)==mosek.fusion.QConeKey.InDExpCone) and (_5!=3)) or (((_2._key)==mosek.fusion.QConeKey.InDPowCone) and (_5 < 2))))))): # src/fusion/Model.mbi:2336:13-2341:66
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for cone")
   _12=self.__natvarmap_1alloc_I(_8)
   _13=self.__natconemap_1alloc_I(_11)
   self.__natvarmap_type[_12] = (_13 + 6)
   _14=numpy.zeros((self.__natvarmap._blocksize_I(_12),), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap._get_I_3II(_12,_14,0)
   fragments._c_closure_50(_8,_14,self.__natvarmap_idx,_12) # src/fusion/Model.mbi:2350:8-2351:52
   self._task_1var_1putboundlist_1fr__3I(_14)
   if (_2._int_flag): # src/fusion/Model.mbi:2354:12-24
    self._task_1var_1putintlist__3I(_14)
   _15=_14
   if (_4 < (int((_3).shape[0]) - 1)): # src/fusion/Model.mbi:2359:12-35
    _15 = numpy.zeros((int((_14).shape[0]),), dtype=numpy.dtype(numpy.int32))
    _16=0
    _16 = fragments._c_closure_51(_5,_9,_10,_14,_16,_15) # src/fusion/Model.mbi:2362:10-2368:13
    _16 = numpy.int32(_16) # postprocess
   _17=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   self.__natconemap._get_I_3II(_13,_17,0)
   self.__natconemap_dim[_13] = _5
   if ((_2._key)==mosek.fusion.QConeKey.InQCone): # src/fusion/Model.mbi:2376:12-39
    self._task_1put_1quadcones__3III_3I(_17,_5,_11,_15)
   else:
    if ((_2._key)==mosek.fusion.QConeKey.InRotatedQCone): # src/fusion/Model.mbi:2377:17-51
     self._task_1put_1rquadcones__3III_3I(_17,_5,_11,_15)
    else:
     if ((_2._key)==mosek.fusion.QConeKey.InPExpCone): # src/fusion/Model.mbi:2378:17-47
      self._task_1put_1pexpcones__3III_3I(_17,_5,_11,_15)
     else:
      if ((_2._key)==mosek.fusion.QConeKey.InPPowCone): # src/fusion/Model.mbi:2379:17-47
       self._task_1put_1ppowcones__3III_3I_3D(_17,_5,_11,_15,numpy.array([(_2._alpha) for _18 in range(0,_11)], dtype=numpy.dtype(numpy.float64)))
      else:
       if ((_2._key)==mosek.fusion.QConeKey.InDExpCone): # src/fusion/Model.mbi:2380:17-47
        self._task_1put_1dexpcones__3III_3I(_17,_5,_11,_15)
       else:
        if ((_2._key)==mosek.fusion.QConeKey.InDPowCone): # src/fusion/Model.mbi:2381:17-47
         self._task_1put_1dpowcones__3III_3I_3D(_17,_5,_11,_15,numpy.array([(_2._alpha) for _19 in range(0,_11)], dtype=numpy.dtype(numpy.float64)))
   for _20 in range(0,int((_17).shape[0])):
    self._task_1cone_1name_IS(_17[_20],mosek.fusion.Utils.StringBuffer()._a_I(_17[_20])._toString_())
   _21=mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4Model_2SI_3I_3I(self,_0,_12,_3,_14)
   self.__vars[_12] = _21
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2391:12-25
    self.__var_map._setItem_SI(_0,_12)
   return (_21)
  def __variable_1_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:2108:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=(_1 if ((_1 is not None) ) else (_2._shape))
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I((_2._shape),_3))): # src/fusion/Model.mbi:2113:12-64
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   if (_3 is None): # src/fusion/Model.mbi:2115:12-25
    _3 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   _4=int((_3).shape[0])
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_52(_4,_3,_5) # src/fusion/Model.mbi:2119:36-135
   _6=1
   _6 = fragments._c_closure_53(_6,_3) # src/fusion/Model.mbi:2120:25-73
   _6 = numpy.int32(_6) # postprocess
   _7=None
   _8=None
   if (_2._empty): # src/fusion/Model.mbi:2124:12-21
    _7 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   elif ((_2._sparsity) is not None): # src/fusion/Model.mbi:2127:16-36
    if (int(((_2._sparsity)).shape[1])!=_4): # src/fusion/Model.mbi:2128:14-39
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
    _9=int(((_2._sparsity)).shape[0])
    _7 = numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _10=False
    _11=(_2._sparsity)
    _10 = fragments._c_closure_54(_10,_9,_3,_11,_7,_5) # src/fusion/Model.mbi:2137:12-2145:13
    if _10: # src/fusion/Model.mbi:2146:16-19
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is out of bounds")
    _12=(_2._sparsity)
    _13=0
    _13 = fragments._c_closure_55(_13,_4,_3) # src/fusion/Model.mbi:2152:26-87
    _13 = numpy.int32(_13) # postprocess
    _14=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_56(_14,_9) # src/fusion/Model.mbi:2153:37-71
    _15=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int32))
    _16=numpy.zeros(((_13 + 1),), dtype=numpy.dtype(numpy.int32))
    for _17 in range(0,_4):
     fragments._c_closure_57(_14,_17,_12,_9,_4,_16,_3,_15) # src/fusion/Model.mbi:2158:12-2168:13
     _18=_14
     _14 = _15
     _15 = _18
    fragments._c_closure_58(_14,_12,_9,_4,_7,_5) # src/fusion/Model.mbi:2172:10-2177:11
   _19=(int((_7).shape[0]) if ((_7 is not None) ) else _6)
   _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.float64))
   if ((_2._bnd) is not None): # src/fusion/Model.mbi:2183:12-27
    if (int(((_2._bnd)).shape[0])==1): # src/fusion/Model.mbi:2184:14-31
     for _21 in range(0,_19):
      _20[_21] = (_2._bnd)[0]
    elif (int(((_2._bnd)).shape[0])==_19): # src/fusion/Model.mbi:2186:18-43
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_2._bnd),0,_20,0,_19)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Invalid right hand side shape in domain")
   _22=self.__natvarmap_1alloc_I(_19)
   _23=numpy.zeros((self.__natvarmap._blocksize_I(_22),), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap._get_I_3II(_22,_23,0)
   fragments._c_closure_59(_23,self.__natvarmap_idx,_19,_22) # src/fusion/Model.mbi:2197:8-2198:52
   if ((_2._key)==mosek.fusion.RelationKey.IsFree): # src/fusion/Model.mbi:2200:17-46
    self._task_1var_1putboundlist_1fr__3I(_23)
    self.__natvarmap_type[_22] = 1
   if ((_2._key)==mosek.fusion.RelationKey.LessThan): # src/fusion/Model.mbi:2204:17-48
    self._task_1var_1putboundlist_1up__3I_3D(_23,_20)
    self.__natvarmap_type[_22] = 3
   elif ((_2._key)==mosek.fusion.RelationKey.GreaterThan): # src/fusion/Model.mbi:2208:17-51
    self._task_1var_1putboundlist_1lo__3I_3D(_23,_20)
    self.__natvarmap_type[_22] = 2
   elif ((_2._key)==mosek.fusion.RelationKey.EqualsTo): # src/fusion/Model.mbi:2212:17-48
    self._task_1var_1putboundlist_1fx__3I_3D(_23,_20)
    self.__natvarmap_type[_22] = 5
   _24=mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,_0,_22,_3,_7,_23)
   if (_2._cardinal_flag): # src/fusion/Model.mbi:2219:12-29
    self._task_1var_1putintlist__3I(_23)
   self.__vars[_22] = _24
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2223:12-25
    self.__var_map._setItem_SI(_0,_22)
   return (_24)
  def __variable_1_alt_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:2049:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=(_1 if ((_1 is not None) ) else (_2._shape))
   if (_3 is None): # src/fusion/Model.mbi:2054:12-25
    raise mosek_fusion_DimensionError._ctor_S("Missing shape for variable")
   elif (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I((_2._shape),_3))): # src/fusion/Model.mbi:2056:17-67
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and domain")
   _4=int((_3).shape[0])
   _5=((_2._conedim) if (((_2._shape) is not None) ) else (_4 - 1))
   if ((_5 < 0) or (_5 >= _4)): # src/fusion/Model.mbi:2062:12-40
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone direction dimension")
   _6=_3[_5]
   _7=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _6))) - 1) / 2))
   if (((_7 * (_7 + 1)) // 2)!=_6): # src/fusion/Model.mbi:2069:12-32
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite variable")
   _8=1
   _9=_3[_5]
   _10=1
   _10 = fragments._c_closure_60(_5,_10,_3) # src/fusion/Model.mbi:2073:8-51
   _10 = numpy.int32(_10) # postprocess
   _8 = fragments._c_closure_61(_5,_8,_4,_3) # src/fusion/Model.mbi:2074:8-51
   _8 = numpy.int32(_8) # postprocess
   _11=(_10 * _8)
   _12=(_11 * _6)
   _13=self.__natbarvarmap_1alloc_II(_11,_7)
   _14=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_1get_I_3I(_13,_14)
   _15=numpy.zeros(((_11 * _9),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_62(_14,_10,_8,self.__natbarvar_ptr,_15,_6) # src/fusion/Model.mbi:2084:8-2092:9
   _16=mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4Model_2SI_3II_3J(self,_0,_13,_3,_5,_15)
   self.__barvars[_13] = _16
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2096:12-25
    self.__var_map._setItem_SI(_0,(- (_13 + 1)))
   return (_16)
  def __variable_1_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:1979:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=_1
   if (_3 is None): # src/fusion/Model.mbi:1983:12-25
    _3 = (_2._shape)
   if (_3 is None): # src/fusion/Model.mbi:1986:12-25
    raise mosek_fusion_DimensionError._ctor_S("Missing shape for variable")
   _4=(_2._conedim1)
   _5=(_2._conedim2)
   _6=int((_3).shape[0])
   _7=_3[_4]
   if (_4 > _5): # src/fusion/Model.mbi:1994:12-31
    _8=_4
    _4 = _5
    _5 = _8
   if ((_4==_5) or ((_4 < 0) or (_5 >= _6))): # src/fusion/Model.mbi:1996:12-66
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone order dimensions for semidefinite variables")
   if (_3[_4]!=_3[_5]): # src/fusion/Model.mbi:1998:12-46
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape in cone order dimensions")
   _9=1
   _9 = fragments._c_closure_63(_4,_9,_3) # src/fusion/Model.mbi:2002:8-63
   _9 = numpy.int32(_9) # postprocess
   _9 = fragments._c_closure_64(_4,_5,_9,_3) # src/fusion/Model.mbi:2003:8-63
   _9 = numpy.int32(_9) # postprocess
   _9 = fragments._c_closure_65(_5,_6,_9,_3) # src/fusion/Model.mbi:2004:8-63
   _9 = numpy.int32(_9) # postprocess
   _10=(((_9 * _7) * (_7 + 1)) // 2)
   _11=self.__natbarvarmap_1alloc_II(_9,_7)
   _12=numpy.zeros((_10,), dtype=numpy.dtype(numpy.int64))
   self.__natbarvar_1get_I_3J(_11,_12)
   _13=mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4Model_2SI_3III_3J(self,_0,_11,_3,(_2._conedim1),(_2._conedim2),_12)
   self.__barvars[_11] = _13
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2038:12-25
    self.__var_map._setItem_SI(_0,(- (_11 + 1)))
   return (_13)
  def __replace_1row_1code_alt_Lmosek_4fusion_4WorkStack_2_3IIIIII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.int32(_t__6)
   _1 = self.__replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self,_0,_1,_2,_3,_4,_5,_6):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _7=int((_1).shape[0])
   _8=(_0.i32)
   _9=(_0.i64)
   _10=(_0.f64)
   _11=True
   _12=0
   _13=0
   _12,_13 = fragments._c_closure_66(_12,_5,_4,_7,_2,_8,_13) # src/fusion/Model.mbi:1923:8-1930:13
   _12 = numpy.int32(_12) # postprocess
   _13 = numpy.int32(_13) # postprocess
   _14=self.__natconmap_codenztop
   _15=self.__natconmap_codeatomtop
   self.__natconmap_1codealloc_II(_12,_13)
   _14,_15,_11 = fragments._c_closure_67(_6,_14,_5,_15,_4,self.__natconmap_cconst,self.__natconmap_code,self.__natconmap_codenidx,self.__natconmap_codeptr,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_1,_7,_3,_11,_2,_10,_8,_9) # src/fusion/Model.mbi:1943:8-1963:9
   _14 = numpy.int32(_14) # postprocess
   _15 = numpy.int32(_15) # postprocess
   self.__natconmap_numparameterized += _12
   if (not _11): # src/fusion/Model.mbi:1965:12-18
    raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:1748:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._cardinal_flag): # src/fusion/Model.mbi:1751:12-29
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))
   _3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.shape_base)
   _9=(self.__rs.nelem)
   _10=(self.__rs.nnz)
   _11=(self.__rs.ncodeatom)
   _12=(self.__rs.hassp)
   _13=(self.__rs.ptr_base)
   _14=(self.__rs.nidxs_base)
   _15=(self.__rs.cof_base)
   _16=(self.__rs.codeptr_base)
   _17=(self.__rs.code_base)
   _18=(self.__rs.cconst_base)
   if ((_2._shape) is not None): # src/fusion/Model.mbi:1782:13-30
    if (int(((_2._shape)).shape[0])!=_7): # src/fusion/Model.mbi:1783:14-34
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
    else:
     for _19 in range(0,_7):
      if ((_2._shape)[_19]!=_4[(_8 + _19)]): # src/fusion/Model.mbi:1787:18-52
       raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _20=1
   _20 = fragments._c_closure_68(_7,_20,_4,_8) # src/fusion/Model.mbi:1790:24-73
   _20 = numpy.int32(_20) # postprocess
   _21=self.__natconmap_1alloc_I(_20)
   _22=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap._get_I_3II(_21,_22,0)
   fragments._c_closure_69(_21,self.__natconmap_idx,self.__natconmap_slackidx,_22,_20) # src/fusion/Model.mbi:1796:8-1799:9
   self.__natconmap_type[_21] = 4
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII_3I(_22,self.__rs,_9,_10,_13,_14,_15,None)
   self.__xs._clear_()
   _23=numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
   _24=numpy.zeros((_20,), dtype=numpy.dtype(numpy.float64))
   _25=(_2._lb)
   _26=(_2._ub)
   _27=(_2._empty)
   _28=(_2._scalable)
   _29=(_2._sparsity)
   fragments._c_closure_70(_23,_24,_27,_25,_28,_29,_26,_7,_20,_4,_8) # src/fusion/Model.mbi:1818:8-1842:9
   self._task_1con_1putboundlist_1ra__3I_3D_3D(_22,_23,_24)
   if (_11==0): # src/fusion/Model.mbi:1846:12-26
    fragments._c_closure_71(self.__natconmap_codeatomtop,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_22,_9) # src/fusion/Model.mbi:1846:28-1851:9
   else:
    _30=True
    _31=0
    _32=0
    _31,_32 = fragments._c_closure_72(_31,_17,_16,_9,_13,_4,_32) # src/fusion/Model.mbi:1856:10-1864:15
    _31 = numpy.int32(_31) # postprocess
    _32 = numpy.int32(_32) # postprocess
    _33=self.__natconmap_codenztop
    _34=self.__natconmap_codeatomtop
    self.__natconmap_1codealloc_II(_31,_32)
    _35=_34
    _36=_33
    _36,_35,self.__natconmap_numparameterized,_30 = fragments._c_closure_73(_18,_31,_36,_17,_35,_16,self.__natconmap_cconst,self.__natconmap_code,self.__natconmap_codenidx,self.__natconmap_codeptr,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,self.__natconmap_numparameterized,_22,_9,_14,_30,_13,_6,_4,_5) # src/fusion/Model.mbi:1871:10-1893:11
    _36 = numpy.int32(_36) # postprocess
    _35 = numpy.int32(_35) # postprocess
    self.__natconmap_numparameterized = numpy.int32(self.__natconmap_numparameterized) # postprocess
    if (not _30): # src/fusion/Model.mbi:1894:14-20
     raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
   _37=mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4Model_2S_3I_3II(self,_0,numpy.array([_4[(_8 + _38)] for _38 in range(0,_7)], dtype=numpy.dtype(numpy.int32)),_22,_21)
   self.__cons[_21] = _37
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1901:12-25
    self.__con_map._setItem_SI(_0,_21)
   return (_37)
  def __putarows_alt__3ILmosek_4fusion_4WorkStack_2IIIII_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.int32(_t__6)
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _1 = self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII_3I(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __putarows__3ILmosek_4fusion_4WorkStack_2IIIII_3I(self,_0,_1,_2,_3,_4,_5,_6,_7):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   _8=(_1.i32)
   _9=(_1.i64)
   _10=(_1.f64)
   _11=0
   _12=0
   _13=0
   _12,_11,_13 = fragments._c_closure_74(_12,_11,self.__natbarvar_idx,_2,_5,_4,_8,_9,_13) # src/fusion/Model.mbi:1492:8-1505:9
   _12 = numpy.int32(_12) # postprocess
   _11 = numpy.int32(_11) # postprocess
   _13 = numpy.int32(_13) # postprocess
   _11 += _2
   if (_7 is not None): # src/fusion/Model.mbi:1507:12-25
    _11 += _2
   _14=int((_0).shape[0])
   _15=numpy.zeros(((_14 + 1),), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _17=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_75(_17,_6,_2,_5,_4,_15,_10,_8,_9,_7,_16) # src/fusion/Model.mbi:1519:8-1554:9
   self._task_1putarowlist__3I_3J_3I_3D(_0,_15,_16,_17)
   if (_12 > 0): # src/fusion/Model.mbi:1569:12-22
    _18=_0
    _19=numpy.zeros(((_14 + 1),), dtype=numpy.dtype(numpy.int64))
    _20=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    _21=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    _22=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _24=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _25=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _26=0
    _27=0
    _27,_26 = fragments._c_closure_76(_27,_26,_20,_6,_25,_21,_22,_23,_24,self.__natbarvar_dim,self.__natbarvar_i,self.__natbarvar_idx,self.__natbarvar_j,_5,_14,_19,_4,_10,_8,_9) # src/fusion/Model.mbi:1584:10-1607:11
    _27 = numpy.int32(_27) # postprocess
    _26 = numpy.int32(_26) # postprocess
    _28=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_21,_22,_23,_24,_25)
    self._task_1putbararowlist__3I_3J_3I_3J(_18,_19,_20,_28)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   _3=_1._getShape_()
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_3,(_2._shape)))): # src/fusion/Model.mbi:1244:13-65
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   if (_2._axisIsSet): # src/fusion/Model.mbi:1249:12-25
    _4 = ((_2._conedim1) < (_2._conedim2))
    _6 = ((_2._conedim1) if (_4 ) else (_2._conedim2))
    _5 = ((_2._conedim2) if (_4 ) else (_2._conedim1))
   else:
    _4 = True
    _6 = (int((_3).shape[0]) - 2)
    _5 = (int((_3).shape[0]) - 1)
   if ((_5 >= int((_3).shape[0])) or (_3[_6]!=_3[_5])): # src/fusion/Model.mbi:1261:13-1262:47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _7=mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprDenseTril._ctor_IILmosek_4fusion_4Expression_2(_6,_5,(mosek_fusion_ExprSymmetrize._ctor_IILmosek_4fusion_4Expression_2(_6,_5,_1) if (((_2._key)==mosek.fusion.PSDKey.IsSymPSD) ) else _1))))
   _7._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   _8=(self.__rs.i32)
   _9=(self.__rs.i64)
   _10=(self.__rs.f64)
   _11=(self.__rs.nd)
   _12=(self.__rs.nelem)
   _13=(self.__rs.nnz)
   _14=(self.__rs.hassp)
   _15=(self.__rs.ncodeatom)
   _16=(self.__rs.shape_base)
   _17=(self.__rs.ptr_base)
   _18=(self.__rs.nidxs_base)
   _19=(self.__rs.sp_base)
   _20=(self.__rs.cof_base)
   _21=(self.__rs.codeptr_base)
   _22=(self.__rs.code_base)
   _23=(self.__rs.cconst_base)
   _24=_3[_5]
   _25=((_24 * (_24 + 1)) // 2)
   _25 = fragments._c_closure_77(_6,_5,_11,_25,_3) # src/fusion/Model.mbi:1301:8-1303:31
   _25 = numpy.int32(_25) # postprocess
   _26=self.__natconmap_1alloc_I(_25)
   _27=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap._get_I_3II(_26,_27,0)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII_3I(_27,self.__rs,_12,_13,_17,_18,_20,None)
   self.__xs._clear_()
   _28=numpy.array([1,1,1,1,1], dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_78(_6,_28,_3) # src/fusion/Model.mbi:1317:8-53
   _28[1] = _3[_6]
   fragments._c_closure_79(_6,_5,_28,_3) # src/fusion/Model.mbi:1319:8-62
   _28[3] = _3[_5]
   fragments._c_closure_80(_5,_28,_11,_3) # src/fusion/Model.mbi:1321:8-56
   _29=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _29[4] = 1
   fragments._c_closure_81(_28,_29) # src/fusion/Model.mbi:1323:49-105
   _30=numpy.zeros((_25,), dtype=numpy.dtype(numpy.float64))
   if (not _14): # src/fusion/Model.mbi:1327:12-21
    raise mosek_fusion_UnexpectedError._ctor_S("Unexpected case!")
   else:
    fragments._c_closure_82(_30,_12) # src/fusion/Model.mbi:1331:10-1332:25
   self._task_1con_1putboundlist_1fx__3I_3D(_27,_30)
   _31=((_28[0] * _28[2]) * _28[4])
   _32=_28[1]
   _33=self.__natbarvarmap_1alloc_II(_31,_32)
   _34=numpy.zeros((_31,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_1get_I_3I(_33,_34)
   _35=numpy.array([_32 for _36 in range(0,((_32 * (_32 + 1)) // 2))], dtype=numpy.dtype(numpy.int32))
   _37=numpy.array([1 for _38 in range(0,((_32 * (_32 + 1)) // 2))], dtype=numpy.dtype(numpy.int64))
   _39=numpy.zeros((((_32 * (_32 + 1)) // 2),), dtype=numpy.dtype(numpy.int32))
   _40=numpy.zeros((((_32 * (_32 + 1)) // 2),), dtype=numpy.dtype(numpy.int32))
   _41=numpy.array([(- 0.5) for _42 in range(0,((_32 * (_32 + 1)) // 2))], dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_83(_32,_41) # src/fusion/Model.mbi:1349:8-1350:39
   fragments._c_closure_84(_32,_39,_40) # src/fusion/Model.mbi:1352:8-1360:9
   _43=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_35,_37,_39,_40,_41)
   _44=_27
   _45=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
   _46=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_85(_28,_43,self.__natbarvar_ptr,self.__natconmap_slackidx,_27,_45,_46,_34,_4) # src/fusion/Model.mbi:1369:8-1395:9
   self._task_1putbaraijlist__3I_3I_3J(_44,_45,_46)
   self.__natconmap_type[_26] = (- (_33 + 1))
   if (_15==0): # src/fusion/Model.mbi:1403:12-26
    fragments._c_closure_86(self.__natconmap_codeatomtop,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_27,_12) # src/fusion/Model.mbi:1403:28-1408:9
   else:
    _47=True
    _48=0
    _49=0
    _48,_49 = fragments._c_closure_87(_48,_22,_21,_12,_17,_8,_49) # src/fusion/Model.mbi:1413:10-1421:15
    _48 = numpy.int32(_48) # postprocess
    _49 = numpy.int32(_49) # postprocess
    _50=self.__natconmap_codenztop
    _51=self.__natconmap_codeatomtop
    self.__natconmap_1codealloc_II(_48,_49)
    _52=_51
    _53=_50
    _53,_52,_47 = fragments._c_closure_88(_23,_53,_22,_52,_21,self.__natconmap_cconst,self.__natconmap_code,self.__natconmap_codenidx,self.__natconmap_codeptr,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_27,_12,_18,_47,_17,_10,_8,_9) # src/fusion/Model.mbi:1428:10-1447:11
    _53 = numpy.int32(_53) # postprocess
    _52 = numpy.int32(_52) # postprocess
    self.__natconmap_numparameterized += _48
    if (not _47): # src/fusion/Model.mbi:1449:14-20
     raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
   _54=mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,_0,_26,_3,_6,_5,numpy.array([self.__natconmap_slackidx[_27[_55]] for _55 in range(0,_25)], dtype=numpy.dtype(numpy.int64)),_27)
   self.__cons[_26] = _54
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1458:12-25
    self.__con_map._setItem_SI(_0,_26)
   return (_54)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinPSDDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:1074:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:1077:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))
   _3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.nelem)
   _9=(self.__rs.nnz)
   _10=(self.__rs.hassp)
   _11=(self.__rs.ncodeatom)
   _12=(self.__rs.shape_base)
   _13=(self.__rs.ptr_base)
   _14=(self.__rs.nidxs_base)
   _15=(self.__rs.cof_base)
   _16=(self.__rs.codeptr_base)
   _17=(self.__rs.code_base)
   _18=(self.__rs.cconst_base)
   _19=numpy.array([_4[(_12 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_19,(_2._shape)))): # src/fusion/Model.mbi:1103:13-65
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _21=1
   _21 = fragments._c_closure_89(_7,_21,_19) # src/fusion/Model.mbi:1106:24-63
   _21 = numpy.int32(_21) # postprocess
   _22=((_2._conedim) if (((_2._shape) is not None) ) else (int((_19).shape[0]) - 1))
   _23=_19[_22]
   _24=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _23))) - 1) / 2))
   if (((_24 * (_24 + 1)) // 2)!=_23): # src/fusion/Model.mbi:1111:12-32
    raise mosek_fusion_DimensionError._ctor_S("Invalid size for semidefinite variable")
   _25=1
   _25 = fragments._c_closure_90(_22,_25,_19) # src/fusion/Model.mbi:1115:8-50
   _25 = numpy.int32(_25) # postprocess
   _26=1
   _26 = fragments._c_closure_91(_22,_26,_7,_19) # src/fusion/Model.mbi:1117:8-53
   _26 = numpy.int32(_26) # postprocess
   _27=(_25 * _26)
   _28=self.__natconmap_1alloc_I(_21)
   _29=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap._get_I_3II(_28,_29,0)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII_3I(_29,self.__rs,_8,_9,_13,_14,_15,None)
   _30=self.__natbarvarmap_1alloc_II(_27,_24)
   _31=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
   self.__natbarvarmap_1get_I_3I(_30,_31)
   self.__barvars[_30] = None
   _32=((_23 * _25) * _26)
   _33=numpy.array([_24 for _34 in range(0,_32)], dtype=numpy.dtype(numpy.int32))
   _35=numpy.array([1 for _36 in range(0,_32)], dtype=numpy.dtype(numpy.int64))
   _37=numpy.zeros((_32,), dtype=numpy.dtype(numpy.float64))
   _38=numpy.zeros((_32,), dtype=numpy.dtype(numpy.int32))
   _39=numpy.zeros((_32,), dtype=numpy.dtype(numpy.int32))
   _40=numpy.zeros((_32,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_92(_40,_28,_24,_25,_26,_37,_38,_39,self.__natbarvar_ptr,self.__natconmap_blockid,self.__natconmap_idx,self.__natconmap_slackidx,self.__natconmap_type,_29,_21,_30,_31) # src/fusion/Model.mbi:1144:8-1167:9
   _41=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_33,_35,_38,_39,_37)
   self._task_1putbaraijlist__3I_3I_3J(_29,_40,_41)
   self._task_1con_1putboundlist_1fx__3I_3D(_29,numpy.zeros((_21,), dtype=numpy.dtype(numpy.float64)))
   if (_11==0): # src/fusion/Model.mbi:1176:12-26
    fragments._c_closure_93(self.__natconmap_codeatomtop,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_29,_8) # src/fusion/Model.mbi:1176:28-1181:9
   else:
    _42=True
    _43=0
    _44=0
    _43,_44 = fragments._c_closure_94(_43,_17,_16,_8,_13,_4,_44) # src/fusion/Model.mbi:1186:10-1194:15
    _43 = numpy.int32(_43) # postprocess
    _44 = numpy.int32(_44) # postprocess
    _45=self.__natconmap_codenztop
    _46=self.__natconmap_codeatomtop
    self.__natconmap_1codealloc_II(_43,_44)
    _47=_46
    _48=_45
    _48,_47,_42 = fragments._c_closure_95(_18,_48,_17,_47,_16,self.__natconmap_cconst,self.__natconmap_code,self.__natconmap_codenidx,self.__natconmap_codeptr,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_29,_8,_14,_42,_13,_6,_4,_5) # src/fusion/Model.mbi:1202:10-1221:11
    _48 = numpy.int32(_48) # postprocess
    _47 = numpy.int32(_47) # postprocess
    self.__natconmap_numparameterized += _43
    if (not _42): # src/fusion/Model.mbi:1223:14-20
     raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
   _49=mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,_0,_28,_19,_22,_29,numpy.array([self.__natconmap_slackidx[_29[_50]] for _50 in range(0,_21)], dtype=numpy.dtype(numpy.int64)))
   self.__cons[_28] = _49
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1231:12-25
    self.__con_map._setItem_SI(_0,_28)
   return (_49)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:882:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:885:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._int_flag): # src/fusion/Model.mbi:888:12-24
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))
   _3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.shape_base)
   _9=(self.__rs.nelem)
   _10=(self.__rs.nnz)
   _11=(self.__rs.ncodeatom)
   _12=(self.__rs.hassp)
   _13=(self.__rs.ptr_base)
   _14=(self.__rs.nidxs_base)
   _15=(self.__rs.cof_base)
   _16=(self.__rs.code_base)
   _17=(self.__rs.codeptr_base)
   _18=(self.__rs.cconst_base)
   _19=numpy.array([_4[(_8 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_19,(_2._shape)))): # src/fusion/Model.mbi:914:13-65
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _21=(_2._getAxis_() if (_2._axisIsSet_() ) else (_7 - 1))
   _22=_19[_21]
   _23=1
   _24=1
   _25=1
   _24,_23,_25 = fragments._c_closure_96(_21,_24,_23,_25,_7,_19) # src/fusion/Model.mbi:925:8-929:9
   _24 = numpy.int32(_24) # postprocess
   _23 = numpy.int32(_23) # postprocess
   _25 = numpy.int32(_25) # postprocess
   _26=(_24 * _23)
   if (((_2._key)==mosek.fusion.QConeKey.InQCone) and (_22 < 2)): # src/fusion/Model.mbi:932:12-63
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_22)._a_S(") for quadratic cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InRotatedQCone) and (_22 < 3)): # src/fusion/Model.mbi:934:16-68
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_22)._a_S(") for rotated quadratic cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InPExpCone) and (_22!=3)): # src/fusion/Model.mbi:936:16-68
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_22)._a_S(") for exponential cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InPPowCone) and (_22 < 2)): # src/fusion/Model.mbi:938:16-68
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_22)._a_S(") for power cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InDExpCone) and (_22!=3)): # src/fusion/Model.mbi:940:16-68
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_22)._a_S(") for dual exponential cone")._toString_())
   elif (((_2._key)==mosek.fusion.QConeKey.InDPowCone) and (_22 < 2)): # src/fusion/Model.mbi:942:16-68
    raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_22)._a_S(") for dual power cone")._toString_())
   _27=self.__natvarmap_1alloc_I(_25)
   _28=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
   self.__natvarmap._get_I_3II(_27,_28,0)
   _29=self.__natconemap_1alloc_I(_26)
   fragments._c_closure_97(_25,self.__natvarmap_idx,_27,_28) # src/fusion/Model.mbi:950:8-951:48
   self._task_1var_1putboundlist_1fr__3I(_28)
   _30=(numpy.zeros((int((_28).shape[0]),), dtype=numpy.dtype(numpy.int32)) if ((_21 < (int((_19).shape[0]) - 1)) ) else _28)
   fragments._c_closure_98(_21,_22,_24,_23,_30,_19,_28) # src/fusion/Model.mbi:956:8-965:9
   _31=numpy.zeros((_26,), dtype=numpy.dtype(numpy.int32))
   self.__natconemap._get_I_3II(_29,_31,0)
   self.__natconemap_dim[_29] = _22
   if ((_2._key)==mosek.fusion.QConeKey.InQCone): # src/fusion/Model.mbi:971:16-43
    self._task_1put_1quadcones__3III_3I(_31,_22,_26,_30)
   elif ((_2._key)==mosek.fusion.QConeKey.InRotatedQCone): # src/fusion/Model.mbi:972:16-50
    self._task_1put_1rquadcones__3III_3I(_31,_22,_26,_30)
   elif ((_2._key)==mosek.fusion.QConeKey.InPExpCone): # src/fusion/Model.mbi:973:16-46
    self._task_1put_1pexpcones__3III_3I(_31,_22,_26,_30)
   elif ((_2._key)==mosek.fusion.QConeKey.InPPowCone): # src/fusion/Model.mbi:974:16-46
    self._task_1put_1ppowcones__3III_3I_3D(_31,_22,_26,_30,numpy.array([(_2._alpha) for _32 in range(0,_26)], dtype=numpy.dtype(numpy.float64)))
   elif ((_2._key)==mosek.fusion.QConeKey.InDExpCone): # src/fusion/Model.mbi:975:16-46
    self._task_1put_1dexpcones__3III_3I(_31,_22,_26,_30)
   elif ((_2._key)==mosek.fusion.QConeKey.InDPowCone): # src/fusion/Model.mbi:976:16-46
    self._task_1put_1dpowcones__3III_3I_3D(_31,_22,_26,_30,numpy.array([(_2._alpha) for _33 in range(0,_26)], dtype=numpy.dtype(numpy.float64)))
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid cone type")
   self.__vars[_27] = None
   _34=self.__natconmap_1alloc_I(_25)
   _35=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap._get_I_3II(_34,_35,0)
   self.__natconmap_type[_34] = (_27 + 6)
   fragments._c_closure_99(_34,_25,self.__natconmap_blockid,self.__natconmap_idx,self.__natconmap_slackidx,_35,_28) # src/fusion/Model.mbi:995:8-999:9
   _36=numpy.zeros((_25,), dtype=numpy.dtype(numpy.float64))
   self._task_1con_1putboundlist_1fx__3I_3D(_35,_36)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII_3I(_35,self.__rs,_9,_10,_13,_14,_15,_28)
   if (_11==0): # src/fusion/Model.mbi:1010:12-26
    fragments._c_closure_100(self.__natconmap_codeatomtop,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_35,_9) # src/fusion/Model.mbi:1010:28-1015:9
   else:
    _37=True
    _38=0
    _39=0
    _38,_39 = fragments._c_closure_101(_38,_16,_17,_9,_13,_4,_39) # src/fusion/Model.mbi:1020:10-1028:15
    _38 = numpy.int32(_38) # postprocess
    _39 = numpy.int32(_39) # postprocess
    _40=self.__natconmap_codenztop
    _41=self.__natconmap_codeatomtop
    self.__natconmap_1codealloc_II(_38,_39)
    _42=_41
    _43=_40
    _43,_42,_37 = fragments._c_closure_102(_18,_43,_16,_42,_17,self.__natconmap_cconst,self.__natconmap_code,self.__natconmap_codenidx,self.__natconmap_codeptr,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_35,_9,_14,_37,_13,_6,_4,_5) # src/fusion/Model.mbi:1036:10-1055:11
    _43 = numpy.int32(_43) # postprocess
    _42 = numpy.int32(_42) # postprocess
    self.__natconmap_numparameterized += _38
    if (not _37): # src/fusion/Model.mbi:1057:14-20
     raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
   _44=mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(self,_0,_2,_19,_34,_35,_28)
   self.__cons[_34] = _44
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1063:12-25
    self.__con_map._setItem_SI(_0,_34)
   return (_44)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:740:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._cardinal_flag): # src/fusion/Model.mbi:743:12-29
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))
   _3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.nelem)
   _9=(self.__rs.nnz)
   _10=(self.__rs.hassp)
   _11=(self.__rs.ncodeatom)
   _12=(self.__rs.shape_base)
   _13=(self.__rs.ptr_base)
   _14=(self.__rs.nidxs_base)
   _15=(self.__rs.cof_base)
   _16=(self.__rs.codeptr_base)
   _17=(self.__rs.code_base)
   _18=(self.__rs.cconst_base)
   _19=numpy.array([_4[(_12 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   _21=1
   _21 = fragments._c_closure_103(_21,_7,_19) # src/fusion/Model.mbi:770:25-65
   _21 = numpy.int32(_21) # postprocess
   if (((_2._shape) is not None) and (not mosek.fusion.Set._match__3I_3I(_19,(_2._shape)))): # src/fusion/Model.mbi:793:13-65
    raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _23=self.__natconmap_1alloc_I(_21)
   _24=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int32))
   self.__natconmap._get_I_3II(_23,_24,0)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII_3I(_24,self.__rs,_8,_9,_13,_14,_15,None)
   _25=(_2._sparsity)
   _26=(_2._empty)
   _27=(_2._bnd)
   _28=(_2._scalable)
   if (_27 is None): # src/fusion/Model.mbi:812:16-30
    _22 = numpy.array([0.0 for _29 in range(0,int((_24).shape[0]))], dtype=numpy.dtype(numpy.float64))
   elif _28: # src/fusion/Model.mbi:814:20-31
    _22 = numpy.array([_27[0] for _30 in range(0,int((_24).shape[0]))], dtype=numpy.dtype(numpy.float64))
   elif (_25 is not None): # src/fusion/Model.mbi:816:20-33
    _31=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
    _31[(_7 - 1)] = 1
    fragments._c_closure_104(_7,_19,_31) # src/fusion/Model.mbi:817:59-121
    _22 = numpy.zeros((int((_24).shape[0]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_105(_22,_27,_25,_7,_31) # src/fusion/Model.mbi:820:14-823:15
   elif _26: # src/fusion/Model.mbi:825:20-28
    _32=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
    _32[(_7 - 1)] = 1
    fragments._c_closure_106(_7,_19,_32) # src/fusion/Model.mbi:826:59-121
    _22 = numpy.zeros((int((_24).shape[0]),), dtype=numpy.dtype(numpy.float64))
   else:
    _22 = numpy.array([_27[_33] for _33 in range(0,int((_24).shape[0]))], dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_107(_23,_21,self.__natconmap_idx,self.__natconmap_slackidx,_24) # src/fusion/Model.mbi:835:8-838:9
   if ((_2._key)==mosek.fusion.RelationKey.IsFree): # src/fusion/Model.mbi:840:17-46
    self.__natconmap_type[_23] = 1
    self._task_1con_1putboundlist_1fr__3I(_24)
   if ((_2._key)==mosek.fusion.RelationKey.LessThan): # src/fusion/Model.mbi:844:17-48
    self.__natconmap_type[_23] = 3
    self._task_1con_1putboundlist_1up__3I_3D(_24,_22)
   elif ((_2._key)==mosek.fusion.RelationKey.GreaterThan): # src/fusion/Model.mbi:848:17-51
    self.__natconmap_type[_23] = 2
    self._task_1con_1putboundlist_1lo__3I_3D(_24,_22)
   elif ((_2._key)==mosek.fusion.RelationKey.EqualsTo): # src/fusion/Model.mbi:852:17-48
    self.__natconmap_type[_23] = 5
    self._task_1con_1putboundlist_1fx__3I_3D(_24,_22)
   if (_11==0): # src/fusion/Model.mbi:859:12-26
    fragments._c_closure_108(self.__natconmap_codeatomtop,self.__natconmap_coderowptrb,self.__natconmap_coderowptre,_24,_8) # src/fusion/Model.mbi:859:28-864:9
   else:
    self.__replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_24,_13,_14,_16,_17,_18)
   _34=mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4Model_2SI_3I_3I(self,_0,_23,_19,_24)
   self.__cons[_23] = _34
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:870:12-25
    self.__con_map._setItem_SI(_0,_23)
   return (_34)
  @staticmethod
  def _match_getVersion_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getVersion_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _getVersion_alt_():
    return mosek_fusion_Model._getVersion_()
  @staticmethod
  def _getVersion_():
   return (mosek.fusion.BaseModel._env_1getversion_())
  @staticmethod
  def _match_hasParameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasParameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasParameter_alt_S(self,_t__0):
    return self._hasParameter_S(_0)
  def _hasParameter_S(self,_0):
   return (self.__par_map._hasItem_S(_0))
  @staticmethod
  def _match_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasConstraint_alt_S(self,_t__0):
    return self._hasConstraint_S(_0)
  def _hasConstraint_S(self,_0):
   return (self.__con_map._hasItem_S(_0))
  @staticmethod
  def _match_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasVariable_alt_S(self,_t__0):
    return self._hasVariable_S(_0)
  def _hasVariable_S(self,_0):
   return (self.__var_map._hasItem_S(_0))
  @staticmethod
  def _match_getParameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getParameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getParameter_alt_S(self,_t__0):
    return self._getParameter_S(_0)
  def _getParameter_S(self,_0):
   return (self.__parameters[self.__par_map._getItem_S(_0)])
  @staticmethod
  def _match_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getConstraint_alt_I(self,_t__0):
    return self._getConstraint_I(numpy.int32(__0))
  def _getConstraint_I(self,_0):
   return (self.__cons[_0])
  @staticmethod
  def _match_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getConstraint_alt_S(self,_t__0):
    return self._getConstraint_S(_0)
  def _getConstraint_S(self,_0):
   return ((self.__cons[self.__con_map._getItem_S(_0)] if (self.__con_map._hasItem_S(_0) ) else None))
  @staticmethod
  def _match_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getVariable_alt_I(self,_t__0):
    return self._getVariable_I(numpy.int32(__0))
  def _getVariable_I(self,_0):
   return (self.__vars[_0])
  @staticmethod
  def _match_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getVariable_alt_S(self,_t__0):
    return self._getVariable_S(_0)
  def _getVariable_S(self,_0):
   if self.__var_map._hasItem_S(_0): # src/fusion/Model.mbi:704:12-33
    _1=self.__var_map._getItem_S(_0)
    if (_1 < 0): # src/fusion/Model.mbi:706:14-23
     return (self.__barvars[(- (_1 + 1))])
    else:
     return (self.__vars[_1])
   else:
    return (None)
  @staticmethod
  def _match_getName_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getName_(*args):
    if len(args) != 0: return False
    return True
  def _getName_alt_(self,):
    return self._getName_()
  def _getName_(self,):
   return (self.__model_name)
  def _getParameterValue_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getParameterValue__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getParameterValue__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_109(_0,self.__param_value,_1) # src/fusion/Model.mbi:695:8-696:40
   return (_1)
  def _setParameterValue_alt__3I_3D(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._setParameterValue__3I_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setParameterValue__3I_3D(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   fragments._c_closure_110(_0,self.__param_value,_1) # src/fusion/Model.mbi:688:70-691:7
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_Model._ctor_Lmosek_4fusion_4Model_2(self))
 return Model
mosek_fusion_Model=__mk_mosek_fusion_Model()
del __mk_mosek_fusion_Model
def __mk_mosek_fusion_Debug():
  class Debug:
    @staticmethod 
    def _o_(): return Debug()
    def p(self,v): 
      sys.stdout.write(str(v))
      return self
    _p_S = p
    _p_I = p
    _p_J = p
    _p_D = p
    _p_Z = p
  
    def p_array (self,v):
      if v is None:
          sys.stdout.write('None')
      else:
          sys.stdout.write('[ %s ]' % ','.join([str(i) for i in v]))
      return self
  
    _p__3I = p_array
    _p__3J = p_array
    _p__3D = p_array
  
    def _lf_(self): 
      sys.stdout.write("\n")
      return self
  
  return Debug
mosek_fusion_Debug=__mk_mosek_fusion_Debug()
#BEFORE CLASS
def __mk_mosek_fusion_Sort():
 class Sort(object):
  @staticmethod
  def getminmax(*args):
    if False: pass
    elif mosek_fusion_Sort._match_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax_alt__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax_alt__3J_3J_3JJJ_3J(*args)
    else:
      raise ValueError('Invalid argument list getminmax('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,array(int32,ndim=1))\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,array(int64,ndim=1))')
  @staticmethod
  def argsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort__3J_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list argsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def argbucketsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort_alt__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort_alt__3J_3JJJJJ(*args)
    else:
      raise ValueError('Invalid argument list argbucketsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,int32,int32)\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,int64,int64)')
  @staticmethod
  def argTransposeSort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(*args)
    elif mosek_fusion_Sort._match_alt_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort_alt__3J_3JIII_3J(*args)
    else:
      raise ValueError('Invalid argument list argTransposeSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argTransposeSort(array(int64,ndim=1),array(int64,ndim=1),int32,int32,int32,array(int64,ndim=1))')
  @staticmethod
  def issorted(*args):
    if False: pass
    elif mosek_fusion_Sort._match_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list issorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  def __repr__(self): return 'mosek.fusion.Sort'
  @staticmethod
  def _match_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _argTransposeSort_alt__3J_3JIII_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   fragments._c_closure_111(_2,_3,_4,_0,_1,_5) # src/fusion/Sort.mbi:250:6-261:7
  @staticmethod
  def _match_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1))
  @staticmethod
  def _argsort_alt__3J_3J(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argsort_alt__3J_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2))
  @staticmethod
  def _argsort_alt__3J_3J_3J(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J_3J(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3J(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _argsort_alt__3J_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3JJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3JJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJ(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3IJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3IJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJ(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((not _4) or ((_3 - _2) < 16)): # src/fusion/Sort.mbi:158:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)): # src/fusion/Sort.mbi:160:16-56
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))): # src/fusion/Sort.mbi:166:14-54
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((not _4) or ((_3 - _2) < 16)): # src/fusion/Sort.mbi:139:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)): # src/fusion/Sort.mbi:141:16-56
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))): # src/fusion/Sort.mbi:147:14-54
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((not _5) or ((_4 - _3) < 16)): # src/fusion/Sort.mbi:118:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)): # src/fusion/Sort.mbi:120:16-62
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))): # src/fusion/Sort.mbi:126:14-127:54
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((not _5) or ((_4 - _3) < 16)): # src/fusion/Sort.mbi:97:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)): # src/fusion/Sort.mbi:99:16-62
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))): # src/fusion/Sort.mbi:105:14-106:54
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_J__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_J__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3JJJJJ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.int64(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3JJJ(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3IJJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3III(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _getminmax_alt__3J_3J_3JJJ_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   fragments._c_closure_112(_3,_0,_4,_5,_1,_2) # src/fusion/Sort.mbi:62:6-80:7
  @staticmethod
  def _match_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5))
  @staticmethod
  def _getminmax_alt__3J_3I_3IJJ_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   fragments._c_closure_113(_3,_0,_4,_5,_1,_2) # src/fusion/Sort.mbi:41:6-59:7
  @staticmethod
  def _match_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3JJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]): # src/fusion/Sort.mbi:35:14-45
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3IJJZ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]): # src/fusion/Sort.mbi:27:14-45
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[(_6 + 1)]]==_1[_0[_6]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))): # src/fusion/Sort.mbi:19:14-119
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[_6]]==_1[_0[(_6 + 1)]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))): # src/fusion/Sort.mbi:11:14-119
     return (False)
   return (True)
 return Sort
mosek_fusion_Sort=__mk_mosek_fusion_Sort()
del __mk_mosek_fusion_Sort
#BEFORE CLASS
def __mk_mosek_fusion_IndexCounter():
 class IndexCounter(object):
  __slots__ = ['_IndexCounter__start','_IndexCounter__dims','_IndexCounter__strides','_IndexCounter__st','_IndexCounter__ii','_IndexCounter__n']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args): # []int32
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):# []int32
      self._ctor_alt_init__3I(*args)
    elif self.__match_ctor_J_3I_3I(*args): # int64,[]int32,[]int32
      self._ctor_init_J_3I_3I(*args)
    elif self.__match_alt_ctor_J_3I_3I(*args):# int64,[]int32,[]int32
      self._ctor_alt_init_J_3I_3I(*args)
    elif self.__match_ctor_J_3I_3J(*args): # int64,[]int32,[]int64
      self._ctor_init_J_3I_3J(*args)
    elif self.__match_alt_ctor_J_3I_3J(*args):# int64,[]int32,[]int64
      self._ctor_alt_init_J_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexCounter.ctor(array(int32,ndim=1))\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int64,ndim=1))')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_getIndex_(*args): # 
      return self._getIndex_(*args)
    elif mosek_fusion_IndexCounter._match_alt_getIndex_(*args): # 
      return self._getIndex_alt_(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.getIndex()')
  def atEnd(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_atEnd_(*args): # 
      return self._atEnd_(*args)
    elif mosek_fusion_IndexCounter._match_alt_atEnd_(*args): # 
      return self._atEnd_alt_(*args)
    else:
      raise ValueError('Invalid argument list atEnd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.atEnd()')
  def next(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_next_(*args): # 
      return self._next_(*args)
    elif mosek_fusion_IndexCounter._match_alt_next_(*args): # 
      return self._next_alt_(*args)
    else:
      raise ValueError('Invalid argument list next('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.next()')
  def inc(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_inc_(*args): # 
      return self._inc_(*args)
    elif mosek_fusion_IndexCounter._match_alt_inc_(*args): # 
      return self._inc_alt_(*args)
    else:
      raise ValueError('Invalid argument list inc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.inc()')
  def reset(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_reset_(*args): # 
      return self._reset_(*args)
    elif mosek_fusion_IndexCounter._match_alt_reset_(*args): # 
      return self._reset_alt_(*args)
    else:
      raise ValueError('Invalid argument list reset('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.reset()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_get_(*args): # 
      return self._get_(*args)
    elif mosek_fusion_IndexCounter._match_alt_get_(*args): # 
      return self._get_alt_(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.get()')
  def __repr__(self): return 'mosek.fusion.IndexCounter'
  @staticmethod
  def _ctor__3I(shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   assert shape is None or isinstance(shape,numpy.ndarray)
   self.__n = int((shape).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   self.__start = 0
   self.__strides = mosek.fusion.Set._strides__3I(shape)
   self.__dims = numpy.array([shape[_0] for _0 in range(0,int((shape).shape[0]))], dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_J_3I_3I(start_,dims_,shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3I(start_,dims_,shape)
    return o
  @staticmethod
  def __match_ctor_J_3I_3I(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor_J_3I_3I(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3I__(shape))
  def _ctor_alt_init_J_3I_3I(self,start_,dims_,shape):
    self._ctor_init_J_3I_3I(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_J_3I_3I(self,start_,dims_,shape):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert shape is None or isinstance(shape,numpy.ndarray)
   _0=int((shape).shape[0])
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_114(self.__n,self.__st,start_) # src/fusion/CommonUtil.mbi:481:21-56
   self.__strides = mosek.fusion.Set._strides__3I(shape)
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _ctor_J_3I_3J(start_,dims_,strides_):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3J(start_,dims_,strides_)
    return o
  @staticmethod
  def __match_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3J__(strides_))
  @staticmethod
  def __match_alt_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(strides_))
  def _ctor_alt_init_J_3I_3J(self,start_,dims_,strides_):
    self._ctor_init_J_3I_3J(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_J_3I_3J(self,start_,dims_,strides_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert strides_ is None or isinstance(strides_,numpy.ndarray)
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_115(self.__n,self.__st,start_) # src/fusion/CommonUtil.mbi:466:21-56
   self.__strides = strides_
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _match_atEnd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_atEnd_(*args):
    if len(args) != 0: return False
    return True
  def _atEnd_alt_(self,):
    return self._atEnd_()
  def _atEnd_(self,):
   return ((self.__ii[(self.__n - 1)] >= self.__dims[(self.__n - 1)]))
  @staticmethod
  def _match_getIndex_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getIndex_(*args):
    if len(args) != 0: return False
    return True
  def _getIndex_alt_(self,):
    return self._getIndex_()
  def _getIndex_(self,):
   return (self.__ii)
  @staticmethod
  def _match_next_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_next_(*args):
    if len(args) != 0: return False
    return True
  def _next_alt_(self,):
    return self._next_()
  def _next_(self,):
   _0=self._get_()
   self._inc_()
   return numpy.int64(_0)
  @staticmethod
  def _match_get_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_(*args):
    if len(args) != 0: return False
    return True
  def _get_alt_(self,):
    return self._get_()
  def _get_(self,):
   return numpy.int64(self.__st[0])
  @staticmethod
  def _match_inc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inc_(*args):
    if len(args) != 0: return False
    return True
  def _inc_alt_(self,):
    return self._inc_()
  def _inc_(self,):
   fragments._c_closure_116(self.__dims,self.__ii,self.__n,self.__st,self.__strides) # src/fusion/CommonUtil.mbi:506:6-517:7
  @staticmethod
  def _match_reset_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_reset_(*args):
    if len(args) != 0: return False
    return True
  def _reset_alt_(self,):
    return self._reset_()
  def _reset_(self,):
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_117(self.__n,self.__st,self.__start) # src/fusion/CommonUtil.mbi:502:21-55
 return IndexCounter
mosek_fusion_IndexCounter=__mk_mosek_fusion_IndexCounter()
del __mk_mosek_fusion_IndexCounter
#BEFORE CLASS
def __mk_mosek_fusion_CommonTools():
 class CommonTools(object):
  @staticmethod
  def ndIncr(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr__3I_3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list ndIncr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.ndIncr(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def resize(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_resize__3DI(*args): # []double,int32
      return mosek_fusion_CommonTools._resize__3DI(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3DI(*args): # []double,int32
      return mosek_fusion_CommonTools._resize_alt__3DI(*args)
    elif mosek_fusion_CommonTools._match_resize__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._resize__3II(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._resize_alt__3II(*args)
    elif mosek_fusion_CommonTools._match_resize__3JI(*args): # []int64,int32
      return mosek_fusion_CommonTools._resize__3JI(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3JI(*args): # []int64,int32
      return mosek_fusion_CommonTools._resize_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.resize(array(double,ndim=1),int32)\n\tmosek.fusion.CommonTools.resize(array(int32,ndim=1),int32)\n\tmosek.fusion.CommonTools.resize(array(int64,ndim=1),int32)')
  @staticmethod
  def binarySearch(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearch__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearch__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearch__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearch_alt__3JJ(*args)
    elif mosek_fusion_CommonTools._match_binarySearch__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._binarySearch__3II(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearch__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._binarySearch_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list binarySearch('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearch(array(int64,ndim=1),int64)\n\tmosek.fusion.CommonTools.binarySearch(array(int32,ndim=1),int32)')
  @staticmethod
  def tripletSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list tripletSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.tripletSort(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def binarySearchR(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearchR__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchR__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearchR__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchR_alt__3JJ(*args)
    else:
      raise ValueError('Invalid argument list binarySearchR('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearchR(array(int64,ndim=1),int64)')
  @staticmethod
  def argMSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort__3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list argMSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argMSort(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def binarySearchL(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearchL__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchL__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearchL__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchL_alt__3JJ(*args)
    else:
      raise ValueError('Invalid argument list binarySearchL('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearchL(array(int64,ndim=1),int64)')
  @staticmethod
  def transposeTriplets(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list transposeTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int64,ndim=1),ndim=1),array(array(int64,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def argQsort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3J_3JJJ(*args)
    else:
      raise ValueError('Invalid argument list argQsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)')
  def __repr__(self): return 'mosek.fusion.CommonTools'
  @staticmethod
  def _match_resize__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3JI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3JI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3JI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:434:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:438:14-35
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_resize__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:422:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:426:14-35
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_resize__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3DI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:410:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:414:14-35
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_binarySearch__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_binarySearch__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _binarySearch_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearch__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearch__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=0
   _3=int((_0).shape[0])
   if (_0[_2]==_1): # src/fusion/CommonUtil.mbi:395:12-32
    return numpy.int32(_2)
   elif (_0[(_3 - 1)]==_1): # src/fusion/CommonUtil.mbi:396:16-38
    return numpy.int32((_3 - 1))
   while (_2 < (_3 - 1)):
    _4=((_3 - _2) // 2)
    if (_1 < _0[_4]): # src/fusion/CommonUtil.mbi:399:14-32
     _2 = (_4 + 1)
    elif (_1 > _0[_4]): # src/fusion/CommonUtil.mbi:401:18-36
     _3 = _4
    else:
     return numpy.int32(_4)
   return numpy.int32((- 1))
  @staticmethod
  def _match_binarySearch__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearch__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearch_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearch__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearch__3JJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=mosek.fusion.CommonTools._binarySearchL__3JJ(_0,_1)
   if ((_2 < int((_0).shape[0])) and (_0[_2]==_1)): # src/fusion/CommonUtil.mbi:385:12-51
    return numpy.int32(_2)
   else:
    return numpy.int32((- 1))
  @staticmethod
  def _match_binarySearchR__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearchR__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearchR_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearchR__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearchR__3JJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=0
   _3=int((_0).shape[0])
   if (_0[_2] > _1): # src/fusion/CommonUtil.mbi:371:12-31
    return numpy.int32(_2)
   _2,_3 = fragments._c_closure_118(_2,_3,_1,_0) # src/fusion/CommonUtil.mbi:373:8-379:9
   _2 = numpy.int32(_2) # postprocess
   _3 = numpy.int32(_3) # postprocess
   return numpy.int32(_3)
  @staticmethod
  def _match_binarySearchL__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearchL__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearchL_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearchL__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearchL__3JJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=0
   _3=int((_0).shape[0])
   if (_1 <= _0[_2]): # src/fusion/CommonUtil.mbi:354:12-32
    return numpy.int32(_2)
   _2,_3 = fragments._c_closure_119(_2,_3,_1,_0) # src/fusion/CommonUtil.mbi:356:8-362:9
   _2 = numpy.int32(_2) # postprocess
   _3 = numpy.int32(_3) # postprocess
   return numpy.int32(_3)
  @staticmethod
  def _match_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _ndIncr_alt__3I_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._ndIncr__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ndIncr__3I_3I_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   fragments._c_closure_120(_1,_2,_0) # src/fusion/CommonUtil.mbi:338:6-346:7
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3J__(_3) and __arg_match__3_3J__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3J__(_3) and __arg_alt_match__3_3J__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int64))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int64))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_121(_10,_6,_9,_0,_1) # src/fusion/CommonUtil.mbi:305:8-309:9
   fragments._c_closure_122(_7,_9) # src/fusion/CommonUtil.mbi:311:8-78
   fragments._c_closure_123(_10,_8) # src/fusion/CommonUtil.mbi:312:8-78
   _11=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _13=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_124(_10,_7,_9,_1,_11,_12,_13,_2) # src/fusion/CommonUtil.mbi:318:8-330:9
   _3[0] = _12
   _4[0] = _11
   _5[0] = _13
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_125(_10,_6,_9,_0,_1) # src/fusion/CommonUtil.mbi:257:8-261:9
   fragments._c_closure_126(_7,_9) # src/fusion/CommonUtil.mbi:263:8-78
   fragments._c_closure_127(_10,_8) # src/fusion/CommonUtil.mbi:264:8-78
   _11=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_128(_10,_7,_9,_1,_11,_12,_13,_2) # src/fusion/CommonUtil.mbi:270:8-282:9
   _3[0] = _12
   _4[0] = _11
   _5[0] = _13
  @staticmethod
  def _match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_129(_10,_6,_1) # src/fusion/CommonUtil.mbi:132:8-75
   fragments._c_closure_130(_10,_8) # src/fusion/CommonUtil.mbi:133:8-69
   fragments._c_closure_131(_9,_10,_6,_1) # src/fusion/CommonUtil.mbi:134:8-139:9
   _11=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_132(_6,_11,_0) # src/fusion/CommonUtil.mbi:145:8-82
   fragments._c_closure_133(_7,_11) # src/fusion/CommonUtil.mbi:146:8-78
   fragments._c_closure_134(_9,_10,_8,_12,_11,_0) # src/fusion/CommonUtil.mbi:147:8-155:9
   _13=1
   _13 = fragments._c_closure_135(_6,_13,_12,_0,_1) # src/fusion/CommonUtil.mbi:161:8-177:9
   _13 = numpy.int32(_13) # postprocess
   _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
   _17=_12[0]
   _14[0] = _0[_17]
   _15[0] = _1[_17]
   _16[0] = _2[_17]
   _18=1
   _18 = fragments._c_closure_136(_18,_6,_12,_0,_1,_14,_15,_16,_2) # src/fusion/CommonUtil.mbi:192:8-209:9
   _18 = numpy.int32(_18) # postprocess
   _3[0] = _14
   _4[0] = _15
   _5[0] = _16
  @staticmethod
  def _match_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argMSort_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._argMSort__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argMSort__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _3=False
   _4=1
   while (_4 < int((_0).shape[0])):
    _3 = (not _3)
    for _5 in range(0,int((_0).shape[0]),(_4 * 2)):
     if _3: # src/fusion/CommonUtil.mbi:79:16-19
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_0,_2,_1,_5,(_5 + _4),(_5 + (2 * _4)))
     else:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_2,_0,_1,_5,(_5 + _4),(_5 + (2 * _4)))
    _4 *= 2
   if _3: # src/fusion/CommonUtil.mbi:85:12-15
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_2,0,_0,0,int((_0).shape[0]))
  @staticmethod
  def __mergeInto_alt__3I_3I_3IIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_CommonTools.__mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _6=(int((_0).shape[0]) if ((_5 > int((_0).shape[0])) ) else _5)
   _7=(_6 if ((_4 > _6) ) else _4)
   if (_7==_6): # src/fusion/CommonUtil.mbi:39:12-22
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,_3,_1,_3,(_7 - _3))
   else:
    fragments._c_closure_137(_3,_7,_6,_0,_1,_2) # src/fusion/CommonUtil.mbi:42:8-53:9
  @staticmethod
  def _match_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_2 is None): # src/fusion/CommonUtil.mbi:18:12-25
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_2 is None): # src/fusion/CommonUtil.mbi:10:12-25
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
 return CommonTools
mosek_fusion_CommonTools=__mk_mosek_fusion_CommonTools()
del __mk_mosek_fusion_CommonTools
#BEFORE CLASS
def __mk_mosek_fusion_SolutionStruct():
 class SolutionStruct(object):
  __slots__ = ['yx','snx','sux','slx','bars','barx','y','suc','slc','xx','xc','dobj','pobj','probstatus','dstatus','pstatus','sol_numbarvar','sol_numcone','sol_numvar','sol_numcon']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args): # mosek.fusion.SolutionStruct
      self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):# mosek.fusion.SolutionStruct
      self._ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_ctor_IIII(*args): # int32,int32,int32,int32
      self._ctor_init_IIII(*args)
    elif self.__match_alt_ctor_IIII(*args):# int32,int32,int32,int32
      self._ctor_alt_init_IIII(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionStruct.ctor(mosek.fusion.SolutionStruct)\n\tmosek.fusion.SolutionStruct.ctor(int32,int32,int32,int32)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_SolutionStruct._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.clone()')
  def isDualAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isDualAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isDualAcceptable(mosek.fusion.AccSolutionStatus)')
  def isPrimalAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isPrimalAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isPrimalAcceptable(mosek.fusion.AccSolutionStatus)')
  def resize(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_resize_IIII(*args): # int32,int32,int32,int32
      return self._resize_IIII(*args)
    elif mosek_fusion_SolutionStruct._match_alt_resize_IIII(*args): # int32,int32,int32,int32
      return self._resize_alt_IIII(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.resize(int32,int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.SolutionStruct'
  @staticmethod
  def _ctor_IIII(numvar,numcon,numcone,numbarvar):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_IIII(numvar,numcon,numcone,numbarvar)
    return o
  @staticmethod
  def __match_ctor_IIII(*args):
    if len(args) != 4: return False
    numvar,numcon,numcone,numbarvar, = args
    return (__arg_match_I__(numvar) and __arg_match_I__(numcon) and __arg_match_I__(numcone) and __arg_match_I__(numbarvar))
  @staticmethod
  def __match_alt_ctor_IIII(*args):
    if len(args) != 4: return False
    numvar,numcon,numcone,numbarvar, = args
    return (__arg_alt_match_I__(numvar) and __arg_alt_match_I__(numcon) and __arg_alt_match_I__(numcone) and __arg_alt_match_I__(numbarvar))
  def _ctor_alt_init_IIII(self,numvar,numcon,numcone,numbarvar):
    self._ctor_init_IIII(numpy.int32(numvar),numpy.int32(numcon),numpy.int32(numcone),numpy.int32(numbarvar))
  def _ctor_init_IIII(self,numvar,numcon,numcone,numbarvar):
   self.pobj = 0.0
   self.dobj = 0.0
   self.pstatus = mosek.fusion.SolutionStatus.Unknown
   self.dstatus = mosek.fusion.SolutionStatus.Unknown
   self.probstatus = mosek.fusion.ProblemStatus.Unknown
   self.sol_numvar = numvar
   self.sol_numcon = numcon
   self.sol_numcone = numcone
   self.sol_numbarvar = numbarvar
   self.slx = None
   self.sux = None
   self.xx = None
   self.yx = None
   self.slc = None
   self.suc = None
   self.y = None
   self.xc = None
   self.snx = None
   self.barx = None
   self.bars = None
   if (numvar > 0): # src/fusion/Model.mbi:4737:12-22
    self.slx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.sux = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.xx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.yx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
   if (numbarvar > 0): # src/fusion/Model.mbi:4746:12-25
    self.barx = numpy.zeros((numbarvar,), dtype=numpy.dtype(numpy.float64))
    self.bars = numpy.zeros((numbarvar,), dtype=numpy.dtype(numpy.float64))
   if (numcon > 0): # src/fusion/Model.mbi:4752:12-22
    self.slc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.suc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.y = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.xc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
   if (numcone > 0): # src/fusion/Model.mbi:4761:12-23
    self.snx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
  @staticmethod
  def _ctor_Lmosek_4fusion_4SolutionStruct_2(that):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  def _ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
    self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
  def _ctor_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
   self.sol_numcon = (that.sol_numcon)
   self.sol_numvar = (that.sol_numvar)
   self.sol_numcone = (that.sol_numcone)
   self.sol_numbarvar = (that.sol_numbarvar)
   self.pstatus = (that.pstatus)
   self.dstatus = (that.dstatus)
   self.probstatus = (that.probstatus)
   self.pobj = (that.pobj)
   self.dobj = (that.dobj)
   self.xc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xc)) if (((that.xc) is not None) ) else None)
   self.xx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xx)) if (((that.xx) is not None) ) else None)
   self.yx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.yx)) if (((that.yx) is not None) ) else None)
   self.slc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slc) is not None) ) else None)
   self.suc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.suc) is not None) ) else None)
   self.y = (mosek.fusion.Utils.Tools._arraycopy__3D((that.y)) if (((that.y) is not None) ) else None)
   self.barx = mosek.fusion.Utils.Tools._arraycopy__3D((that.barx))
   self.bars = mosek.fusion.Utils.Tools._arraycopy__3D((that.bars))
   self.slx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slx) is not None) ) else None)
   self.sux = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.sux) is not None) ) else None)
   self.snx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.snx)) if (((that.snx) is not None) ) else None)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_SolutionStruct._ctor_Lmosek_4fusion_4SolutionStruct_2(self))
  @staticmethod
  def _match_resize_IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_resize_IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3))
  def _resize_alt_IIII(self,_t__0,_t__1,_t__2,_t__3):
    return self._resize_IIII(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),numpy.int32(__3))
  def _resize_IIII(self,_0,_1,_2,_3):
   if (_3 < 0): # src/fusion/Model.mbi:4507:14-27
    pass
   elif (_3 <= self.sol_numbarvar): # src/fusion/Model.mbi:4509:18-44
    self.sol_numbarvar = _3
   elif (_3 <= int((self.barx).shape[0])): # src/fusion/Model.mbi:4512:18-40
    pass
   else:
    if ((self.sol_numbarvar * 2) > (_3 + 100)): # src/fusion/Model.mbi:4517:18-53
     _4 = (self.sol_numbarvar * 2)
    else:
     _4 = (_3 + 100)
    self.barx = mosek.fusion.CommonTools._resize__3DI(self.barx,_4)
    self.bars = mosek.fusion.CommonTools._resize__3DI(self.bars,_4)
    self.sol_numbarvar = _4
   if (_0 < 0): # src/fusion/Model.mbi:4526:14-24
    pass
   elif (_0 <= self.sol_numvar): # src/fusion/Model.mbi:4530:18-38
    self.sol_numvar = _0
   elif (_0 <= int((self.xx).shape[0])): # src/fusion/Model.mbi:4535:18-35
    self.sol_numvar = fragments._c_closure_138(_0,self.slx,self.sol_numvar,self.sux,self.xx,self.yx) # src/fusion/Model.mbi:4536:10-4546:11
    self.sol_numvar = numpy.int32(self.sol_numvar) # postprocess
   else:
    if ((self.sol_numvar * 2) > (_0 + 100)): # src/fusion/Model.mbi:4551:18-47
     _5 = (self.sol_numvar * 2)
    else:
     _5 = (_0 + 100)
    _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slx,0,_6,0,int((self.slx).shape[0]))
    self.slx = _6
    _7=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.sux,0,_7,0,int((self.sux).shape[0]))
    self.sux = _7
    _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xx,0,_8,0,int((self.xx).shape[0]))
    self.xx = _8
    _9=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.yx,0,_9,0,int((self.yx).shape[0]))
    self.yx = _9
    fragments._c_closure_139(_0,self.slx,self.sol_numvar,self.sux,self.xx) # src/fusion/Model.mbi:4570:14-4576:15
    self.sol_numvar = _0
   if (_1 < 0): # src/fusion/Model.mbi:4581:14-24
    pass
   elif (_1 <= self.sol_numcon): # src/fusion/Model.mbi:4585:18-38
    self.sol_numcon = _1
   elif (_1 <= int((self.xx).shape[0])): # src/fusion/Model.mbi:4590:18-35
    self.sol_numcon = fragments._c_closure_140(_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) # src/fusion/Model.mbi:4591:10-4602:11
    self.sol_numcon = numpy.int32(self.sol_numcon) # postprocess
   else:
    if ((self.sol_numcon * 2) > (_1 + 100)): # src/fusion/Model.mbi:4607:18-47
     _10 = (self.sol_numcon * 2)
    else:
     _10 = (_1 + 100)
    _11=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slc,0,_11,0,int((self.slc).shape[0]))
    self.slc = _11
    _12=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.suc,0,_12,0,int((self.suc).shape[0]))
    self.suc = _12
    _13=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xc,0,_13,0,int((self.xc).shape[0]))
    self.xc = _13
    _14=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.y,0,_14,0,int((self.y).shape[0]))
    self.y = _14
    fragments._c_closure_141(_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) # src/fusion/Model.mbi:4629:14-4635:15
    self.sol_numcon = _1
   if (_2 < 0): # src/fusion/Model.mbi:4641:14-25
    pass
   elif (_2 <= self.sol_numcone): # src/fusion/Model.mbi:4645:18-40
    self.sol_numcone = _2
   elif (_2 <= int((self.xx).shape[0])): # src/fusion/Model.mbi:4650:18-36
    self.sol_numcone = fragments._c_closure_142(_2,self.snx,self.sol_numcone) # src/fusion/Model.mbi:4651:10-4659:11
    self.sol_numcone = numpy.int32(self.sol_numcone) # postprocess
   else:
    if ((self.sol_numcone * 2) > (_2 + 100)): # src/fusion/Model.mbi:4665:18-49
     _15 = (self.sol_numcone * 2)
    else:
     _15 = (_2 + 100)
    _16=numpy.zeros((_15,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.snx,0,_16,0,int((self.snx).shape[0]))
    self.snx = _16
    fragments._c_closure_143(_2,self.snx,self.sol_numcone) # src/fusion/Model.mbi:4672:14-4676:15
    self.sol_numcone = _2
  @staticmethod
  def _match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.dstatus,_0))
  @staticmethod
  def _match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.pstatus,_0))
  def __isAcceptable_alt_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_t__0,_t__1):
    return self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(__0,__1)
  def __isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_0,_1):
   if (_1==mosek.fusion.AccSolutionStatus.Anything): # src/fusion/Model.mbi:4468:16-53
    return (True)
   elif (_1==mosek.fusion.AccSolutionStatus.Optimal): # src/fusion/Model.mbi:4472:16-52
    return ((_0==mosek.fusion.SolutionStatus.Optimal))
   elif (_1==mosek.fusion.AccSolutionStatus.Feasible): # src/fusion/Model.mbi:4476:16-53
    return (((_0==mosek.fusion.SolutionStatus.Optimal) or (_0==mosek.fusion.SolutionStatus.Feasible)))
   elif (_1==mosek.fusion.AccSolutionStatus.Certificate): # src/fusion/Model.mbi:4482:16-56
    return ((_0==mosek.fusion.SolutionStatus.Certificate))
   return (False)
 return SolutionStruct
mosek_fusion_SolutionStruct=__mk_mosek_fusion_SolutionStruct()
del __mk_mosek_fusion_SolutionStruct
#BEFORE CLASS
def __mk_mosek_fusion_ConNZStruct():
 class ConNZStruct(object):
  __slots__ = ['barmidx','barsubj','barsubi','bfix','cof','subj','ptrb']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3I_3D_3D_3I_3I_3I(*args): # []int64,[]int32,[]double,[]double,[]int32,[]int32,[]int32
      self._ctor_init__3J_3I_3D_3D_3I_3I_3I(*args)
    elif self.__match_alt_ctor__3J_3I_3D_3D_3I_3I_3I(*args):# []int64,[]int32,[]double,[]double,[]int32,[]int32,[]int32
      self._ctor_alt_init__3J_3I_3D_3D_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ConNZStruct.ctor(array(int64,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ConNZStruct'
  @staticmethod
  def _ctor__3J_3I_3D_3D_3I_3I_3I(ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
    o = ConNZStruct.__new__(ConNZStruct)
    o._ctor_init__3J_3I_3D_3D_3I_3I_3I(ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_)
    return o
  @staticmethod
  def __match_ctor__3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3I__(subj_) and __arg_match__3D__(cof_) and __arg_match__3D__(bfix_) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barmidx_))
  @staticmethod
  def __match_alt_ctor__3J_3I_3D_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barmidx_))
  def _ctor_alt_init__3J_3I_3D_3D_3I_3I_3I(self,ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
    self._ctor_init__3J_3I_3D_3D_3I_3I_3I(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barmidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3J_3I_3D_3D_3I_3I_3I(self,ptrb_,subj_,cof_,bfix_,barsubi_,barsubj_,barmidx_):
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barmidx_ is None or isinstance(barmidx_,numpy.ndarray)
   self.ptrb = ptrb_
   self.subj = subj_
   self.cof = cof_
   self.bfix = bfix_
   self.barsubi = barsubi_
   self.barsubj = barsubj_
   self.barmidx = barmidx_
 return ConNZStruct
mosek_fusion_ConNZStruct=__mk_mosek_fusion_ConNZStruct()
del __mk_mosek_fusion_ConNZStruct
#BEFORE CLASS
def __mk_mosek_fusion_BaseVariable():
 class BaseVariable(mosek_fusion_Variable,object):
  __slots__ = ['_BaseVariable__sparsity','_BaseVariable__nativeidxs','_BaseVariable__model','_BaseVariable__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args): # mosek.fusion.Model,[]int32,[]int64,[]int64
      self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):# mosek.fusion.Model,[]int32,[]int64,[]int64
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseVariable.ctor(mosek.fusion.Model,array(int32,ndim=1),array(int64,ndim=1),array(int64,ndim=1))')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_BaseVariable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.setLevel(array(double,ndim=1))')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.set_values(array(double,ndim=1),bool)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_integer()')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getDim(int32)')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getModel()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getSize()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_BaseVariable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.transpose()')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.values(int32,array(double,ndim=1),bool)')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_BaseVariable._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.remove()')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.antidiag()\n\tmosek.fusion.BaseVariable.antidiag(int32)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_BaseVariable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeContinuous()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BaseVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.dual()')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_BaseVariable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.numInst()')
  def fromTril(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_fromTril_I(*args): # int32
      return self._fromTril_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_fromTril_I(*args): # int32
      return self._fromTril_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_fromTril_II(*args): # int32,int32
      return self._fromTril_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_fromTril_II(*args): # int32,int32
      return self._fromTril_alt_II(*args)
    else:
      raise ValueError('Invalid argument list fromTril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.fromTril(int32)\n\tmosek.fusion.BaseVariable.fromTril(int32,int32)')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getND()')
  def tril(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_tril_(*args): # 
      return self._tril_(*args)
    elif mosek_fusion_BaseVariable._match_alt_tril_(*args): # 
      return self._tril_alt_(*args)
    elif mosek_fusion_BaseVariable._match_tril_II(*args): # int32,int32
      return self._tril_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_tril_II(*args): # int32,int32
      return self._tril_alt_II(*args)
    else:
      raise ValueError('Invalid argument list tril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.tril()\n\tmosek.fusion.BaseVariable.tril(int32,int32)')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeInteger()')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_reshape_I(*args): # int32
      return self._reshape_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_I(*args): # int32
      return self._reshape_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_reshape_II(*args): # int32,int32
      return self._reshape_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_II(*args): # int32,int32
      return self._reshape_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_reshape_III(*args): # int32,int32,int32
      return self._reshape_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_III(*args): # int32,int32,int32
      return self._reshape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.reshape(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.reshape(int32)\n\tmosek.fusion.BaseVariable.reshape(int32,int32)\n\tmosek.fusion.BaseVariable.reshape(int32,int32,int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_BaseVariable._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.slice(int32,int32)\n\tmosek.fusion.BaseVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_BaseVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.toString()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.index(int32)\n\tmosek.fusion.BaseVariable.index(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.index(int32,int32)\n\tmosek.fusion.BaseVariable.index(int32,int32,int32)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getShape()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_continuous()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_BaseVariable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.level()')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.diag()\n\tmosek.fusion.BaseVariable.diag(int32)')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_BaseVariable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.asExpr()')
  def __repr__(self): return 'mosek.fusion.BaseVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   self.__model = m
   self.__shape = (v.__shape)
   self.__sparsity = (v.__sparsity)
   self.__nativeidxs = (v.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   self.__model = m
   (self.__shape) = shape
   (self.__sparsity) = sparsity
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Variable((")
   if (int((self.__shape).shape[0]) > 0): # src/fusion/BaseVariable.monty:962:12-26
    _0._a_I(self.__shape[0])
    for _1 in range(1,int((self.__shape).shape[0])):
     _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S("))")
   return (_0._toString_())
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__nativeidxs).shape[0])
   _4=_3
   _5=int((self.__shape).shape[0])
   _6=(self.__sparsity is not None)
   _0._alloc_1expr_IIIZ(_5,_4,_3,_6)
   _7=(_0.ptr_base)
   _8=(_0.nidxs_base)
   _9=(_0.sp_base)
   _10=(_0.cof_base)
   _11=(_0.shape_base)
   _12=(_0.i32)
   _13=(_0.i64)
   _14=(_0.f64)
   fragments._c_closure_144(_5,_12,self.__shape,_11) # src/fusion/BaseVariable.monty:944:8-945:40
   fragments._c_closure_145(_10,_6,self.__nativeidxs,_8,_3,_7,_14,_12,_13,_9,self.__sparsity) # src/fusion/BaseVariable.monty:947:8-953:9
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   raise mosek_fusion_DeletionError._ctor_S("Only original variables can be removed")
  @staticmethod
  def _match_fromTril_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_fromTril_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _fromTril_alt_II(self,_t__0,_t__1):
    return self._fromTril_II(numpy.int32(__0),numpy.int32(__1))
  def _fromTril_II(self,_0,_1):
   if ((_0 < 0) or (_0 >= int((self.__shape).shape[0]))): # src/fusion/BaseVariable.monty:845:16-46
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension")
   elif (self.__shape[_0]!=((_1 * (_1 + 1)) // 2)): # src/fusion/BaseVariable.monty:846:16-40
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   _2=1
   _2 = fragments._c_closure_146(_2,_0,self.__shape) # src/fusion/BaseVariable.monty:848:20-57
   _2 = numpy.int32(_2) # postprocess
   _3=self.__shape[_0]
   _4=1
   _4 = fragments._c_closure_147(_4,_0,self.__shape) # src/fusion/BaseVariable.monty:850:20-68
   _4 = numpy.int32(_4) # postprocess
   _5=numpy.zeros(((int((self.__shape).shape[0]) + 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_148(_0,_5,self.__shape) # src/fusion/BaseVariable.monty:853:8-51
   _5[_0] = _1
   _5[(_0 + 1)] = _1
   fragments._c_closure_149(_0,_5,self.__shape) # src/fusion/BaseVariable.monty:856:8-64
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:858:12-28
    _6=numpy.zeros(((((_2 * _1) * _1) * _4),), dtype=numpy.dtype(numpy.int64))
    _7=0
    _7 = fragments._c_closure_150(_1,_2,_3,_4,self.__nativeidxs,_6,_7) # src/fusion/BaseVariable.monty:861:10-870:17
    _7 = numpy.int32(_7) # postprocess
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_5,None,_6))
   else:
    _8=0
    for _9 in range(0,int((self.__sparsity).shape[0])):
     _10=((self.__sparsity[_9] // _4) % _3)
     _11=numpy.int32((((- 1) + mosek.fusion.Utils.Tools._sqrt_D(((1 + (2 * _10)) * (1 + (2 * _10))))) / 4))
     _12=(self.__sparsity[_9] - ((_11 * (_11 + 1)) // 2))
     if (_11==_12): # src/fusion/BaseVariable.monty:883:16-24
      _8 += 1
     else:
      _8 += 2
    _13=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_151(_8,_15) # src/fusion/BaseVariable.monty:890:38-72
    _16=0
    for _17 in range(0,int((self.__sparsity).shape[0])):
     _18=(self.__sparsity[_17] // (_3 * _4))
     _19=((self.__sparsity[_17] // _4) % _3)
     _20=(self.__sparsity[_17] % _4)
     _21=numpy.int32((((- 1) + mosek.fusion.Utils.Tools._sqrt_D(((1 + (2 * _19)) * (1 + (2 * _19))))) / 4))
     _22=(self.__sparsity[_17] - ((_21 * (_21 + 1)) // 2))
     if (_21==_22): # src/fusion/BaseVariable.monty:901:16-26
      _13[_16] = self.__nativeidxs[_17]
      _14[_16] = (((((_18 * _1) * _1) * _4) + (((_21 * _1) + _22) * _4)) + _20)
      _16 += 1
     else:
      _13[_16] = self.__nativeidxs[_17]
      _13[(_16 + 1)] = self.__nativeidxs[_17]
      _14[_16] = (((((_18 * _1) * _1) * _4) + (((_21 * _1) + _22) * _4)) + _20)
      _14[(_16 + 1)] = (((((_18 * _1) * _1) * _4) + (((_22 * _1) + _21) * _4)) + _20)
      _16 += 2
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_15,_13,None,0,_8)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_5,numpy.array([_14[_15[_23]] for _23 in range(0,_8)], dtype=numpy.dtype(numpy.int64)),numpy.array([_13[_15[_24]] for _24 in range(0,_8)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_fromTril_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_fromTril_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _fromTril_alt_I(self,_t__0):
    return self._fromTril_I(numpy.int32(__0))
  def _fromTril_I(self,_0):
   return (self._fromTril_II(0,_0))
  @staticmethod
  def _match_tril_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_tril_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _tril_alt_II(self,_t__0,_t__1):
    return self._tril_II(numpy.int32(__0),numpy.int32(__1))
  def _tril_II(self,_0,_1):
   if ((_0 < 0) or ((_0 >= _1) or (_1 >= int((self.__shape).shape[0])))): # src/fusion/BaseVariable.monty:739:17-63
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension specification")
   else:
    if (self.__shape[_0]!=self.__shape[_1]): # src/fusion/BaseVariable.monty:740:17-43
     raise mosek_fusion_DimensionError._ctor_S("Operation only valid for square variables")
   _2=numpy.zeros(((int((self.__shape).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_152(_0,_2,self.__shape) # src/fusion/BaseVariable.monty:743:8-51
   _2[_0] = ((self.__shape[_0] * (self.__shape[_0] + 1)) // 2)
   fragments._c_closure_153(_0,_1,_2,self.__shape) # src/fusion/BaseVariable.monty:745:8-56
   fragments._c_closure_154(_1,_2,self.__shape) # src/fusion/BaseVariable.monty:746:8-64
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:748:12-28
    _3=1
    _3 = fragments._c_closure_155(_3,_0,self.__shape) # src/fusion/BaseVariable.monty:749:22-59
    _3 = numpy.int32(_3) # postprocess
    _4=self.__shape[_0]
    _5=1
    _5 = fragments._c_closure_156(_5,_0,_1,self.__shape) # src/fusion/BaseVariable.monty:751:22-64
    _5 = numpy.int32(_5) # postprocess
    _6=self.__shape[_1]
    _7=1
    _7 = fragments._c_closure_157(_7,_1,self.__shape) # src/fusion/BaseVariable.monty:753:22-70
    _7 = numpy.int32(_7) # postprocess
    _8=numpy.zeros(((((((_3 * _5) * _7) * _4) * (_4 + 1)) // 2),), dtype=numpy.dtype(numpy.int64))
    _9=0
    _9 = fragments._c_closure_158(_3,_4,_5,_6,_7,_9,self.__nativeidxs,_8) # src/fusion/BaseVariable.monty:757:10-764:19
    _9 = numpy.int32(_9) # postprocess
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_2,None,_8))
   else:
    _10=1
    _10 = fragments._c_closure_159(_10,_0,self.__shape) # src/fusion/BaseVariable.monty:769:22-59
    _10 = numpy.int32(_10) # postprocess
    _11=self.__shape[_0]
    _12=1
    _12 = fragments._c_closure_160(_12,_0,_1,self.__shape) # src/fusion/BaseVariable.monty:771:22-64
    _12 = numpy.int32(_12) # postprocess
    _13=self.__shape[_1]
    _14=1
    _14 = fragments._c_closure_161(_14,_1,self.__shape) # src/fusion/BaseVariable.monty:773:22-70
    _14 = numpy.int32(_14) # postprocess
    _15=1
    _16=_14
    _17=(_16 * _13)
    _18=(_17 * _12)
    _19=(_18 * _11)
    _20=0
    _20 = fragments._c_closure_162(_11,_13,_20,_18,_16,self.__sparsity) # src/fusion/BaseVariable.monty:783:10-784:63
    _20 = numpy.int32(_20) # postprocess
    _21=1
    _22=_14
    _23=(_22 * _12)
    _24=(((_23 * _11) * (_11 + 1)) // 2)
    _25=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _26=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _27=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _28=0
    _28 = fragments._c_closure_163(_11,_12,_13,_14,_28,self.__nativeidxs,_20,_25,_26,_24,_23,_22,_21,_27,_19,_18,_17,_16,_15,self.__sparsity) # src/fusion/BaseVariable.monty:796:10-814:11
    _28 = numpy.int32(_28) # postprocess
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_25,_26,None,0,_20)
    _29=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _30=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_164(_20,_29,_25,_26) # src/fusion/BaseVariable.monty:820:10-63
    fragments._c_closure_165(_20,_25,_27,_30) # src/fusion/BaseVariable.monty:821:10-60
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_2,_30,_29))
  @staticmethod
  def _match_tril_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_tril_(*args):
    if len(args) != 0: return False
    return True
  def _tril_alt_(self,):
    return self._tril_()
  def _tril_(self,):
   return (self._tril_II(0,1))
  @staticmethod
  def _match_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _reshape_alt_III(self,_t__0,_t__1,_t__2):
    return self._reshape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _reshape_III(self,_0,_1,_2):
   return (self._reshape__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _reshape_alt_II(self,_t__0,_t__1):
    return self._reshape_II(numpy.int32(__0),numpy.int32(__1))
  def _reshape_II(self,_0,_1):
   return (self._reshape__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _reshape_alt_I(self,_t__0):
    return self._reshape_I(numpy.int32(__0))
  def _reshape_I(self,_0):
   return (self._reshape__3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   for _2 in range(0,int((_0).shape[0])):
    if (_0[_2] < 0): # src/fusion/BaseVariable.monty:722:14-26
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape")
    _1 *= _0[_2]
   if (_1!=self._getSize_()): # src/fusion/BaseVariable.monty:726:12-34
    raise mosek_fusion_LengthError._ctor_S("Shape size does not match variable size")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_0[_3] for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),self.__sparsity,self.__nativeidxs))
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:707:12-28
    if (int((_0).shape[0])!=int((self.__nativeidxs).shape[0])): # src/fusion/BaseVariable.monty:708:14-39
     raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
    self.__model._setVariableValues_Z_3J_3D(True,self.__nativeidxs,_0)
   else:
    if (int((_0).shape[0])!=self._getSize_()): # src/fusion/BaseVariable.monty:712:14-33
     raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
    _1=numpy.array([_0[self.__sparsity[_2]] for _2 in range(0,int((self.__nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.float64))
    self.__model._setVariableValues_Z_3J_3D(True,self.__nativeidxs,_1)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   return numpy.int32(self.__shape[_0])
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   _0=1
   _0 = fragments._c_closure_166(self.__shape,_0) # src/fusion/BaseVariable.monty:699:51-94
   _0 = numpy.int64(_0) # postprocess
   return numpy.int64(_0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__model._getVariableValues_Z_3J_3DI(False,self.__nativeidxs,_0,0)
   if (self.__sparsity is not None): # src/fusion/BaseVariable.monty:690:12-28
    _1=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_167(self.__nativeidxs,_0,self.__sparsity,_1) # src/fusion/BaseVariable.monty:692:10-76
    _0 = _1
   return (_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__model._getVariableValues_Z_3J_3DI(True,self.__nativeidxs,_0,0)
   if (self.__sparsity is not None): # src/fusion/BaseVariable.monty:678:12-28
    _1=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_168(self.__nativeidxs,_0,self.__sparsity,_1) # src/fusion/BaseVariable.monty:680:10-76
    _0 = _1
   return (_0)
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   self._make_1continuous_()
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   self._make_1integer_()
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   if (int((self.__shape).shape[0])==1): # src/fusion/BaseVariable.monty:632:12-27
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([1,self.__shape[0]], dtype=numpy.dtype(numpy.int32)),self.__sparsity,self.__nativeidxs))
   elif (int((self.__shape).shape[0]) > 2): # src/fusion/BaseVariable.monty:635:16-30
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   else:
    _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _1=(None if ((self.__sparsity is None) ) else numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.int64)))
    fragments._c_closure_169(_0,self.__nativeidxs,self.__shape,_1,self.__sparsity) # src/fusion/BaseVariable.monty:640:10-661:11
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([self.__shape[1],self.__shape[0]], dtype=numpy.dtype(numpy.int32)),_1,_0))
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   return (self._index__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   return (self._index__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((1,int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_170(_0,_1) # src/fusion/BaseVariable.monty:609:8-57
   return (self._pick__3_5I(_1)._reshape__3I(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self._pick__3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32)))._reshape__3I(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (int((self.__shape).shape[0])!=3): # src/fusion/BaseVariable.monty:584:12-27
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((_2).shape[0]))): # src/fusion/BaseVariable.monty:586:12-52
    raise mosek_fusion_LengthError._ctor_S("Mismatching argument lengths")
   _3=numpy.zeros((int((_0).shape[0]),3,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_171(_0,_1,_2,_3) # src/fusion/BaseVariable.monty:590:8-594:9
   return (self._pick__3_5I(_3))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int((self.__shape).shape[0])!=2) or (int((_0).shape[0])!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:567:12-49
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _2=numpy.zeros((int((_0).shape[0]),2,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_172(_0,_1,_2) # src/fusion/BaseVariable.monty:571:8-574:9
   return (self._pick__3_5I(_2))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((self.__shape).shape[0])!=int((_0).shape[1])): # src/fusion/BaseVariable.monty:504:12-38
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _1=False
   _1 = fragments._c_closure_173(_1,_0,self.__shape) # src/fusion/BaseVariable.monty:508:8-511:34
   if _1: # src/fusion/BaseVariable.monty:512:12-24
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _2=int((self.__shape).shape[0])
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _3[(_2 - 1)] = 1
   fragments._c_closure_174(_2,self.__shape,_3) # src/fusion/BaseVariable.monty:518:8-74
   _4=numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))
   _6=None
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:524:12-28
    _5 = numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_175(_5,_0,self.__nativeidxs,_2,_3) # src/fusion/BaseVariable.monty:526:10-532:11
   else:
    _7=0
    for _8 in range(0,int((_0).shape[0])):
     _9=0
     _9 = fragments._c_closure_176(_8,_9,_0,_2,_3) # src/fusion/BaseVariable.monty:537:12-60
     _9 = numpy.int64(_9) # postprocess
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_9) >= 0): # src/fusion/BaseVariable.monty:538:16-59
      _7 += 1
    _5 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _6 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _10=0
    for _11 in range(0,int((_0).shape[0])):
     _12=0
     _12 = fragments._c_closure_177(_11,_12,_0,_2,_3) # src/fusion/BaseVariable.monty:547:14-62
     _12 = numpy.int64(_12) # postprocess
     _13=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_12)
     if (_13 >= 0): # src/fusion/BaseVariable.monty:549:18-27
      _5[_10] = self.__nativeidxs[_13]
      _6[_10] = _11
      _10 += 1
    if (_7==int((_0).shape[0])): # src/fusion/BaseVariable.monty:556:14-33
     _6 = None
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_4,_6,_5))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:462:12-27
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _1=False
   _1 = fragments._c_closure_178(_0,_1,self.__shape) # src/fusion/BaseVariable.monty:466:8-468:32
   if _1: # src/fusion/BaseVariable.monty:469:12-24
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _3=None
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:474:12-28
    _2 = numpy.array([self.__nativeidxs[_0[_4]] for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   else:
    _5=0
    for _6 in range(0,int((_0).shape[0])):
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_0[_6]) >= 0): # src/fusion/BaseVariable.monty:480:16-64
      _5 += 1
    _2 = numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _3 = numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _7=0
    for _8 in range(0,int((_0).shape[0])):
     _9=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_0[_8])
     if (_9 >= 0): # src/fusion/BaseVariable.monty:489:16-22
      _3[_7] = _8
      _2[_7] = self.__nativeidxs[_9]
      _7 += 1
    if (_5==int((_0).shape[0])): # src/fusion/BaseVariable.monty:495:14-30
     _3 = None
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)),_3,_2))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:448:12-27
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   elif ((_0 >= self.__shape[1]) or ((- _0) >= self.__shape[2])): # src/fusion/BaseVariable.monty:450:16-55
    raise mosek_fusion_IndexError._ctor_S("Diagonal index out of bounds")
   if (_0 >= 0): # src/fusion/BaseVariable.monty:453:12-22
    return (self.__general_1diag__3I_3II(numpy.array([0,((self.__shape[1] - 1) - _0)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < (self.__shape[1] - _0)) ) else (self.__shape[1] - _0))))
   else:
    return (self.__general_1diag__3I_3II(numpy.array([(- _0),(self.__shape[1] - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[1] if ((self.__shape[1] < (self.__shape[0] + _0)) ) else (self.__shape[0] + _0))))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:440:12-27
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3II(numpy.array([0,(self.__shape[1] - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < self.__shape[1]) ) else self.__shape[1])))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:427:12-27
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   elif ((_0 >= self.__shape[1]) or ((- _0) >= self.__shape[2])): # src/fusion/BaseVariable.monty:429:16-55
    raise mosek_fusion_IndexError._ctor_S("Diagonal index out of bounds")
   if (_0 >= 0): # src/fusion/BaseVariable.monty:432:12-22
    return (self.__general_1diag__3I_3II(numpy.array([0,_0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < (self.__shape[1] - _0)) ) else (self.__shape[1] - _0))))
   else:
    return (self.__general_1diag__3I_3II(numpy.array([(- _0),0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[1] if ((self.__shape[1] < (self.__shape[0] + _0)) ) else (self.__shape[0] + _0))))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:420:12-27
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3II(numpy.array([0,0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < self.__shape[1]) ) else self.__shape[1])))
  def __general_1diag_alt__3I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self.__general_1diag__3I_3II(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __general_1diag__3I_3II(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((self.__shape).shape[0])
   if ((_3!=int((_0).shape[0])) or (_3!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:371:13-372:28
    raise mosek_fusion_DimensionError._ctor_S("Invalid start or step definition")
   for _4 in range(0,_3):
    if ((_0[_4] < 0) or (_0[_4] >= self.__shape[_4])): # src/fusion/BaseVariable.monty:375:15-57
     raise mosek_fusion_LengthError._ctor_S("Start element is out of bounds")
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _5[(_3 - 1)] = 1
   fragments._c_closure_179(_3,self.__shape,_5) # src/fusion/BaseVariable.monty:379:27-93
   _6=0
   _6 = fragments._c_closure_180(_0,_6,_1,_5) # src/fusion/BaseVariable.monty:381:29-95
   _6 = numpy.int64(_6) # postprocess
   _7=0
   _7 = fragments._c_closure_181(_1,_7,_5) # src/fusion/BaseVariable.monty:382:29-91
   _7 = numpy.int64(_7) # postprocess
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:384:12-28
    _8=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_182(self.__nativeidxs,_2,_8,_6,_7) # src/fusion/BaseVariable.monty:386:10-387:59
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),None,_8))
   else:
    _9=0
    for _10 in range(0,_2):
     _11=(_6 + (_7 * _10))
     _12=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_11)
     if (_12 >= 0): # src/fusion/BaseVariable.monty:395:16-26
      _9 += 1
    _13=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _15=0
    for _16 in range(0,_2):
     _13[_16] = self.__nativeidxs[(_6 + (_7 * _16))]
     _17=(_6 + (_7 * _16))
     _18=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_17)
     if (_18 >= 0): # src/fusion/BaseVariable.monty:405:16-26
      _14[_15] = _16
      _13[_15] = self.__nativeidxs[_18]
      _15 += 1
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),_14,_13))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/BaseVariable.monty:263:12-35
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   elif (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/BaseVariable.monty:265:16-40
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   else:
    for _2 in range(0,int((self.__shape).shape[0])):
     if ((_0[_2] < 0) or (_1[_2] > self.__shape[_2])): # src/fusion/BaseVariable.monty:269:16-50
      raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
     elif (_0[_2] > _1[_2]): # src/fusion/BaseVariable.monty:271:20-38
      raise mosek_fusion_SliceError._ctor_S("Invalid slice")
    _3=int((self.__shape).shape[0])
    _4=numpy.array([(_1[_5] - _0[_5]) for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _6=1
    _6 = fragments._c_closure_183(_0,_1,_3,_6) # src/fusion/BaseVariable.monty:277:29-79
    _6 = numpy.int32(_6) # postprocess
    if (_6==0): # src/fusion/BaseVariable.monty:278:14-28
     return (mosek_fusion_NilVariable._ctor_())
    elif (self.__sparsity is not None): # src/fusion/BaseVariable.monty:280:18-34
     _7=0
     _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
     _7 = fragments._c_closure_184(_0,_8,_1,_3,_7,self.__shape,self.__sparsity) # src/fusion/BaseVariable.monty:284:12-295:13
     _7 = numpy.int32(_7) # postprocess
     _9=0
     _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _11=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _9 = fragments._c_closure_185(_0,_9,_10,_8,_1,self.__nativeidxs,_3,self.__shape,_4,_11,self.__sparsity) # src/fusion/BaseVariable.monty:300:12-320:13
     _9 = numpy.int32(_9) # postprocess
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_4,_11,_10))
    else:
     _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
     fragments._c_closure_186(_0,_1,self.__nativeidxs,_3,self.__shape,_12,_6) # src/fusion/BaseVariable.monty:326:12-353:13
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_4,None,_12))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:230:12-27
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   if ((_0==0) and (_1==self.__shape[0])): # src/fusion/BaseVariable.monty:232:12-43
    return (self)
   elif ((_0 < 0) or (_1 > self.__shape[0])): # src/fusion/BaseVariable.monty:234:16-44
    raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   elif (_0 > _1): # src/fusion/BaseVariable.monty:236:16-28
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   elif (_0==_1): # src/fusion/BaseVariable.monty:238:16-29
    return (mosek_fusion_NilVariable._ctor_())
   elif (self.__sparsity is not None): # src/fusion/BaseVariable.monty:240:16-32
    _2=(_1 - _0)
    _3=0
    _4=mosek.fusion.CommonTools._binarySearchL__3JJ(self.__sparsity,_0)
    _5=mosek.fusion.CommonTools._binarySearchL__3JJ(self.__sparsity,_1)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),numpy.array([(self.__sparsity[_6] - _0) for _6 in range(_4,_5)], dtype=numpy.dtype(numpy.int64)),numpy.array([self.__nativeidxs[_7] for _7 in range(_4,_5)], dtype=numpy.dtype(numpy.int64))))
   else:
    _8=(_1 - _0)
    _9=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.__nativeidxs,_0,_9,0,_8)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_8], dtype=numpy.dtype(numpy.int32)),None,_9))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_ExprFromVar._ctor_Lmosek_4fusion_4Variable_2(self))
  @staticmethod
  def _match_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match__3J__(_3))
  @staticmethod
  def _match_alt_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match__3J__(_3))
  def _inst_alt_I_3JI_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3JI_3J(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3JI_3J(self,_0,_1,_2,_3):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=(self.__nativeidxs)
   _5=(self.__sparsity)
   if (_5 is None): # src/fusion/BaseVariable.monty:194:12-26
    fragments._c_closure_187(_3,_2,_1,_0,_4) # src/fusion/BaseVariable.monty:194:28-199:9
   else:
    for _6 in range(0,int(((self.__sparsity)).shape[0])):
     _1[(_0 + _6)] = _5[_6]
     _3[(_6 + _2)] = _4[_6]
   return numpy.int32(int(((self.__nativeidxs)).shape[0]))
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   return numpy.int32(int((self.__nativeidxs).shape[0]))
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:169:17-33
    fragments._c_closure_188(self.__nativeidxs,_1,_0) # src/fusion/BaseVariable.monty:170:10-171:45
   else:
    _2=self._getShape_()
    _3=1
    _3 = fragments._c_closure_189(_3,_2) # src/fusion/BaseVariable.monty:174:27-75
    _3 = numpy.int32(_3) # postprocess
    fragments._c_closure_190(_3,_1,_0) # src/fusion/BaseVariable.monty:175:10-56
    fragments._c_closure_191(self.__nativeidxs,_1,_0,self.__sparsity) # src/fusion/BaseVariable.monty:176:10-177:55
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:151:12-28
    self._getModel_()._setVariableValues_Z_3J_3D(_1,self.__nativeidxs,_0)
   else:
    _2=1
    _2 = fragments._c_closure_192(self.__shape,_2) # src/fusion/BaseVariable.monty:155:27-75
    _2 = numpy.int32(_2) # postprocess
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_193(_3,self.__nativeidxs,self.__sparsity) # src/fusion/BaseVariable.monty:158:10-159:46
    self._getModel_()._setVariableValues_Z_3J_3D(_1,_3,_0)
  def _dual_1lu_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._dual_1lu_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1lu_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:136:12-28
    self.__model._getVariableDuals_Z_3J_3DI(_2,self.__nativeidxs,_1,_0)
   else:
    _3=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_194(_3,self.__nativeidxs,self.__sparsity) # src/fusion/BaseVariable.monty:140:10-141:46
    self.__model._getVariableDuals_Z_3J_3DI(_2,_3,_1,_0)
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:121:12-28
    self.__model._getVariableValues_Z_3J_3DI(_2,self.__nativeidxs,_1,_0)
   else:
    _3=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_195(_3,self.__nativeidxs,self.__sparsity) # src/fusion/BaseVariable.monty:125:10-126:46
    self.__model._getVariableValues_Z_3J_3DI(_2,_3,_1,_0)
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   self._getModel_()._make_1continuous__3J(self.__nativeidxs)
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   self._getModel_()._make_1integer__3J(self.__nativeidxs)
 return BaseVariable
mosek_fusion_BaseVariable=__mk_mosek_fusion_BaseVariable()
del __mk_mosek_fusion_BaseVariable
#BEFORE CLASS
def __mk_mosek_fusion_SliceVariable():
 class SliceVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_SliceVariable__shape','_SliceVariable__sparsity','_SliceVariable__nativeidxs']
  def __repr__(self): return 'mosek.fusion.SliceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs)
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__shape) = shape
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceVariable_2(v):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4SliceVariable_2(v)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceVariable_2(*args):
    if len(args) != 1: return False
    v, = args
    return (__arg_match_Lmosek_4fusion_4SliceVariable_2__(v))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceVariable_2(*args):
    if len(args) != 1: return False
    v, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v))
  def _ctor_alt_init_Lmosek_4fusion_4SliceVariable_2(self,v):
    self._ctor_init_Lmosek_4fusion_4SliceVariable_2(v)
  def _ctor_init_Lmosek_4fusion_4SliceVariable_2(self,v):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,v._getModel_())
   (self.__nativeidxs) = (v.__nativeidxs)
   (self.__sparsity) = (v.__sparsity)
   (self.__shape) = (v.__shape)
 return SliceVariable
mosek_fusion_SliceVariable=__mk_mosek_fusion_SliceVariable()
del __mk_mosek_fusion_SliceVariable
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceVariable():
 class BoundInterfaceVariable(mosek_fusion_SliceVariable):
  __slots__ = ['_BoundInterfaceVariable__islower']
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.transpose()')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.antidiag()\n\tmosek.fusion.BoundInterfaceVariable.antidiag(int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.slice(int32,int32)\n\tmosek.fusion.BoundInterfaceVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.dual()')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.diag()\n\tmosek.fusion.BoundInterfaceVariable.diag(int32)')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.BoundInterfaceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,shape,sparsity,nativeidxs,islower):
    o = BoundInterfaceVariable.__new__(BoundInterfaceVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,shape,sparsity,nativeidxs,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(*args):
    if len(args) != 5: return False
    m,shape,sparsity,nativeidxs,islower, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(*args):
    if len(args) != 5: return False
    m,shape,sparsity,nativeidxs,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self,m,shape,sparsity,nativeidxs,islower):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)),islower)
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self,m,shape,sparsity,nativeidxs,islower):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_SliceVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs)
   (self.__islower) = islower
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceVariable_2Z(v,islower):
    o = BoundInterfaceVariable.__new__(BoundInterfaceVariable)
    o._ctor_init_Lmosek_4fusion_4SliceVariable_2Z(v,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceVariable_2Z(*args):
    if len(args) != 2: return False
    v,islower, = args
    return (__arg_match_Lmosek_4fusion_4SliceVariable_2__(v) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceVariable_2Z(*args):
    if len(args) != 2: return False
    v,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4SliceVariable_2Z(self,v,islower):
    self._ctor_init_Lmosek_4fusion_4SliceVariable_2Z(v,islower)
  def _ctor_init_Lmosek_4fusion_4SliceVariable_2Z(self,v,islower):
   mosek_fusion_SliceVariable._ctor_init_Lmosek_4fusion_4SliceVariable_2(self,v)
   (self.__islower) = islower
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
   self._dual_1lu_I_3DZ(0,_0,self.__islower)
   return (_0)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._transpose_(self)))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I_3I_3I(self,_0,_1,_2)))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I_3I(self,_0,_1)))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3_5I(self,_0)))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I(self,_0)))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._antidiag_I(self,_0)))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._antidiag_(self)))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._diag_I(self,_0)))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._diag_(self)))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._slice__3I_3I(self,_0,_1)))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._slice_II(self,_0,_1)))
  def __from_1_alt_Lmosek_4fusion_4Variable_2(self,_t__0):
    return self.__from_1_Lmosek_4fusion_4Variable_2(_0)
  def __from_1_Lmosek_4fusion_4Variable_2(self,_0):
   _1=self._getShape_()
   _2=_0._numInst_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _4=None
   if (_0._getSize_()==_2): # src/fusion/BoundInterfaceVariable.mbi:57:12-30
    _0._inst_I_3J(0,_3)
   else:
    _4 = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _0._inst_I_3JI_3J(0,_4,0,_3)
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(_0._getModel_(),_1,_4,_3,self.__islower))
 return BoundInterfaceVariable
mosek_fusion_BoundInterfaceVariable=__mk_mosek_fusion_BoundInterfaceVariable()
del __mk_mosek_fusion_BoundInterfaceVariable
#BEFORE CLASS
def __mk_mosek_fusion_ModelVariable():
 class ModelVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_ModelVariable__sparsity','_ModelVariable__shape','_ModelVariable__nativeidxs','_ModelVariable__varid','_ModelVariable__name']
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ModelVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_ModelVariable._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.remove()')
  def __repr__(self): return 'mosek.fusion.ModelVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__name = (v.__name)
   self.__varid = (v.__varid)
   self.__nativeidxs = (v.__nativeidxs)
   self.__shape = (v.__shape)
   self.__sparsity = (v.__sparsity)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,shape,varid,sparsity,nativeidxs):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,shape,varid,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(*args):
    if len(args) != 6: return False
    model,name,shape,varid,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match_J__(varid) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(*args):
    if len(args) != 6: return False
    model,name,shape,varid,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match_J__(varid) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,model,shape,sparsity,nativeidxs)
   (self.__name) = name
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__sparsity) = sparsity
   (self.__nativeidxs) = nativeidxs
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self.__name))==0) ) else self.__name))._a_S("[")._a_S(mosek.fusion.Set._indexToString__3IJ(self.__shape,_0))._a_S("]")
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   self._getModel_()._removeVariableBlock_J(self.__varid)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
 return ModelVariable
mosek_fusion_ModelVariable=__mk_mosek_fusion_ModelVariable()
del __mk_mosek_fusion_ModelVariable
#BEFORE CLASS
def __mk_mosek_fusion_SymRangedVariable():
 class SymRangedVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_SymRangedVariable__dim','_SymRangedVariable__sparsity','_SymRangedVariable__nativeidxs','_SymRangedVariable__names_flushed','_SymRangedVariable__name']
  def __repr__(self): return 'mosek.fusion.SymRangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = SymRangedVariable.__new__(SymRangedVariable)
    o._ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymRangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__name = (v.__name)
   self.__sparsity = (v.__sparsity)
   self.__nativeidxs = (v.__nativeidxs)
   self.__dim = (v.__dim)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,varid,dim,sparsity,nativeidxs):
    o = SymRangedVariable.__new__(SymRangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,varid,dim,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,dim,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match_I__(dim) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,dim,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match_I__(dim) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJI_3J_3I(self,model,name,varid,dim,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,numpy.int64(varid),numpy.int32(dim),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(self,model,name,varid,dim,sparsity,nativeidxs):
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,numpy.array([dim,dim], dtype=numpy.dtype(numpy.int32)),varid,mosek.fusion.SymRangedVariable.__mirror_1sp_I_3J(dim,sparsity),mosek.fusion.SymRangedVariable.__mirror_1idxs_I_3J_3I(dim,sparsity,nativeidxs))
   self.__names_flushed = False
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__dim) = dim
  def _dual_1u_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._dual_1lu_I_3DZ(_0,_1,False)
  def _dual_1l_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._dual_1lu_I_3DZ(_0,_1,True)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self._getModel_()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/SymRangedVariable.mbi:140:12-47
    if (self.__sparsity is None): # src/fusion/SymRangedVariable.mbi:142:14-30
     for _1 in range(0,int((self.__nativeidxs).shape[0])):
      _0._varname_IS(self.__nativeidxs[_1],("" if ((int(len(self.__name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self.__name)._a_S("[")._a_I((_1 // self.__dim))._a_S(",")._a_I((_1 % self.__dim))._a_S("]")._toString_()))
    else:
     for _2 in range(0,int((self.__sparsity).shape[0])):
      _0._varname_IS(self.__nativeidxs[_2],mosek.fusion.Utils.StringBuffer()._a_S(self.__name)._a_S("[")._a_J((self.__sparsity[_2] // self.__dim))._a_S(",")._a_J((self.__sparsity[_2] % self.__dim))._a_S("]")._toString_())
    self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_SymRangedVariable._ctor_Lmosek_4fusion_4SymRangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __mirror_1idxs_alt_I_3J_3I(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_SymRangedVariable.__mirror_1idxs_I_3J_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mirror_1idxs_I_3J_3I(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_1 is None): # src/fusion/SymRangedVariable.mbi:60:12-22
    _3=numpy.zeros(((_0 * _0),), dtype=numpy.dtype(numpy.int64))
    _4=0
    _4 = fragments._c_closure_196(_0,_2,_4,_3) # src/fusion/SymRangedVariable.mbi:63:10-72:11
    _4 = numpy.int32(_4) # postprocess
    return (_3)
   else:
    _5=0
    _5 = fragments._c_closure_197(_0,_5,_1) # src/fusion/SymRangedVariable.mbi:77:10-80:11
    _5 = numpy.int32(_5) # postprocess
    _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _7=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_198(_0,_2,_7,_6,_1) # src/fusion/SymRangedVariable.mbi:84:10-99:11
    _8=numpy.array([_9 for _9 in range(0,_5)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_8,_6,None,0,_5)
    return (numpy.array([_7[_8[_10]] for _10 in range(0,_5)], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def __mirror_1sp_alt_I_3J(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_SymRangedVariable.__mirror_1sp_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mirror_1sp_I_3J(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (_1 is None): # src/fusion/SymRangedVariable.mbi:30:12-22
    return (None)
   else:
    _2=0
    _2 = fragments._c_closure_199(_0,_2,_1) # src/fusion/SymRangedVariable.mbi:34:10-37:11
    _2 = numpy.int32(_2) # postprocess
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_200(_0,_3,_1) # src/fusion/SymRangedVariable.mbi:40:10-52:11
    _4=numpy.array([_5 for _5 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_4,_3,None,0,_2)
    return (numpy.array([_3[_4[_6]] for _6 in range(0,_2)], dtype=numpy.dtype(numpy.int64)))
 return SymRangedVariable
mosek_fusion_SymRangedVariable=__mk_mosek_fusion_SymRangedVariable()
del __mk_mosek_fusion_SymRangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_RangedVariable():
 class RangedVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_RangedVariable__shape','_RangedVariable__name','_RangedVariable__names_flushed','_RangedVariable__nativeidxs','_RangedVariable__sparsity']
  def upperBoundVar(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_upperBoundVar_(*args): # 
      return self._upperBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_upperBoundVar_(*args): # 
      return self._upperBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.upperBoundVar()')
  def lowerBoundVar(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_lowerBoundVar_(*args): # 
      return self._lowerBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_lowerBoundVar_(*args): # 
      return self._lowerBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.lowerBoundVar()')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RangedVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.RangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__name = (v.__name)
   self.__nativeidxs = (v.__nativeidxs)
   self.__sparsity = (v.__sparsity)
   self.__names_flushed = (v.__names_flushed)
   self.__shape = (v.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,numpy.int64(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,mosek.fusion.RangedVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__name) = name
   (self.__shape) = shape
   self.__names_flushed = False
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   _1._a_S(" : in range")
   return (_1)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self._getModel_()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/RangedVariable.mbi:101:12-47
    _1=mosek.fusion.Utils.StringBuffer()
    _1._a_S(self.__name)._a_S("[")
    if (self._getND_() > 0): # src/fusion/RangedVariable.mbi:105:14-25
     _1._a_S("%0")
     for _2 in range(1,self._getND_()):
      _1._a_S(",%")._a_I(_2)
    _1._a_S("]")
    _0._varnames__3IS_3I_3J(self.__nativeidxs,_1._toString_(),self._getShape_(),self.__sparsity)
    self.__names_flushed = True
  def _dual_1u_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._dual_1lu_I_3DZ(_0,_1,False)
  def _dual_1l_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_I_3D(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self._dual_1lu_I_3DZ(_0,_1,True)
  @staticmethod
  def _match_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundVar_alt_(self,):
    return self._upperBoundVar_()
  def _upperBoundVar_(self,):
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self._getModel_(),self.__shape,self.__sparsity,numpy.array([self.__nativeidxs[_0] for _0 in range(0,int((self.__nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.int64)),False))
  @staticmethod
  def _match_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundVar_alt_(self,):
    return self._lowerBoundVar_()
  def _lowerBoundVar_(self,):
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self._getModel_(),self.__shape,self.__sparsity,numpy.array([self.__nativeidxs[_0] for _0 in range(0,int((self.__nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.int64)),True))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_RangedVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_201(_0,_1) # src/fusion/RangedVariable.mbi:26:44-98
   return (_1)
 return RangedVariable
mosek_fusion_RangedVariable=__mk_mosek_fusion_RangedVariable()
del __mk_mosek_fusion_RangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDVariable():
 class LinearPSDVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearPSDVariable__shape','_LinearPSDVariable__name','_LinearPSDVariable__varid','_LinearPSDVariable__nativeidxs','_LinearPSDVariable__conedim']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.toString()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    elif mosek_fusion_LinearPSDVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_integer()\n\tmosek.fusion.LinearPSDVariable.make_integer(array(int64,ndim=1))')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_continuous()\n\tmosek.fusion.LinearPSDVariable.make_continuous(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.LinearPSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   (self.__conedim) = (v.__conedim)
   (self.__varid) = (v.__varid)
   (self.__name) = (v.__name)
   (self.__shape) = (v.__shape)
   (self.__nativeidxs) = (v.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,varid,shape,conedim,nativeidxs):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,varid,shape,conedim,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3II_3J(*args):
    if len(args) != 6: return False
    model,name,varid,shape,conedim,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match_I__(conedim) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3II_3J(*args):
    if len(args) != 6: return False
    model,name,varid,shape,conedim,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3II_3J(self,model,name,varid,shape,conedim,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(self,model,name,varid,shape,conedim,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.LinearPSDVariable.__globalNativeIndexes__3J(nativeidxs))
   (self.__name) = name
   (self.__conedim) = conedim
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self.__name)) > 0): # src/fusion/LinearPSDVariable.monty:64:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3J(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_LinearPSDVariable.__globalNativeIndexes__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3J(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([(- (_0[_1] + 1)) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
 return LinearPSDVariable
mosek_fusion_LinearPSDVariable=__mk_mosek_fusion_LinearPSDVariable()
del __mk_mosek_fusion_LinearPSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_PSDVariable():
 class PSDVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_PSDVariable__conedim2','_PSDVariable__conedim1','_PSDVariable__shape','_PSDVariable__name','_PSDVariable__nativeidxs','_PSDVariable__varid']
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PSDVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.toString()')
  def __repr__(self): return 'mosek.fusion.PSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__varid = (v.__varid)
   self.__nativeidxs = (v.__nativeidxs)
   self.__name = (v.__name)
   self.__shape = (v.__shape)
   self.__conedim1 = (v.__conedim1)
   self.__conedim2 = (v.__conedim2)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3III_3J(model,name,varid,shape,conedim1,conedim2,nativeidxs):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J(model,name,varid,shape,conedim1,conedim2,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3III_3J(*args):
    if len(args) != 7: return False
    model,name,varid,shape,conedim1,conedim2,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match_I__(conedim1) and __arg_match_I__(conedim2) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3III_3J(*args):
    if len(args) != 7: return False
    model,name,varid,shape,conedim1,conedim2,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim1) and __arg_alt_match_I__(conedim2) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3III_3J(self,model,name,varid,shape,conedim1,conedim2,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim1),numpy.int32(conedim2),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J(self,model,name,varid,shape,conedim1,conedim2,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.PSDVariable.__fullnativeidxs__3III_3J(shape,conedim1,conedim2,nativeidxs))
   (self.__varid) = varid
   (self.__nativeidxs) = nativeidxs
   (self.__name) = name
   (self.__shape) = shape
   (self.__conedim1) = conedim1
   (self.__conedim2) = conedim2
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self.__name)) > 0): # src/fusion/SemidefiniteVariable.mbi:110:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   _1._a_S(" : element in positive semidefinite cone")
   return (_1)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __fullnativeidxs_alt__3III_3J(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_PSDVariable.__fullnativeidxs__3III_3J(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __fullnativeidxs__3III_3J(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=int((_0).shape[0])
   _5=(_1 < _2)
   _6=(_1 if (_5 ) else _2)
   _7=(_1 if ((not _5) ) else _2)
   _8=1
   _8 = fragments._c_closure_202(_6,_8,_0) # src/fusion/SemidefiniteVariable.mbi:25:20-56
   _8 = numpy.int32(_8) # postprocess
   _9=_0[_6]
   _10=1
   _10 = fragments._c_closure_203(_6,_7,_10,_0) # src/fusion/SemidefiniteVariable.mbi:27:20-60
   _10 = numpy.int32(_10) # postprocess
   _11=_0[_7]
   _12=1
   _12 = fragments._c_closure_204(_7,_12,_4,_0) # src/fusion/SemidefiniteVariable.mbi:29:20-59
   _12 = numpy.int32(_12) # postprocess
   _13=((((_8 * _9) * _10) * _11) * _12)
   _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
   _15=_12
   _16=(_15 * _11)
   _17=(_16 * _10)
   _18=(_17 * _17)
   fragments._c_closure_205(_8,_9,_10,_11,_12,_3,_14,_18,_17,_16,_15) # src/fusion/SemidefiniteVariable.mbi:39:8-52:9
   return (_14)
 return PSDVariable
mosek_fusion_PSDVariable=__mk_mosek_fusion_PSDVariable()
del __mk_mosek_fusion_PSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_SymLinearVariable():
 class SymLinearVariable(mosek_fusion_SymmetricVariable,mosek_fusion_ModelVariable):
  __slots__ = ['_SymLinearVariable__dim','_SymLinearVariable__sparsity','_SymLinearVariable__nativeidxs','_SymLinearVariable__names_flushed','_SymLinearVariable__name']
  def __repr__(self): return 'mosek.fusion.SymLinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = SymLinearVariable.__new__(SymLinearVariable)
    o._ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymLinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__name = (v.__name)
   self.__sparsity = (v.__sparsity)
   self.__nativeidxs = (v.__nativeidxs)
   self.__dim = (v.__dim)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,varid,dim,sparsity,nativeidxs):
    o = SymLinearVariable.__new__(SymLinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,varid,dim,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,dim,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match_I__(dim) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJI_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,dim,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match_I__(dim) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJI_3J_3I(self,model,name,varid,dim,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(model,name,numpy.int64(varid),numpy.int32(dim),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJI_3J_3I(self,model,name,varid,dim,sparsity,nativeidxs):
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,numpy.array([dim,dim], dtype=numpy.dtype(numpy.int32)),varid,mosek.fusion.SymLinearVariable.__mirror_1sp_I_3J(dim,sparsity),mosek.fusion.SymLinearVariable.__mirror_1idxs_I_3J_3I(dim,sparsity,nativeidxs))
   self.__names_flushed = False
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__dim) = dim
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self._getModel_()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/SymLinearVariable.monty:144:12-47
    if (self.__sparsity is None): # src/fusion/SymLinearVariable.monty:146:14-30
     for _1 in range(0,int((self.__nativeidxs).shape[0])):
      _0._varname_IS(self.__nativeidxs[_1],("" if ((int(len(self.__name))==0) ) else mosek.fusion.Utils.StringBuffer()._a_S(self.__name)._a_S("[")._a_I((_1 // self.__dim))._a_S(",")._a_I((_1 % self.__dim))._a_S("]")._toString_()))
    else:
     for _2 in range(0,int((self.__sparsity).shape[0])):
      _0._varname_IS(self.__nativeidxs[_2],mosek.fusion.Utils.StringBuffer()._a_S(self.__name)._a_S("[")._a_J((self.__sparsity[_2] // self.__dim))._a_S(",")._a_J((self.__sparsity[_2] % self.__dim))._a_S("]")._toString_())
    self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_SymLinearVariable._ctor_Lmosek_4fusion_4SymLinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __mirror_1idxs_alt_I_3J_3I(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_SymLinearVariable.__mirror_1idxs_I_3J_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mirror_1idxs_I_3J_3I(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_1 is None): # src/fusion/SymLinearVariable.monty:63:12-22
    _3=numpy.zeros(((_0 * _0),), dtype=numpy.dtype(numpy.int64))
    _4=0
    _4 = fragments._c_closure_206(_0,_2,_4,_3) # src/fusion/SymLinearVariable.monty:66:10-75:11
    _4 = numpy.int32(_4) # postprocess
    return (_3)
   else:
    _5=0
    _5 = fragments._c_closure_207(_0,_5,_1) # src/fusion/SymLinearVariable.monty:80:10-83:11
    _5 = numpy.int32(_5) # postprocess
    _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _7=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_208(_0,_2,_7,_6,_1) # src/fusion/SymLinearVariable.monty:87:10-102:11
    _8=numpy.array([_9 for _9 in range(0,_5)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_8,_6,None,0,_5)
    return (numpy.array([_7[_8[_10]] for _10 in range(0,_5)], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def __mirror_1sp_alt_I_3J(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_SymLinearVariable.__mirror_1sp_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mirror_1sp_I_3J(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (_1 is None): # src/fusion/SymLinearVariable.monty:33:12-22
    return (None)
   else:
    _2=0
    _2 = fragments._c_closure_209(_0,_2,_1) # src/fusion/SymLinearVariable.monty:37:10-40:11
    _2 = numpy.int32(_2) # postprocess
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_210(_0,_3,_1) # src/fusion/SymLinearVariable.monty:43:10-55:11
    _4=numpy.array([_5 for _5 in range(0,_2)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_4,_3,None,0,_2)
    return (numpy.array([_3[_4[_6]] for _6 in range(0,_2)], dtype=numpy.dtype(numpy.int64)))
 return SymLinearVariable
mosek_fusion_SymLinearVariable=__mk_mosek_fusion_SymLinearVariable()
del __mk_mosek_fusion_SymLinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearVariable():
 class LinearVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearVariable__shape','_LinearVariable__sparsity','_LinearVariable__nativeidxs','_LinearVariable__names_flushed','_LinearVariable__name']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.toString()')
  def __repr__(self): return 'mosek.fusion.LinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__nativeidxs = (v.__nativeidxs)
   self.__sparsity = (v.__sparsity)
   self.__shape = (v.__shape)
   self.__name = (v.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,numpy.int64(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,mosek.fusion.LinearVariable.__globalNativeIndexes__3I(nativeidxs))
   self.__names_flushed = False
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__shape) = shape
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("LinearVariable((")
   if (int((self.__shape).shape[0]) > 0): # src/fusion/LinearVariable.mbi:96:12-26
    _0._a_I(self.__shape[0])
    for _1 in range(1,int((self.__shape).shape[0])):
     _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   if (self.__sparsity is not None): # src/fusion/LinearVariable.mbi:101:12-28
    _0._a_S(",sparse")
   _0._a_S(")")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self._getModel_()
   if (self._getSize_()==0): # src/fusion/LinearVariable.mbi:70:12-26
    self.__names_flushed = True
   else:
    if (int(len(self.__name))==0): # src/fusion/LinearVariable.mbi:72:17-31
     self.__names_flushed = True
   if (not self.__names_flushed): # src/fusion/LinearVariable.mbi:74:12-29
    _1=mosek.fusion.Utils.StringBuffer()
    _1._a_S(self.__name)._a_S("[")
    if (self._getND_() > 0): # src/fusion/LinearVariable.mbi:78:14-25
     _1._a_S("%0")
     for _2 in range(1,self._getND_()):
      _1._a_S(",%")._a_I(_2)
    _1._a_S("]")
    _0._varnames__3IS_3I_3J(self.__nativeidxs,_1._toString_(),(self._getShape_() if ((self._getND_() > 0) ) else numpy.array([1], dtype=numpy.dtype(numpy.int32))),self.__sparsity)
    self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_LinearVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_211(_0,_1) # src/fusion/LinearVariable.mbi:31:44-98
   return (_1)
 return LinearVariable
mosek_fusion_LinearVariable=__mk_mosek_fusion_LinearVariable()
del __mk_mosek_fusion_LinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_ConicVariable():
 class ConicVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_ConicVariable__nativeidxs','_ConicVariable__shape','_ConicVariable__name','_ConicVariable__names_flushed','_ConicVariable__varid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.toString()')
  def __repr__(self): return 'mosek.fusion.ConicVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__shape = (v.__shape)
   self.__nativeidxs = (v.__nativeidxs)
   self.__shape = (v.__shape)
   self.__varid = (v.__varid)
   self.__name = (v.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,varid,shape,nativeidxs):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,varid,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,varid,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,varid,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,varid,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,varid,shape,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.ConicVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__name) = name
   (self.__names_flushed) = False
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("ConicVariable( ")
   if (int(len(self.__name)) > 0): # src/fusion/ConicVariable.mbi:95:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_S("(")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(") )")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self._getModel_()
   if (self._getSize_()==0): # src/fusion/ConicVariable.mbi:73:12-26
    self.__names_flushed = True
   else:
    if (int(len(self.__name))==0): # src/fusion/ConicVariable.mbi:75:17-31
     self.__names_flushed = True
   if (not self.__names_flushed): # src/fusion/ConicVariable.mbi:77:12-29
    _1=mosek.fusion.Utils.StringBuffer()
    _1._a_S(self.__name)._a_S("[")
    _1._a_S("%0")
    for _2 in range(1,self._getND_()):
     _1._a_S(",%")._a_I(_2)
    _1._a_S("]")
    _0._varnames__3IS_3I_3J(self.__nativeidxs,_1._toString_(),(self._getShape_() if ((self._getND_() > 0) ) else numpy.array([0], dtype=numpy.dtype(numpy.int32))),None)
    self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ConicVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_212(_0,_1) # src/fusion/ConicVariable.mbi:34:44-98
   return (_1)
 return ConicVariable
mosek_fusion_ConicVariable=__mk_mosek_fusion_ConicVariable()
del __mk_mosek_fusion_ConicVariable
#BEFORE CLASS
def __mk_mosek_fusion_NilVariable():
 class NilVariable(mosek_fusion_SymmetricVariable,mosek_fusion_BaseVariable):
  __slots__ = ['_NilVariable__shape']
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_continuous()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.set_values(array(double,ndim=1),bool)')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_integer()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_NilVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.toString()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_NilVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_NilVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_NilVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_NilVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_NilVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_NilVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_NilVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.index(int32)\n\tmosek.fusion.NilVariable.index(array(int32,ndim=1))\n\tmosek.fusion.NilVariable.index(int32,int32)\n\tmosek.fusion.NilVariable.index(int32,int32,int32)')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_NilVariable._match_inst_I_3J_3J(*args): # int32,[]int64,[]int64
      return self._inst_I_3J_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3J_3J(*args): # int32,[]int64,[]int64
      return self._inst_alt_I_3J_3J(*args)
    elif mosek_fusion_NilVariable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.values(int32,array(double,ndim=1),bool)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_NilVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_NilVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.slice(int32,int32)\n\tmosek.fusion.NilVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_NilVariable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.numInst()')
  def __repr__(self): return 'mosek.fusion.NilVariable'
  @staticmethod
  def _ctor__3I(shape):
    o = NilVariable.__new__(NilVariable)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   assert shape is None or isinstance(shape,numpy.ndarray)
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,None,mosek.fusion.Utils.Tools._arraycopy__3I(shape),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)))
   (self.__shape) = numpy.array([shape[_0] for _0 in range(0,int((shape).shape[0]))], dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_():
    o = NilVariable.__new__(NilVariable)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_NilVariable._ctor_init__3I(self,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   return numpy.int32(0)
  @staticmethod
  def _match_inst_I_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_inst_I_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2))
  def _inst_alt_I_3J_3J(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J_3J(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return numpy.int32(0)
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   pass
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   pass
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("NilVariable")
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([1 for _1 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([1 for _1 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int((self.__shape).shape[0])!=int((_0).shape[0])) or (int((self.__shape).shape[0])!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:1030:12-63
    raise mosek_fusion_DimensionError._ctor_S("Mismatching slice shape")
   for _2 in range(0,int((_0).shape[0])):
    if ((_1[_2] > _0[_2]) or ((_0[_2] < 0) or (_1[_2] >= self.__shape[_2]))): # src/fusion/BaseVariable.monty:1033:14-71
     raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([(_1[_3] - _0[_3]) for _3 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((_1 > _0) or ((_0 < 0) or (_1 > self.__shape[0]))): # src/fusion/BaseVariable.monty:1018:12-56
    raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   elif (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:1020:16-31
    raise mosek_fusion_DimensionError._ctor_S("Mismatching slice shape")
   else:
    return (mosek_fusion_NilVariable._ctor__3I(numpy.array([(_1 - _0)], dtype=numpy.dtype(numpy.int32))))
 return NilVariable
mosek_fusion_NilVariable=__mk_mosek_fusion_NilVariable()
del __mk_mosek_fusion_NilVariable
#BEFORE CLASS
def __mk_mosek_fusion_Var():
 class Var(object):
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Var._match_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack_alt__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.stack(array(array(mosek.fusion.Variable,ndim=1),ndim=1))\n\tmosek.fusion.Var.stack(array(mosek.fusion.Variable,ndim=1),int32)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32)')
  @staticmethod
  def hrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list hrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Var._match_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.flatten(mosek.fusion.Variable)')
  @staticmethod
  def vrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list vrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,array(int32,ndim=1))\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def promote(*args):
    if False: pass
    elif mosek_fusion_Var._match_promote_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._promote_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_promote_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._promote_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list promote('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.promote(mosek.fusion.Variable,int32)')
  @staticmethod
  def compress(*args):
    if False: pass
    elif mosek_fusion_Var._match_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list compress('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.compress(mosek.fusion.Variable)')
  @staticmethod
  def empty(*args):
    if False: pass
    elif mosek_fusion_Var._match_empty__3I(*args): # []int32
      return mosek_fusion_Var._empty__3I(*args)
    elif mosek_fusion_Var._match_alt_empty__3I(*args): # []int32
      return mosek_fusion_Var._empty_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list empty('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.empty(array(int32,ndim=1))')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32,int32)')
  def __repr__(self): return 'mosek.fusion.Var'
  @staticmethod
  def _match_empty__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_empty__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _empty_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._empty__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _empty__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] < 0): # src/fusion/Var.monty:807:14-26
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape")
   return (mosek_fusion_NilVariable._ctor__3I(_0))
  @staticmethod
  def _match_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _compress_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _compress_Lmosek_4fusion_4Variable_2(_0):
   _1=_0._getShape_()
   _2=int((_1).shape[0])
   _3=0
   _3 = fragments._c_closure_213(_2,_3,_1) # src/fusion/Var.monty:784:8-785:38
   _3 = numpy.int32(_3) # postprocess
   _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_214(_2,_4,_1) # src/fusion/Var.monty:787:8-794:9
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,_4))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Variable_2(_0):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([numpy.int32(mosek.fusion.Set._size__3I(_0._getShape_()))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0._reshape__3I(_1))
  @staticmethod
  def _index_1permute_1_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _4=_0._getShape_()
   _5=int((_4).shape[0])
   _6=1
   _6 = fragments._c_closure_215(_5,_4,_6) # src/fusion/Var.monty:621:27-69
   _6 = numpy.int32(_6) # postprocess
   _7=_0._numInst_()
   _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
   _8[(_5 - 1)] = 1
   fragments._c_closure_216(_5,_1,_8,_4) # src/fusion/Var.monty:624:57-131
   if (_7 < _6): # src/fusion/Var.monty:626:12-27
    _2 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _3 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _0._inst_I_3JI_3J(0,_2,0,_3)
   else:
    _2 = None
    _3 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _0._inst_I_3J(0,_3)
   if (_2 is None): # src/fusion/Var.monty:637:12-28
    _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_217(_3,_5,_7,_1,_8,_9,_4) # src/fusion/Var.monty:639:10-646:11
    _3 = _9
   else:
    _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_218(_5,_7,_1,_8,_10,_4) # src/fusion/Var.monty:651:10-658:11
    _11=numpy.array([_12 for _12 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_11,_10,None,0,_7)
    _2 = numpy.array([_2[_11[_13]] for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    _3 = numpy.array([_3[_11[_14]] for _14 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_0._getModel_(),numpy.array([_4[_1[_15]] for _15 in range(0,_5)], dtype=numpy.dtype(numpy.int32)),_2,_3))
  @staticmethod
  def _match_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _hrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _hrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,1,_1))
  @staticmethod
  def _match_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _vrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _vrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def __drepeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if (_2 < 0): # src/fusion/Var.monty:474:12-17
    raise mosek_fusion_LengthError._ctor_S("Cannot repeat less than 0 times")
   elif (_2==0): # src/fusion/Var.monty:476:16-22
    return (mosek_fusion_NilVariable._ctor_())
   elif (_2==1): # src/fusion/Var.monty:478:16-22
    return (_0)
   else:
    _3=_0._getModel_()
    _4=_0._getShape_()
    _5=int((_4).shape[0])
    if ((_1 < 0) or (_1 > _5)): # src/fusion/Var.monty:485:14-33
     raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
    _6=mosek.fusion.Set._size__3I(_4)
    _7=_0._numInst_()
    _8=(_7 * _2)
    _9=1
    _9 = fragments._c_closure_219(_9,_1,_4) # src/fusion/Var.monty:491:22-58
    _9 = numpy.int32(_9) # postprocess
    _10=(_4[_1] if ((_1 < _5) ) else 1)
    _11=(_10 * _2)
    _12=1
    _12 = fragments._c_closure_220(_12,_1,_5,_4) # src/fusion/Var.monty:494:22-61
    _12 = numpy.int32(_12) # postprocess
    _13=(_5 if ((_1 < _5) ) else (_1 + 1))
    _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_221(_5,_14,_4) # src/fusion/Var.monty:498:10-51
    fragments._c_closure_222(_5,_13,_14) # src/fusion/Var.monty:499:10-46
    _14[_1] = _11
    if (_7 < _6): # src/fusion/Var.monty:502:14-27
     _15=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _16=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _17=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     _18=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     _0._inst_I_3JI_3J(0,_16,0,_15)
     _19=(_11 * _12)
     _20=(_10 * _12)
     _21=_12
     if (_1==0): # src/fusion/Var.monty:515:18-26
      _22=0
      _22 = fragments._c_closure_223(_6,_22,_2,_7,_17,_18,_15,_16) # src/fusion/Var.monty:517:16-522:19
      _22 = numpy.int32(_22) # postprocess
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_14,_18,_17))
     elif (_1 >= _5): # src/fusion/Var.monty:525:22-31
      _23=0
      _23 = fragments._c_closure_224(_23,_2,_7,_17,_18,_15,_16) # src/fusion/Var.monty:527:16-532:19
      _23 = numpy.int32(_23) # postprocess
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_14,_18,_17))
     else:
      _24=0
      _24 = fragments._c_closure_225(_10,_12,_24,_2,_7,_19,_17,_18,_20,_21,_15,_16) # src/fusion/Var.monty:538:16-548:17
      _24 = numpy.int32(_24) # postprocess
      _25=1
      _25 = fragments._c_closure_226(_25,_13,_14) # src/fusion/Var.monty:551:32-96
      _25 = numpy.int32(_25) # postprocess
      _26=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
      _27=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
      _28=numpy.zeros(((_25 + 1),), dtype=numpy.dtype(numpy.int32))
      _29=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
      _29[(_13 - 1)] = 1
      fragments._c_closure_227(_13,_14,_29) # src/fusion/Var.monty:557:55-114
      fragments._c_closure_228(_26,_8) # src/fusion/Var.monty:558:18-55
      for _30 in range(0,_13):
       _31=((_13 - _30) - 1)
       fragments._c_closure_229(_31,_28,_14) # src/fusion/Var.monty:562:20-60
       fragments._c_closure_230(_31,_28,_8,_14,_18,_29) # src/fusion/Var.monty:563:20-79
       fragments._c_closure_231(_31,_28,_14) # src/fusion/Var.monty:564:20-66
       fragments._c_closure_232(_26,_31,_28,_8,_14,_18,_29,_27) # src/fusion/Var.monty:565:20-570:21
       _32=_26
       _26 = _27
       _27 = _32
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_14,numpy.array([_18[_26[_33]] for _33 in range(0,_8)], dtype=numpy.dtype(numpy.int64)),numpy.array([_17[_26[_34]] for _34 in range(0,_8)], dtype=numpy.dtype(numpy.int64))))
    else:
     _35=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _36=numpy.zeros(((_7 * _2),), dtype=numpy.dtype(numpy.int64))
     _0._inst_I_3J(0,_35)
     _37=(_11 * _12)
     _38=_12
     _39=0
     _39 = fragments._c_closure_233(_9,_10,_12,_39,_2,_36,_37,_38,_35) # src/fusion/Var.monty:592:12-598:17
     _39 = numpy.int32(_39) # postprocess
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_14,None,_36))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0[_1],1) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,1))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,numpy.int32(__3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,_3):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,numpy.int32(__2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=_1
   for _3 in range(0,int((_0).shape[0])):
    if (_2 < _0[_3]._getND_()): # src/fusion/Var.monty:289:53-73
     _2 = _0[_3]._getND_()
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1))
  @staticmethod
  def _match_promote_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_promote_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _promote_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._promote_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _promote_Lmosek_4fusion_4Variable_2I(_0,_1):
   if (_1 > _0._getND_()): # src/fusion/Var.monty:276:12-26
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _3=_0._getShape_()
    fragments._c_closure_234(_3,_2) # src/fusion/Var.monty:279:10-52
    fragments._c_closure_235(_1,_3,_2) # src/fusion/Var.monty:280:10-49
    return (_0._reshape__3I(_2))
   else:
    return (_0)
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1 < 0): # src/fusion/Var.monty:155:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
   _2=None
   for _3 in range(0,int((_0).shape[0])):
    if (_2 is None): # src/fusion/Var.monty:161:16-26
     _2 = _0[_3]._getModel_()
    elif ((_0[_3]._getModel_() is not None) and (_0[_3]._getModel_() is not _2)): # src/fusion/Var.monty:162:20-69
     _4=mosek.fusion.Utils.StringBuffer()
     _5=(_2._getName_() if ((int(len(_2._getName_())) > 0) ) else "?")
     _6=(_0[_3]._getModel_()._getName_() if ((int(len(_0[_3]._getModel_()._getName_())) > 0) ) else "?")
     _4._a_S("Variables belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   if (int((_0).shape[0])==0): # src/fusion/Var.monty:173:12-23
    return (mosek_fusion_NilVariable._ctor_())
   elif (int((_0).shape[0])==1): # src/fusion/Var.monty:174:16-27
    return (_0[0])
   else:
    _7=int((_0).shape[0])
    _8=numpy.array([_0[_9]._numInst_() for _9 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _10=_monty.initJaggedArray([_0[_11]._getShape_() for _11 in range(0,_7)], 1)
    _12=numpy.array([int((_10[_13]).shape[0]) for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _14=_10[0]
    _15=_12[0]
    _16=0
    _16 = fragments._c_closure_236(_7,_8,_16) # src/fusion/Var.monty:182:24-60
    _16 = numpy.int32(_16) # postprocess
    _17=(_1 + 1)
    _17 = fragments._c_closure_237(_7,_12,_17) # src/fusion/Var.monty:184:27-77
    _17 = numpy.int32(_17) # postprocess
    _18=numpy.zeros((_17,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_238(_15,_18,_14) # src/fusion/Var.monty:186:10-53
    fragments._c_closure_239(_15,_17,_18) # src/fusion/Var.monty:186:54-91
    _18[_1] = 0
    fragments._c_closure_240(_1,_7,_18,_10) # src/fusion/Var.monty:187:27-109
    for _19 in range(0,_7):
     for _20 in range(0,int((_10[_19]).shape[0])):
      if ((_20!=_1) and (_10[_19][_20]!=_18[_20])): # src/fusion/Var.monty:191:18-56
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
     for _21 in range(int((_10[_19]).shape[0]),_17):
      if ((_21!=_1) and (1!=_18[_21])): # src/fusion/Var.monty:194:18-45
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
    _22=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    _24=numpy.array([(_10[_25][_1] if ((_1 < int((_10[_25]).shape[0])) ) else 1) for _25 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _26=1
    _26 = fragments._c_closure_241(_26,_1,_14) # src/fusion/Var.monty:202:22-88
    _26 = numpy.int32(_26) # postprocess
    _27=0
    _27 = fragments._c_closure_242(_27,_7,_24) # src/fusion/Var.monty:203:22-56
    _27 = numpy.int32(_27) # postprocess
    _28=1
    _28 = fragments._c_closure_243(_28,_1,_14) # src/fusion/Var.monty:204:22-71
    _28 = numpy.int32(_28) # postprocess
    if (_26==1): # src/fusion/Var.monty:206:14-21
     _29=0
     _30=0
     for _31 in range(0,_7):
      _0[_31]._inst_I_3JI_3J(_29,_23,_29,_22)
      _29 = fragments._c_closure_244(_31,_29,_30,_8,_23) # src/fusion/Var.monty:210:14-213:15
      _29 = numpy.int32(_29) # postprocess
      _30 += mosek.fusion.Set._size__3I(_10[_31])
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_2,_18,(_23 if ((_16 < ((_26 * _27) * _28)) ) else None),_22))
    else:
     _32=0
     for _33 in range(0,_7):
      _32 += _0[_33]._inst_I_3JI_3J(_32,_23,_32,_22)
     _34=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
     _35=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
     _36=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_245(_7,_36,_24) # src/fusion/Var.monty:226:38-92
     fragments._c_closure_246(_34,_16) # src/fusion/Var.monty:228:12-49
     _37=0
     _37 = fragments._c_closure_247(_27,_28,_37,_7,_8,_36,_23,_24) # src/fusion/Var.monty:231:12-241:13
     _37 = numpy.int32(_37) # postprocess
     _38=1
     _38 = fragments._c_closure_248(_38,_17,_18) # src/fusion/Var.monty:243:28-104
     _38 = numpy.int32(_38) # postprocess
     _39=numpy.zeros((_17,), dtype=numpy.dtype(numpy.int64))
     _39[(_17 - 1)] = 1
     fragments._c_closure_249(_17,_18,_39) # src/fusion/Var.monty:244:49-106
     _40=numpy.zeros(((_38 + 1),), dtype=numpy.dtype(numpy.int32))
     for _41 in range(0,_17):
      _42=((_17 - _41) - 1)
      fragments._c_closure_250(_42,_40,_18) # src/fusion/Var.monty:249:14-54
      fragments._c_closure_251(_42,_40,_16,_18,_23,_39) # src/fusion/Var.monty:250:14-69
      fragments._c_closure_252(_42,_40,_18) # src/fusion/Var.monty:251:14-60
      fragments._c_closure_253(_34,_42,_40,_16,_18,_23,_39,_35) # src/fusion/Var.monty:252:14-257:15
      _43=_34
      _34 = _35
      _35 = _43
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_2,_18,(numpy.array([_23[_34[_44]] for _44 in range(0,_16)], dtype=numpy.dtype(numpy.int64)) if ((_16 < ((_26 * _27) * _28)) ) else None),numpy.array([_22[_34[_45]] for _45 in range(0,_16)], dtype=numpy.dtype(numpy.int64))))
 return Var
mosek_fusion_Var=__mk_mosek_fusion_Var()
del __mk_mosek_fusion_Var
#BEFORE CLASS
def __mk_mosek_fusion_ConstraintCache():
 class ConstraintCache(object):
  __slots__ = ['barmatidx','barsubj','barsubi','nbarnz','nunordered','buffer_subi','buffer_subj','buffer_cof','bfix','cof','subi','subj','nnz','nrows']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3D_3I_3D_3I_3I_3I(*args): # []int64,[]double,[]int32,[]double,[]int32,[]int32,[]int32
      self._ctor_init__3J_3D_3I_3D_3I_3I_3I(*args)
    elif self.__match_alt_ctor__3J_3D_3I_3D_3I_3I_3I(*args):# []int64,[]double,[]int32,[]double,[]int32,[]int32,[]int32
      self._ctor_alt_init__3J_3D_3I_3D_3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ConstraintCache.ctor(array(int64,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_add__3J_3I_3D_3D(*args): # []int64,[]int32,[]double,[]double
      return self._add__3J_3I_3D_3D(*args)
    elif mosek_fusion_ConstraintCache._match_alt_add__3J_3I_3D_3D(*args): # []int64,[]int32,[]double,[]double
      return self._add_alt__3J_3I_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.add(array(int64,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def numUnsorted(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_numUnsorted_(*args): # 
      return self._numUnsorted_(*args)
    elif mosek_fusion_ConstraintCache._match_alt_numUnsorted_(*args): # 
      return self._numUnsorted_alt_(*args)
    else:
      raise ValueError('Invalid argument list numUnsorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.numUnsorted()')
  def flush(self,*args):
    if False: pass
    elif mosek_fusion_ConstraintCache._match_flush__3I_3I_3D_3D(*args): # []int32,[]int32,[]double,[]double
      return self._flush__3I_3I_3D_3D(*args)
    elif mosek_fusion_ConstraintCache._match_alt_flush__3I_3I_3D_3D(*args): # []int32,[]int32,[]double,[]double
      return self._flush_alt__3I_3I_3D_3D(*args)
    else:
      raise ValueError('Invalid argument list flush('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConstraintCache.flush(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ConstraintCache'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConstraintCache_2(cc):
    o = ConstraintCache.__new__(ConstraintCache)
    o._ctor_init_Lmosek_4fusion_4ConstraintCache_2(cc)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConstraintCache_2(*args):
    if len(args) != 1: return False
    cc, = args
    return (__arg_match_Lmosek_4fusion_4ConstraintCache_2__(cc))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConstraintCache_2(*args):
    if len(args) != 1: return False
    cc, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConstraintCache_2__(cc))
  def _ctor_alt_init_Lmosek_4fusion_4ConstraintCache_2(self,cc):
    self._ctor_init_Lmosek_4fusion_4ConstraintCache_2(cc)
  def _ctor_init_Lmosek_4fusion_4ConstraintCache_2(self,cc):
   self.nrows = (cc.nrows)
   self.nnz = (cc.nnz)
   self.subj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.subj)) if (((cc.subj) is not None) ) else None)
   self.subi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.subi)) if (((cc.subi) is not None) ) else None)
   self.cof = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.cof)) if (((cc.cof) is not None) ) else None)
   self.bfix = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.bfix)) if (((cc.bfix) is not None) ) else None)
   self.buffer_cof = (mosek.fusion.Utils.Tools._arraycopy__3D((cc.buffer_cof)) if (((cc.buffer_cof) is not None) ) else None)
   self.buffer_subj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.buffer_subj)) if (((cc.buffer_subj) is not None) ) else None)
   self.buffer_subi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.buffer_subi)) if (((cc.buffer_subi) is not None) ) else None)
   self.nunordered = (cc.nunordered)
   self.nbarnz = (cc.nbarnz)
   self.barsubi = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barsubi)) if (((cc.barsubi) is not None) ) else None)
   self.barsubj = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barsubj)) if (((cc.barsubj) is not None) ) else None)
   self.barmatidx = (mosek.fusion.Utils.Tools._arraycopy__3I((cc.barmatidx)) if (((cc.barmatidx) is not None) ) else None)
  @staticmethod
  def _ctor__3J_3D_3I_3D_3I_3I_3I(ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
    o = ConstraintCache.__new__(ConstraintCache)
    o._ctor_init__3J_3D_3I_3D_3I_3I_3I(ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_)
    return o
  @staticmethod
  def __match_ctor__3J_3D_3I_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_, = args
    return (__arg_match__3J__(ptrb_) and __arg_match__3D__(cof_) and __arg_match__3I__(subj_) and __arg_match__3D__(bfix_) and __arg_match__3I__(barsubi_) and __arg_match__3I__(barsubj_) and __arg_match__3I__(barmatidx_))
  @staticmethod
  def __match_alt_ctor__3J_3D_3I_3D_3I_3I_3I(*args):
    if len(args) != 7: return False
    ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_, = args
    return (__arg_alt_match__3J__(ptrb_) and __arg_alt_match__3D__(cof_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(bfix_) and __arg_alt_match__3I__(barsubi_) and __arg_alt_match__3I__(barsubj_) and __arg_alt_match__3I__(barmatidx_))
  def _ctor_alt_init__3J_3D_3I_3D_3I_3I_3I(self,ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
    self._ctor_init__3J_3D_3I_3D_3I_3I_3I(numpy.array(ptrb_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(bfix_,dtype=numpy.dtype(numpy.float64)),numpy.array(barsubi_,dtype=numpy.dtype(numpy.int32)),numpy.array(barsubj_,dtype=numpy.dtype(numpy.int32)),numpy.array(barmatidx_,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3J_3D_3I_3D_3I_3I_3I(self,ptrb_,cof_,subj_,bfix_,barsubi_,barsubj_,barmatidx_):
   assert ptrb_ is None or isinstance(ptrb_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert bfix_ is None or isinstance(bfix_,numpy.ndarray)
   assert barsubi_ is None or isinstance(barsubi_,numpy.ndarray)
   assert barsubj_ is None or isinstance(barsubj_,numpy.ndarray)
   assert barmatidx_ is None or isinstance(barmatidx_,numpy.ndarray)
   self.nrows = (int((ptrb_).shape[0]) - 1)
   self.nnz = ptrb_[(int((ptrb_).shape[0]) - 1)]
   self.subj = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.int32))
   self.subi = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.int32))
   self.cof = numpy.zeros((self.nnz,), dtype=numpy.dtype(numpy.float64))
   if (bfix_ is not None): # src/fusion/ConstraintCache.mbi:73:12-25
    self.bfix = bfix_
   else:
    self.bfix = numpy.zeros((self.nrows,), dtype=numpy.dtype(numpy.float64))
   if ((barsubi_ is not None) and ((barsubj_ is not None) and (barmatidx_ is not None))): # src/fusion/ConstraintCache.mbi:76:13-78:31
    self.nbarnz = int((barsubi_).shape[0])
    if (self.nbarnz > int((barsubj_).shape[0])): # src/fusion/ConstraintCache.mbi:81:14-36
     self.nbarnz = int((barsubj_).shape[0])
    if (self.nbarnz > int((barmatidx_).shape[0])): # src/fusion/ConstraintCache.mbi:82:14-38
     self.nbarnz = int((barmatidx_).shape[0])
    self.barsubi = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    self.barsubj = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    self.barmatidx = numpy.zeros((self.nbarnz,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barsubi_,0,self.barsubi,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barsubj_,0,self.barsubj,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(barmatidx_,0,self.barmatidx,0,self.nbarnz)
   else:
    self.nbarnz = 0
    self.barsubi = None
    self.barsubj = None
    self.barmatidx = None
   mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(subj_,0,self.subj,0,self.nnz)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(cof_,0,self.cof,0,self.nnz)
   fragments._c_closure_254(self.nrows,ptrb_,self.subi) # src/fusion/ConstraintCache.mbi:102:8-104:24
   self.buffer_cof = None
   self.buffer_subj = None
   self.buffer_subi = None
   self.nunordered = 0
  def _unchecked_1add_1fx_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._unchecked_1add_1fx__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _unchecked_1add_1fx__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   fragments._c_closure_255(self.bfix,_0,self.nrows) # src/fusion/ConstraintCache.mbi:475:6-478:7
  def _order_1barentries_alt_(self,):
    return self._order_1barentries_()
  def _order_1barentries_(self,):
   _0=numpy.array([_1 for _1 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int64))
   if (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,self.barsubi,self.barsubj,0,self.nbarnz,False)): # src/fusion/ConstraintCache.mbi:458:12-66
    mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,self.barsubi,self.barsubj,0,self.nbarnz,False)
    _2=self.barsubi
    _3=self.barsubj
    _4=self.barmatidx
    self.barsubi = numpy.array([_2[_0[_5]] for _5 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
    self.barsubj = numpy.array([_3[_0[_6]] for _6 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
    self.barmatidx = numpy.array([_4[_0[_7]] for _7 in range(0,self.nbarnz)], dtype=numpy.dtype(numpy.int32))
   return numpy.int64(self.nbarnz)
  def _add_1bar_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._add_1bar__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add_1bar__3I_3I_3I(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (_0 is not None): # src/fusion/ConstraintCache.mbi:424:12-28
    _3=int((_0).shape[0])
    if (int((_0).shape[0]) <= (self.nbarnz + _3)): # src/fusion/ConstraintCache.mbi:427:15-50
     _4=self.barsubi
     _5=self.barsubj
     _6=self.barmatidx
     _7=((2 * self.nbarnz) if (((2 * self.nbarnz) > (self.nbarnz + _3)) ) else (self.nbarnz + (_3 * 2)))
     self.barsubi = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     self.barsubj = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     self.barmatidx = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     if (self.nbarnz > 0): # src/fusion/ConstraintCache.mbi:440:16-26
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_4,0,self.barsubi,0,self.nbarnz)
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_5,0,self.barsubj,0,self.nbarnz)
      mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_6,0,self.barmatidx,0,self.nbarnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_0,0,self.barsubi,self.nbarnz,_3)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_1,0,self.barsubj,self.nbarnz,_3)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_2,0,self.barmatidx,self.nbarnz,_3)
    self.nbarnz += _3
  def _unchecked_1add_1l_alt__3J_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._unchecked_1add_1l__3J_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _unchecked_1add_1l__3J_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=(self.nunordered + _0[self.nrows])
   _5=_0[self.nrows]
   if ((self.buffer_cof is None) or (int((self.buffer_cof).shape[0]) < _4)): # src/fusion/ConstraintCache.mbi:381:13-382:37
    _6 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    _7 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    _8 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
    if (self.buffer_cof is not None): # src/fusion/ConstraintCache.mbi:388:14-32
     mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self.buffer_subi,0,_6,0,self.nunordered)
     mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self.buffer_subj,0,_7,0,self.nunordered)
     mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self.buffer_cof,0,_8,0,self.nunordered)
   else:
    _6 = self.buffer_subi
    _7 = self.buffer_subj
    _8 = self.buffer_cof
   fragments._c_closure_256(self.nrows,self.nunordered,_0,_6) # src/fusion/ConstraintCache.mbi:402:8-404:39
   mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(_1,0,_7,self.nunordered,_5)
   mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_2,0,_8,self.nunordered,_5)
   self.buffer_subi = _6
   self.buffer_subj = _7
   self.buffer_cof = _8
   fragments._c_closure_257(self.bfix,_3,self.nrows) # src/fusion/ConstraintCache.mbi:412:8-414:41
   self.nunordered = _4
  @staticmethod
  def _match_add__3J_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3))
  @staticmethod
  def _match_alt_add__3J_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3))
  def _add_alt__3J_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._add__3J_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _add__3J_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   if ((int((_0).shape[0])!=(self.nrows + 1)) or ((_3 is not None) and (int((_3).shape[0])!=self.nrows))): # src/fusion/ConstraintCache.mbi:353:17-354:56
    raise mosek_fusion_LengthError._ctor_S("Mismatching expression lengths")
   self._unchecked_1add_1l__3J_3I_3D_3D(_0,_1,_2,_3)
  @staticmethod
  def _match_flush__3I_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3))
  @staticmethod
  def _match_alt_flush__3I_3I_3D_3D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3))
  def _flush_alt__3I_3I_3D_3D(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _1 = self._flush__3I_3I_3D_3D(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _flush__3I_3I_3D_3D(self,_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=None
   fragments._c_closure_258(self.bfix,self.nrows,_3) # src/fusion/ConstraintCache.mbi:169:8-171:33
   if (self.nunordered==0): # src/fusion/ConstraintCache.mbi:173:12-28
    return numpy.int64(0)
   _5=False
   _5 = fragments._c_closure_259(self.buffer_subi,self.buffer_subj,_5,self.nunordered) # src/fusion/ConstraintCache.mbi:179:8-183:9
   if (not _5): # src/fusion/ConstraintCache.mbi:185:12-26
    _4 = numpy.array([_6 for _6 in range(0,self.nunordered)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3I_3IJJ(_4,self.buffer_subi,self.buffer_subj,0,self.nunordered)
   _7=self.nnz
   _8=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((self.nunordered + _7),), dtype=numpy.dtype(numpy.float64))
   _11=0
   self.nnz,_11 = fragments._c_closure_260(self.buffer_cof,self.buffer_subi,self.buffer_subj,self.cof,_5,self.nnz,_7,self.nunordered,_11,_4,_10,_8,_9,_2,_0,_1,self.subi,self.subj) # src/fusion/ConstraintCache.mbi:198:8-327:9
   self.nnz = numpy.int64(self.nnz) # postprocess
   _11 = numpy.int64(_11) # postprocess
   self.subi = _8
   self.subj = _9
   self.cof = _10
   self.nunordered = 0
   return numpy.int64(_11)
  @staticmethod
  def _match_numUnsorted_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numUnsorted_(*args):
    if len(args) != 0: return False
    return True
  def _numUnsorted_alt_(self,):
    return self._numUnsorted_()
  def _numUnsorted_(self,):
   return numpy.int64(self.nunordered)
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_ConstraintCache._ctor_Lmosek_4fusion_4ConstraintCache_2(self))
 return ConstraintCache
mosek_fusion_ConstraintCache=__mk_mosek_fusion_ConstraintCache()
del __mk_mosek_fusion_ConstraintCache
#BEFORE CLASS
def __mk_mosek_fusion_Constraint():
 class Constraint(object):
  __slots__ = ['_Constraint__nativeidxs','_Constraint__shape','_Constraint__model']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):# mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args): # mosek.fusion.Model,[]int32,[]int32
      self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):# mosek.fusion.Model,[]int32,[]int32
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Constraint,mosek.fusion.Model)\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Model,array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_hstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.hstack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_stack__3Lmosek_4fusion_4Constraint_2I(*args): # []mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack__3Lmosek_4fusion_4Constraint_2I(*args): # []mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt__3Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.stack(array(mosek.fusion.Constraint,ndim=1),int32)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,int32)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32)')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Constraint._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getModel()')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_Constraint._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.remove()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Constraint._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getSize()')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Constraint._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.size()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Constraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.dual()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Constraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Constraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Constraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.slice(int32,int32)\n\tmosek.fusion.Constraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def get_nd(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1nd_(*args): # 
      return self._get_1nd_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1nd_(*args): # 
      return self._get_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_nd()')
  def update(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._update_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._update_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_update__3D(*args): # []double
      return self._update__3D(*args)
    elif mosek_fusion_Constraint._match_alt_update__3D(*args): # []double
      return self._update_alt__3D(*args)
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args): # mosek.fusion.Expression,mosek.fusion.Variable,bool
      return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args): # mosek.fusion.Expression,mosek.fusion.Variable,bool
      return self._update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args)
    else:
      raise ValueError('Invalid argument list update('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression)\n\tmosek.fusion.Constraint.update(array(double,ndim=1))\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable,bool)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_vstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.vstack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Constraint._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getND()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Constraint._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Constraint._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Constraint._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.index(int32)\n\tmosek.fusion.Constraint.index(array(int32,ndim=1))')
  def get_model(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1model_(*args): # 
      return self._get_1model_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1model_(*args): # 
      return self._get_1model_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_model('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_model()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Constraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.toString()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Constraint._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.level()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Constraint._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getShape()')
  def __repr__(self): return 'mosek.fusion.Constraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
   self.__model = m
   self.__shape = (c.__shape)
   self.__nativeidxs = (c.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   (self.__model) = model
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   raise mosek_fusion_UnimplementedError._ctor_S("Constraint.toString")
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  def _dual_1lu_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._dual_1lu_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1lu_I_3DZ(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.__model._getConstraintDuals_Z_3I_3DI(_2,self.__nativeidxs,_1,_0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__values_ZI_3D(False,0,_0)
   return (_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros((int((self.__nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__values_ZI_3D(True,0,_0)
   return (_0)
  def __values_alt_ZI_3D(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__values_ZI_3D(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __values_ZI_3D(self,_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   self.__model._getConstraintValues_Z_3I_3DI(_0,self.__nativeidxs,_2,_1)
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   raise mosek_fusion_DeletionError._ctor_S("Only original constraints can be removed")
  @staticmethod
  def _match_update__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_update__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _update_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._update__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(mosek.fusion.Expr._constTerm__3D(_0),self._getShape_()),mosek_fusion_NilVariable._ctor_(),True)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  def _update_alt_Lmosek_4fusion_4Expression_2(self,_t__0):
    return self._update_Lmosek_4fusion_4Expression_2(_0)
  def _update_Lmosek_4fusion_4Expression_2(self,_0):
   _1=_0._getShape_()
   if (int((self.__shape).shape[0]) < int((_1).shape[0])): # src/fusion/Constraint.mbi:579:12-36
    raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _2 in range(0,int((_1).shape[0])):
    if (_1[_2]!=self.__shape[_2]): # src/fusion/Constraint.mbi:582:14-35
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _3 in range(int((_1).shape[0]),int((self.__shape).shape[0])):
    if (self.__shape[_3]!=1): # src/fusion/Constraint.mbi:585:14-27
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   self.__model._update__3ILmosek_4fusion_4Expression_2(self.__nativeidxs,_0)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Z__(_2))
  def _update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(self,_t__0,_t__1,_t__2):
    return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(_0,_1,_2)
  def _update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(self,_0,_1,_2):
   _3=self._getND_()
   _4=_0._getShape_()
   if (_3 < int((_4).shape[0])): # src/fusion/Constraint.mbi:521:12-28
    raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _5 in range(0,int((_4).shape[0])):
    if (_4[_5]!=self.__shape[_5]): # src/fusion/Constraint.mbi:524:14-35
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _6 in range(int((_4).shape[0]),int((self.__shape).shape[0])):
    if (self.__shape[_6]!=1): # src/fusion/Constraint.mbi:527:14-27
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   _7=_1._numInst_()
   _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
   if (_7 < _1._getSize_()): # src/fusion/Constraint.mbi:532:12-28
    _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _1._inst_I_3JI_3J(0,_9,0,_8)
   else:
    _1._inst_I_3J(0,_8)
   for _10 in range(0,_7):
    if (_8[_10] < 0): # src/fusion/Constraint.mbi:540:14-28
     raise mosek_fusion_UpdateError._ctor_S("Semidefinite terms cannot be updated")
   _12=True
   _12 = fragments._c_closure_261(_12,_7,_8) # src/fusion/Constraint.mbi:547:10-82
   if _12: # src/fusion/Constraint.mbi:548:14-22
    if (not _2): # src/fusion/Constraint.mbi:549:16-30
     _11 = numpy.array([numpy.int32(_8[_13]) for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    else:
     _11 = numpy.zeros(((_7 + 1),), dtype=numpy.dtype(numpy.int32))
     _11[0] = 0
     fragments._c_closure_262(_7,_8,_11) # src/fusion/Constraint.mbi:554:14-69
   else:
    _14=numpy.array([_15 for _15 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_14,_8,None,0,_7)
    _16=1
    _16 = fragments._c_closure_263(_7,_16,_14,_8) # src/fusion/Constraint.mbi:561:12-85
    _16 = numpy.int32(_16) # postprocess
    if _2: # src/fusion/Constraint.mbi:562:16-26
     _16 += 1
    _11 = numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
    _17=0
    if _2: # src/fusion/Constraint.mbi:565:16-26
     _11[0] = 0
     _17 += 1
    _11[_17] = numpy.int32(_8[_14[0]])
    _17 = fragments._c_closure_264(_17,_7,_14,_8,_11) # src/fusion/Constraint.mbi:567:12-570:13
    _17 = numpy.int32(_17) # postprocess
   self.__model._update__3ILmosek_4fusion_4Expression_2_3I(self.__nativeidxs,_0,_11)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  def _update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1):
    return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  def _update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_0,_1):
   self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(_0,_1,False)
  @staticmethod
  def _match_get_1model_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1model_(*args):
    if len(args) != 0: return False
    return True
  def _get_1model_alt_(self,):
    return self._get_1model_()
  def _get_1model_(self,):
   return (self.__model)
  @staticmethod
  def _match_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _get_1nd_alt_(self,):
    return self._get_1nd_()
  def _get_1nd_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   _0=1
   _0 = fragments._c_closure_265(self.__shape,_0) # src/fusion/Constraint.mbi:493:26-69
   _0 = numpy.int64(_0) # postprocess
   return numpy.int64(_0)
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Constraint_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Constraint_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2,numpy.int32(__3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2,_3):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,numpy.int32(__2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Constraint._hstack__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Constraint_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,1))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Constraint._vstack__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Constraint_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1):
    return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1):
    return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Constraint_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=None
   for _3 in range(0,int((_0).shape[0])):
    if (_2 is None): # src/fusion/Constraint.mbi:284:16-26
     _2 = _0[_3]._getModel_()
    elif (((_0[_3].__model) is not None) and ((_0[_3].__model) is not _2)): # src/fusion/Constraint.mbi:285:20-59
     _4=mosek.fusion.Utils.StringBuffer()
     _5=(_2._getName_() if ((int(len(_2._getName_())) > 0) ) else "?")
     _6=(_0[_3]._getModel_()._getName_() if ((int(len(_0[_3]._getModel_()._getName_())) > 0) ) else "?")
     _4._a_S("Constraints belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   if (int((_0).shape[0])==0): # src/fusion/Constraint.mbi:296:12-23
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(None,numpy.array([0], dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
   elif (int((_0).shape[0])==1): # src/fusion/Constraint.mbi:297:16-27
    return (_0[1])
   else:
    _7=int((_0).shape[0])
    _8=1
    for _9 in range(0,_7):
     _8 = (_0[_9]._getND_() if ((_0[_9]._getND_() > _8) ) else _8)
    if (_1==_8): # src/fusion/Constraint.mbi:302:14-23
     _8 += 1
    _10=numpy.zeros((_7,_8,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_266(_7,_8,_10) # src/fusion/Constraint.mbi:303:38-92
    _11=numpy.array([_0[_12]._getSize_() for _12 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _13=0
    _13 = fragments._c_closure_267(_7,_11,_13) # src/fusion/Constraint.mbi:306:28-68
    _13 = numpy.int32(_13) # postprocess
    for _14 in range(0,_7):
     _15=_0[_14]._getShape_()
     fragments._c_closure_268(_14,_10,_15) # src/fusion/Constraint.mbi:310:12-311:35
    if ((_1 < 0) or (_1 > _8)): # src/fusion/Constraint.mbi:314:14-33
     raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
    for _16 in range(0,_1):
     for _17 in range(1,_7):
      if (_10[0,_16]!=_10[_17,_16]): # src/fusion/Constraint.mbi:319:18-42
       raise mosek_fusion_DimensionError._ctor_S("Constraint dimensions do not match")
    for _18 in range((_1 + 1),_8):
     for _19 in range(1,_7):
      if (_10[0,_18]!=_10[_19,_18]): # src/fusion/Constraint.mbi:324:18-42
       raise mosek_fusion_DimensionError._ctor_S("Constraint dimensions do not match")
    _20=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _21=numpy.array([_10[0,_22] for _22 in range(0,_8)], dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_269(_1,_7,_21,_10) # src/fusion/Constraint.mbi:333:10-59
    _23=int((_21).shape[0])
    _24=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    for _25 in range(0,int((_0).shape[0])):
     _24[(_25 + 1)] = (_24[_25] + _10[_25,_1])
    if (_1==0): # src/fusion/Constraint.mbi:341:16-24
     _26=0
     for _27 in range(0,_7):
      _28=int(((_0[_27].__nativeidxs)).shape[0])
      mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0[_27].__nativeidxs),0,_20,_26,_28)
      _26 += _28
    else:
     _29=_monty.initJaggedArray([(_0[_30].__nativeidxs) for _30 in range(0,_7)], 1)
     if (_1 < _8): # src/fusion/Constraint.mbi:352:18-26
      _31=1
      _31 = fragments._c_closure_270(_31,_1,_21) # src/fusion/Constraint.mbi:354:28-70
      _31 = numpy.int32(_31) # postprocess
      _32=1
      _32 = fragments._c_closure_271(_32,_1,_8,_21) # src/fusion/Constraint.mbi:355:28-70
      _32 = numpy.int32(_32) # postprocess
      _33=0
      for _34 in range(0,_31):
       for _35 in range(0,_7):
        _36=0
        _37=_10[_35,_1]
        for _38 in range(0,_37):
         for _39 in range(0,_32):
          _20[_33] = (_0[_7].__nativeidxs)[(((_34 * _32) * _37) + _36)]
          _33 += 1
          _36 += 1
     else:
      fragments._c_closure_272(_7,_20,_8,_29,_21) # src/fusion/Constraint.mbi:372:19-380:15
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(_2,_21,_20))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/Constraint.mbi:253:12-35
    raise mosek_fusion_DimensionError._ctor_S("variable shape and slice do not match")
   else:
    for _1 in range(0,int((self.__shape).shape[0])):
     if ((_0[_1] < 0) or (_0[_1] > self.__shape[_1])): # src/fusion/Constraint.mbi:257:16-49
      raise mosek_fusion_IndexError._ctor_S("index is out of bounds")
    _2=int((self.__shape).shape[0])
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _3[(_2 - 1)] = 1
    fragments._c_closure_273(_2,self.__shape,_3) # src/fusion/Constraint.mbi:261:57-123
    _4=0
    _4 = fragments._c_closure_274(_0,_4,_2,_3) # src/fusion/Constraint.mbi:262:22-76
    _4 = numpy.int32(_4) # postprocess
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.array([self.__nativeidxs[_4]], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   if ((int((self.__shape).shape[0])==0) and (_0==0)): # src/fusion/Constraint.mbi:238:12-40
    return (self)
   elif (int((self.__shape).shape[0])!=1): # src/fusion/Constraint.mbi:240:16-31
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   elif ((_0 < 0) or (_0 > self.__shape[0])): # src/fusion/Constraint.mbi:242:16-41
    raise mosek_fusion_IndexError._ctor_S("Index is out of bounds")
   else:
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.array([self.__nativeidxs[_0]], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/Constraint.mbi:180:12-37
    raise mosek_fusion_SliceError._ctor_S("invalid slice")
   elif (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/Constraint.mbi:182:16-41
    raise mosek_fusion_DimensionError._ctor_S("variable shape and slice do not match")
   else:
    for _2 in range(0,int((self.__shape).shape[0])):
     if ((_0[_2] < 0) or (_1[_2] > self.__shape[_2])): # src/fusion/Constraint.mbi:186:16-52
      raise mosek_fusion_IndexError._ctor_S("slice is out of bounds")
     elif (_0[_2] > _1[_2]): # src/fusion/Constraint.mbi:188:20-40
      raise mosek_fusion_SliceError._ctor_S("invalid slice")
    _3=int((self.__shape).shape[0])
    _4=numpy.array([(_1[_5] - _0[_5]) for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _6=1
    _6 = fragments._c_closure_275(_0,_1,_3,_6) # src/fusion/Constraint.mbi:194:29-81
    _6 = numpy.int32(_6) # postprocess
    if (_6==0): # src/fusion/Constraint.mbi:195:14-28
     return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,_4,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
    else:
     _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_276(_0,_1,self.__nativeidxs,_3,self.__shape,_7,_6) # src/fusion/Constraint.mbi:199:12-226:13
     return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self._getModel_(),_4,_7))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (int((self.__shape).shape[0])!=1): # src/fusion/Constraint.mbi:167:12-27
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   if ((_0==0) and (_1==self.__shape[0])): # src/fusion/Constraint.mbi:169:12-43
    return (self)
   elif ((_0 < 0) or (_1 > self.__shape[0])): # src/fusion/Constraint.mbi:171:16-44
    raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   elif (_0 > _1): # src/fusion/Constraint.mbi:173:16-28
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   else:
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.array([(_1 - _0)], dtype=numpy.dtype(numpy.int32)),numpy.array([self.__nativeidxs[_2] for _2 in range(_0,_1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   _0=1
   _0 = fragments._c_closure_277(self.__shape,_0) # src/fusion/Constraint.mbi:157:20-63
   _0 = numpy.int32(_0) # postprocess
   return numpy.int32(_0)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (numpy.array([self.__shape[_0] for _0 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  def _getNativeidxs_alt_(self,):
    return self._getNativeidxs_()
  def _getNativeidxs_(self,):
   return (self.__nativeidxs)
 return Constraint
mosek_fusion_Constraint=__mk_mosek_fusion_Constraint()
del __mk_mosek_fusion_Constraint
#BEFORE CLASS
def __mk_mosek_fusion_SliceConstraint():
 class SliceConstraint(mosek_fusion_Constraint):
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SliceConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SliceConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.SliceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceConstraint_2(c):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4SliceConstraint_2(c)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceConstraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_match_Lmosek_4fusion_4SliceConstraint_2__(c))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceConstraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(c))
  def _ctor_alt_init_Lmosek_4fusion_4SliceConstraint_2(self,c):
    self._ctor_init_Lmosek_4fusion_4SliceConstraint_2(c)
  def _ctor_init_Lmosek_4fusion_4SliceConstraint_2(self,c):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,c._getModel_())
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SliceConstraint()")
   return (_0._toString_())
 return SliceConstraint
mosek_fusion_SliceConstraint=__mk_mosek_fusion_SliceConstraint()
del __mk_mosek_fusion_SliceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceConstraint():
 class BoundInterfaceConstraint(mosek_fusion_SliceConstraint):
  __slots__ = ['_BoundInterfaceConstraint__islower']
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.dual()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.slice(int32,int32)\n\tmosek.fusion.BoundInterfaceConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.index(int32)\n\tmosek.fusion.BoundInterfaceConstraint.index(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.BoundInterfaceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3IZ(m,shape,nativeidxs,islower):
    o = BoundInterfaceConstraint.__new__(BoundInterfaceConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(m,shape,nativeidxs,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3IZ(*args):
    if len(args) != 4: return False
    m,shape,nativeidxs,islower, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3IZ(*args):
    if len(args) != 4: return False
    m,shape,nativeidxs,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3IZ(self,m,shape,nativeidxs,islower):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),islower)
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(self,m,shape,nativeidxs,islower):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_SliceConstraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,m,shape,nativeidxs)
   (self.__islower) = islower
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceConstraint_2Z(c,islower):
    o = BoundInterfaceConstraint.__new__(BoundInterfaceConstraint)
    o._ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(c,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceConstraint_2Z(*args):
    if len(args) != 2: return False
    c,islower, = args
    return (__arg_match_Lmosek_4fusion_4SliceConstraint_2__(c) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceConstraint_2Z(*args):
    if len(args) != 2: return False
    c,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(c) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4SliceConstraint_2Z(self,c,islower):
    self._ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(c,islower)
  def _ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(self,c,islower):
   mosek_fusion_SliceConstraint._ctor_init_Lmosek_4fusion_4SliceConstraint_2(self,c)
   (self.__islower) = islower
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
   self._dual_1lu_I_3DZ(0,_0,self.__islower)
   return (_0)
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=mosek_fusion_Constraint._slice__3I_3I(self,_0,_1)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_2))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   _2=mosek_fusion_Constraint._slice_II(self,_0,_1)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_2))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=mosek_fusion_Constraint._index__3I(self,_0)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_1))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   _1=mosek_fusion_Constraint._index_I(self,_0)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_1))
  def __from_1_alt_Lmosek_4fusion_4Constraint_2(self,_t__0):
    return self.__from_1_Lmosek_4fusion_4Constraint_2(_0)
  def __from_1_Lmosek_4fusion_4Constraint_2(self,_0):
   _2=_0
   if   isinstance(_2,mosek_fusion_SliceConstraint):
    cc=_2
    return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4SliceConstraint_2Z(cc,self.__islower))
   else:
    cc=_2
    return (None)
 return BoundInterfaceConstraint
mosek_fusion_BoundInterfaceConstraint=__mk_mosek_fusion_BoundInterfaceConstraint()
del __mk_mosek_fusion_BoundInterfaceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ModelConstraint():
 class ModelConstraint(mosek_fusion_Constraint):
  __slots__ = ['_ModelConstraint__conid','_ModelConstraint__shape','_ModelConstraint__nativeidxs','_ModelConstraint__names_flushed','_ModelConstraint__name']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.toString()')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.remove()')
  def __repr__(self): return 'mosek.fusion.ModelConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m)
   (self.__conid) = (c.__conid)
   self.__name = (c.__name)
   self.__names_flushed = (c.__names_flushed)
   self.__nativeidxs = (c.__nativeidxs)
   self.__shape = (c.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nidxs,conid):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nidxs,conid)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nidxs,conid, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match__3I__(nidxs) and __arg_match_I__(conid))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nidxs,conid, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nidxs) and __arg_alt_match_I__(conid))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nidxs is None or isinstance(nidxs,numpy.ndarray)
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nidxs)
   (self.__name) = name
   (self.__names_flushed) = False
   (self.__nativeidxs) = nidxs
   (self.__shape) = shape
   (self.__conid) = conid
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Constraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   _0=self._getModel_()
   if (not self.__names_flushed): # src/fusion/ModelConstraint.mbi:82:12-29
    if (self._getSize_()==0): # src/fusion/ModelConstraint.mbi:83:14-28
     self.__names_flushed = True
    else:
     if (int(len(self.__name))==0): # src/fusion/ModelConstraint.mbi:85:19-33
      _0._connames__3IS_3I_3J(self.__nativeidxs,"",numpy.array([self._getSize_()], dtype=numpy.dtype(numpy.int32)),None)
     else:
      _1=mosek.fusion.Utils.StringBuffer()
      _1._a_S(self.__name)._a_S("[")
      if (self._getND_() > 0): # src/fusion/ModelConstraint.mbi:91:16-27
       _1._a_S("%0")
       for _2 in range(1,self._getND_()):
        _1._a_S(",%")._a_I(_2)
      _1._a_S("]")
      _0._connames__3IS_3I_3J(self.__nativeidxs,_1._toString_(),(self._getShape_() if ((self._getND_() > 0) ) else numpy.array([1], dtype=numpy.dtype(numpy.int32))),None)
      self.__names_flushed = True
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   self._getModel_()._removeConstraintBlock_I(self.__conid)
 return ModelConstraint
mosek_fusion_ModelConstraint=__mk_mosek_fusion_ModelConstraint()
del __mk_mosek_fusion_ModelConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDConstraint():
 class LinearPSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearPSDConstraint__conedim','_LinearPSDConstraint__shape','_LinearPSDConstraint__conid','_LinearPSDConstraint__slackidxs','_LinearPSDConstraint__nativeidxs']
  def __repr__(self): return 'mosek.fusion.LinearPSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__slackidxs = (c.__slackidxs)
   self.__nativeidxs = (c.__nativeidxs)
   self.__conedim = (c.__conedim)
   self.__shape = (c.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,conid,shape,conedim,nativeidxs,slackidxs):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,conid,shape,conedim,nativeidxs,slackidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(*args):
    if len(args) != 7: return False
    model,name,conid,shape,conedim,nativeidxs,slackidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match_I__(conedim) and __arg_match__3I__(nativeidxs) and __arg_match__3J__(slackidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(*args):
    if len(args) != 7: return False
    model,name,conid,shape,conedim,nativeidxs,slackidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match__3J__(slackidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,model,name,conid,shape,conedim,nativeidxs,slackidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(slackidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,model,name,conid,shape,conedim,nativeidxs,slackidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   assert slackidxs is None or isinstance(slackidxs,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid)
   (self.__conid) = conid
   (self.__slackidxs) = slackidxs
   (self.__nativeidxs) = nativeidxs
   (self.__conedim) = conedim
   (self.__shape) = shape
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=mosek.fusion.Set._idxtokey__3IJ(self.__shape,_0)
   _1._a_S(" : element (")._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   _1._a_S(") in a positive semi-definite cone of size (")._a_I(self.__shape[0])
   for _4 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(self.__shape[_4])
   _1._a_S(")")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearPSDConstraint
mosek_fusion_LinearPSDConstraint=__mk_mosek_fusion_LinearPSDConstraint()
del __mk_mosek_fusion_LinearPSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_PSDConstraint():
 class PSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_PSDConstraint__names_flushed','_PSDConstraint__conedim1','_PSDConstraint__conedim0','_PSDConstraint__shape','_PSDConstraint__name','_PSDConstraint__slackidxs','_PSDConstraint__nativeidxs','_PSDConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.PSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__name = (c.__name)
   self.__shape = (c.__shape)
   self.__slackidxs = (c.__slackidxs)
   self.__nativeidxs = (c.__nativeidxs)
   self.__names_flushed = (c.__names_flushed)
   self.__conedim0 = (c.__conedim0)
   self.__conedim1 = (c.__conedim1)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(*args):
    if len(args) != 8: return False
    model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match_I__(conedim0) and __arg_match_I__(conedim1) and __arg_match__3J__(slackidxs) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(*args):
    if len(args) != 8: return False
    model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim0) and __arg_alt_match_I__(conedim1) and __arg_alt_match__3J__(slackidxs) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim0),numpy.int32(conedim1),numpy.array(slackidxs,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert slackidxs is None or isinstance(slackidxs,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,mosek.fusion.PSDConstraint.__computenidxs__3III_3I(shape,conedim0,conedim1,nativeidxs),conid)
   (self.__conid) = conid
   (self.__nativeidxs) = nativeidxs
   (self.__slackidxs) = slackidxs
   (self.__name) = name
   (self.__shape) = shape
   (self.__conedim0) = conedim0
   (self.__conedim1) = conedim1
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   raise mosek_fusion_UnimplementedError._ctor_S("PSDConstraint.toString not implemented")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __computenidxs_alt__3III_3I(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_PSDConstraint.__computenidxs__3III_3I(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computenidxs__3III_3I(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _4=int((_0).shape[0])
   _5=(_1 < _2)
   _6=(_1 if (_5 ) else _2)
   _7=(_2 if (_5 ) else _1)
   _8=numpy.array([1,1,1,1,1], dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _10=1
   _10 = fragments._c_closure_278(_0,_10) # src/fusion/SemidefiniteConstraint.mbi:39:22-67
   _10 = numpy.int32(_10) # postprocess
   fragments._c_closure_279(_6,_8,_0) # src/fusion/SemidefiniteConstraint.mbi:41:8-53
   _8[1] = _0[_6]
   fragments._c_closure_280(_6,_7,_8,_0) # src/fusion/SemidefiniteConstraint.mbi:43:8-62
   _8[3] = _0[_7]
   fragments._c_closure_281(_7,_8,_4,_0) # src/fusion/SemidefiniteConstraint.mbi:45:8-56
   _9[4] = 1
   fragments._c_closure_282(_8,_9) # src/fusion/SemidefiniteConstraint.mbi:46:23-81
   _11=numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
   _12=0
   _12 = fragments._c_closure_283(_8,_12,_3,_11,_9,_5) # src/fusion/SemidefiniteConstraint.mbi:51:8-70:19
   _12 = numpy.int32(_12) # postprocess
   return (_11)
 return PSDConstraint
mosek_fusion_PSDConstraint=__mk_mosek_fusion_PSDConstraint()
del __mk_mosek_fusion_PSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_RangedConstraint():
 class RangedConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_RangedConstraint__nativeidxs','_RangedConstraint__shape']
  def upperBoundCon(self,*args):
    if False: pass
    elif mosek_fusion_RangedConstraint._match_upperBoundCon_(*args): # 
      return self._upperBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_upperBoundCon_(*args): # 
      return self._upperBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.upperBoundCon()')
  def lowerBoundCon(self,*args):
    if False: pass
    elif mosek_fusion_RangedConstraint._match_lowerBoundCon_(*args): # 
      return self._lowerBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_lowerBoundCon_(*args): # 
      return self._lowerBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.lowerBoundCon()')
  def __repr__(self): return 'mosek.fusion.RangedConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__shape = (c.__shape)
   self.__nativeidxs = (c.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nativeidxs,conid):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nativeidxs,conid)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nativeidxs,conid, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs) and __arg_match_I__(conid))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nativeidxs,conid, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match_I__(conid))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid)
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundCon_alt_(self,):
    return self._upperBoundCon_()
  def _upperBoundCon_(self,):
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3IZ(self._getModel_(),self.__shape,self.__nativeidxs,False))
  @staticmethod
  def _match_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundCon_alt_(self,):
    return self._lowerBoundCon_()
  def _lowerBoundCon_(self,):
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3IZ(self._getModel_(),self.__shape,self.__nativeidxs,True))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return RangedConstraint
mosek_fusion_RangedConstraint=__mk_mosek_fusion_RangedConstraint()
del __mk_mosek_fusion_RangedConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ConicConstraint():
 class ConicConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_ConicConstraint__nativeslack','_ConicConstraint__nativeidxs','_ConicConstraint__names_flushed','_ConicConstraint__name','_ConicConstraint__shape','_ConicConstraint__dom','_ConicConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.ConicConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__dom = (c.__dom)
   self.__conid = (c.__conid)
   self.__shape = (c.__shape)
   self.__name = (c.__name)
   self.__nativeidxs = (c.__nativeidxs)
   self.__nativeslack = (c.__nativeslack)
   self.__names_flushed = (c.__names_flushed)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(model,name,dom,shape,conid,nativeidxs,nativeslack):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(model,name,dom,shape,conid,nativeidxs,nativeslack)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(*args):
    if len(args) != 7: return False
    model,name,dom,shape,conid,nativeidxs,nativeslack, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(dom) and __arg_match__3I__(shape) and __arg_match_I__(conid) and __arg_match__3I__(nativeidxs) and __arg_match__3I__(nativeslack))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(*args):
    if len(args) != 7: return False
    model,name,dom,shape,conid,nativeidxs,nativeslack, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(dom) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match__3I__(nativeslack))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(self,model,name,dom,shape,conid,nativeidxs,nativeslack):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(model,name,dom,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeslack,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3I(self,model,name,dom,shape,conid,nativeidxs,nativeslack):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nativeidxs is None or isinstance(nativeidxs,numpy.ndarray)
   assert nativeslack is None or isinstance(nativeslack,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid)
   (self.__dom) = dom
   (self.__shape) = shape
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__nativeslack) = nativeslack
   (self.__conid) = conid
   self.__names_flushed = False
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   mosek_fusion_ModelConstraint._flushNames_(self)
   _0=int((self.__nativeslack).shape[0])
   _1=self._getModel_()
   if ((not self.__names_flushed) and (int(len(self.__name)) > 0)): # src/fusion/ConicConstraint.mbi:112:12-47
    if (int(len(self.__name))==0): # src/fusion/ConicConstraint.mbi:113:14-28
     for _2 in range(0,_0):
      _1._task_1var_1name_IS(self.__nativeslack[_2],"")
    else:
     _3=mosek.fusion.Utils.StringBuffer()
     for _4 in range(0,_0):
      _1._task_1var_1name_IS(self.__nativeslack[_4],_3._clear_()._a_S(self.__name)._a_S("[")._a_S(mosek.fusion.Set._indexToString__3IJ(self.__shape,_4))._a_S("].coneslack")._toString_())
    self.__names_flushed = True
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("ConicConstraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   raise mosek_fusion_UnimplementedError._ctor_S("ConicConstraint.domainToString")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return ConicConstraint
mosek_fusion_ConicConstraint=__mk_mosek_fusion_ConicConstraint()
del __mk_mosek_fusion_ConicConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearConstraint():
 class LinearConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearConstraint__name','_LinearConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.LinearConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__name = (c.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,conid,shape,nidxs):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,conid,shape,nidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,conid,shape,nidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match__3I__(nidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,conid,shape,nidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,conid,shape,nidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,conid,shape,nidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert nidxs is None or isinstance(nidxs,numpy.ndarray)
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid)
   (self.__conid) = conid
   (self.__name) = name
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("LinearConstraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearConstraint
mosek_fusion_LinearConstraint=__mk_mosek_fusion_LinearConstraint()
del __mk_mosek_fusion_LinearConstraint
#BEFORE CLASS
def __mk_mosek_fusion_Set():
 class Set(object):
  @staticmethod
  def keyToString(*args):
    if False: pass
    elif mosek_fusion_Set._match_keyToString__3I(*args): # []int32
      return mosek_fusion_Set._keyToString__3I(*args)
    elif mosek_fusion_Set._match_alt_keyToString__3I(*args): # []int32
      return mosek_fusion_Set._keyToString_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list keyToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.keyToString(array(int32,ndim=1))')
  @staticmethod
  def size(*args):
    if False: pass
    elif mosek_fusion_Set._match_size__3I(*args): # []int32
      return mosek_fusion_Set._size__3I(*args)
    elif mosek_fusion_Set._match_alt_size__3I(*args): # []int32
      return mosek_fusion_Set._size_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.size(array(int32,ndim=1))')
  @staticmethod
  def idxtokey(*args):
    if False: pass
    elif mosek_fusion_Set._match_idxtokey__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._idxtokey__3IJ(*args)
    elif mosek_fusion_Set._match_alt_idxtokey__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._idxtokey_alt__3IJ(*args)
    elif mosek_fusion_Set._match_idxtokey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._idxtokey__3IJ_3I(*args)
    elif mosek_fusion_Set._match_alt_idxtokey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._idxtokey_alt__3IJ_3I(*args)
    else:
      raise ValueError('Invalid argument list idxtokey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.idxtokey(array(int32,ndim=1),int64)\n\tmosek.fusion.Set.idxtokey(array(int32,ndim=1),int64,array(int32,ndim=1))')
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_Set._match_make__3S(*args): # []string
      return mosek_fusion_Set._make__3S(*args)
    elif mosek_fusion_Set._match_alt_make__3S(*args): # []string
      return mosek_fusion_Set._make_alt__3S(*args)
    elif mosek_fusion_Set._match_make_I(*args): # int32
      return mosek_fusion_Set._make_I(*args)
    elif mosek_fusion_Set._match_alt_make_I(*args): # int32
      return mosek_fusion_Set._make_alt_I(*args)
    elif mosek_fusion_Set._match_make__3I(*args): # []int32
      return mosek_fusion_Set._make__3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I(*args): # []int32
      return mosek_fusion_Set._make_alt__3I(*args)
    elif mosek_fusion_Set._match_make__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._make__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._make_alt__3I_3I(*args)
    elif mosek_fusion_Set._match_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_II(*args)
    elif mosek_fusion_Set._match_alt_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_alt_II(*args)
    elif mosek_fusion_Set._match_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_III(*args)
    elif mosek_fusion_Set._match_alt_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_alt_III(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.make(array(string,ndim=1))\n\tmosek.fusion.Set.make(int32)\n\tmosek.fusion.Set.make(array(int32,ndim=1))\n\tmosek.fusion.Set.make(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Set.make(int32,int32)\n\tmosek.fusion.Set.make(int32,int32,int32)')
  @staticmethod
  def linearidx(*args):
    if False: pass
    elif mosek_fusion_Set._match_linearidx__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._linearidx__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_linearidx__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._linearidx_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list linearidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.linearidx(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def match(*args):
    if False: pass
    elif mosek_fusion_Set._match_match__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._match__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_match__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._match_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list match('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.match(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def indexToString(*args):
    if False: pass
    elif mosek_fusion_Set._match_indexToString__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._indexToString__3IJ(*args)
    elif mosek_fusion_Set._match_alt_indexToString__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._indexToString_alt__3IJ(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToString(array(int32,ndim=1),int64)')
  @staticmethod
  def strides(*args):
    if False: pass
    elif mosek_fusion_Set._match_strides__3I(*args): # []int32
      return mosek_fusion_Set._strides__3I(*args)
    elif mosek_fusion_Set._match_alt_strides__3I(*args): # []int32
      return mosek_fusion_Set._strides_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list strides('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.strides(array(int32,ndim=1))')
  @staticmethod
  def indexToKey(*args):
    if False: pass
    elif mosek_fusion_Set._match_indexToKey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._indexToKey__3IJ_3I(*args)
    elif mosek_fusion_Set._match_alt_indexToKey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._indexToKey_alt__3IJ_3I(*args)
    else:
      raise ValueError('Invalid argument list indexToKey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToKey(array(int32,ndim=1),int64,array(int32,ndim=1))')
  @staticmethod
  def scalar(*args):
    if False: pass
    elif mosek_fusion_Set._match_scalar_(*args): # 
      return mosek_fusion_Set._scalar_(*args)
    elif mosek_fusion_Set._match_alt_scalar_(*args): # 
      return mosek_fusion_Set._scalar_alt_(*args)
    else:
      raise ValueError('Invalid argument list scalar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.scalar()')
  def __repr__(self): return 'mosek.fusion.Set'
  @staticmethod
  def _match_size__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_size__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _size_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._size__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _size__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   _1 = fragments._c_closure_284(_0,_1) # src/fusion/Set.mbi:205:21-64
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def _match_match__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_match__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _match_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._match__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _match__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/Set.mbi:196:12-30
    return (False)
   for _2 in range(0,int((_0).shape[0])):
    if (_0[_2]!=_1[_2]): # src/fusion/Set.mbi:198:14-28
     return (False)
   return (True)
  @staticmethod
  def _match_linearidx__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_linearidx__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _linearidx_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._linearidx__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _linearidx__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=_1[0]
   _2 = fragments._c_closure_285(_1,_2,_0) # src/fusion/Set.mbi:189:8-190:40
   _2 = numpy.int64(_2) # postprocess
   return numpy.int64(_2)
  @staticmethod
  def _match_idxtokey__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_idxtokey__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _idxtokey_alt__3IJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_Set._idxtokey__3IJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _idxtokey__3IJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Set._idxtokey__3IJ_3I(_0,_1,_2)
   return (_2)
  @staticmethod
  def _match_idxtokey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_idxtokey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _idxtokey_alt__3IJ_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._idxtokey__3IJ_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _idxtokey__3IJ_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   fragments._c_closure_286(_2,_1,_0) # src/fusion/Set.mbi:155:6-167:7
  @staticmethod
  def _match_indexToString__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_indexToString__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _indexToString_alt__3IJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_Set._indexToString__3IJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _indexToString__3IJ(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=int((_0).shape[0])
   _3=mosek.fusion.Utils.StringBuffer()
   if (_2==0): # src/fusion/Set.mbi:128:12-19
    return ("0")
   elif (_2==1): # src/fusion/Set.mbi:130:16-23
    return (_3._a_J(_1)._toString_())
   else:
    _4=_1
    _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _4 = fragments._c_closure_287(_5,_2,_4,_0) # src/fusion/Set.mbi:136:10-139:11
    _4 = numpy.int64(_4) # postprocess
    _5[0] = numpy.int32(_4)
    _3._a_I(_5[0])
    for _6 in range(1,_2):
     _3._a_S(",")._a_I(_5[_6])
    return (_3._toString_())
  @staticmethod
  def _match_keyToString__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_keyToString__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _keyToString_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._keyToString__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _keyToString__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=mosek.fusion.Utils.StringBuffer()
   _1._a_I(_0[0])
   for _2 in range(1,int((_0).shape[0])):
    _1._a_S(",")._a_I(_0[_2])
   return (_1._toString_())
  @staticmethod
  def _match_indexToKey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_indexToKey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _indexToKey_alt__3IJ_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._indexToKey__3IJ_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _indexToKey__3IJ_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   fragments._c_closure_288(_1,_2,_0) # src/fusion/Set.mbi:93:6-107:7
  @staticmethod
  def _match_strides__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_strides__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _strides_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._strides__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _strides__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
   _2[(_1 - 1)] = 1
   fragments._c_closure_289(_1,_0,_2) # src/fusion/Set.mbi:85:8-64
   return (_2)
  @staticmethod
  def _match_make__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_make__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _make_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._make__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.zeros(((int((_0).shape[0]) + int((_1).shape[0])),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_290(_2,_0) # src/fusion/Set.mbi:69:8-50
   fragments._c_closure_291(_2,_0,_1) # src/fusion/Set.mbi:70:8-60
   return (_2)
  @staticmethod
  def _match_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _make_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._make__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _make_alt_III(_t__0,_t__1,_t__2):
    return mosek_fusion_Set._make_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _make_III(_0,_1,_2):
   return (numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _make_alt_II(_t__0,_t__1):
    return mosek_fusion_Set._make_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _make_II(_0,_1):
   return (numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _make_alt_I(_t__0):
    return mosek_fusion_Set._make_I(numpy.int32(__0))
  @staticmethod
  def _make_I(_0):
   return (numpy.array([_0], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _scalar_alt_():
    return mosek_fusion_Set._scalar_()
  @staticmethod
  def _scalar_():
   return (numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3S__(_0))
  @staticmethod
  def _match_alt_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3S__(_0))
  @staticmethod
  def _make_alt__3S(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Set._make__3S(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3S(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)))
 return Set
mosek_fusion_Set=__mk_mosek_fusion_Set()
del __mk_mosek_fusion_Set
#BEFORE CLASS
def __mk_mosek_fusion_ConeDomain():
 class ConeDomain(object):
  __slots__ = ['_alpha','_shape','_int_flag','_axisset','_axisidx','_key']
  def axis(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_axis_I(*args): # int32
      return self._axis_I(*args)
    elif mosek_fusion_ConeDomain._match_alt_axis_I(*args): # int32
      return self._axis_alt_I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.axis(int32)')
  def axisIsSet(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_axisIsSet_(*args): # 
      return self._axisIsSet_(*args)
    elif mosek_fusion_ConeDomain._match_alt_axisIsSet_(*args): # 
      return self._axisIsSet_alt_(*args)
    else:
      raise ValueError('Invalid argument list axisIsSet('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.axisIsSet()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_ConeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.integral()')
  def getAxis(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_getAxis_(*args): # 
      return self._getAxis_(*args)
    elif mosek_fusion_ConeDomain._match_alt_getAxis_(*args): # 
      return self._getAxis_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.getAxis()')
  def __repr__(self): return 'mosek.fusion.ConeDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2D_3I(k,alpha,d):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2D_3I(k,alpha,d)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2D_3I(*args):
    if len(args) != 3: return False
    k,alpha,d, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match_D__(alpha) and __arg_match__3I__(d))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2D_3I(*args):
    if len(args) != 3: return False
    k,alpha,d, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match_D__(alpha) and __arg_alt_match__3I__(d))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2D_3I(self,k,alpha,d):
    self._ctor_init_Emosek_4fusion_4QConeKey_2D_3I(k,numpy.float64(alpha),numpy.array(d,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4QConeKey_2D_3I(self,k,alpha,d):
   assert d is None or isinstance(d,numpy.ndarray)
   self._shape = (mosek.fusion.Set._make__3I(d) if ((d is not None) ) else None)
   (self._alpha) = alpha
   self._key = k
   self._axisidx = 0
   self._axisset = False
   self._int_flag = False
   (self._alpha) = alpha
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2_3I(k,d):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2_3I(k,d)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2_3I(*args):
    if len(args) != 2: return False
    k,d, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match__3I__(d))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2_3I(*args):
    if len(args) != 2: return False
    k,d, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match__3I__(d))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2_3I(self,k,d):
    self._ctor_init_Emosek_4fusion_4QConeKey_2_3I(k,numpy.array(d,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4QConeKey_2_3I(self,k,d):
   assert d is None or isinstance(d,numpy.ndarray)
   mosek_fusion_ConeDomain._ctor_init_Emosek_4fusion_4QConeKey_2D_3I(self,k,1.0,d)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (((self._shape is None) or mosek.fusion.Set._match__3I_3I(_0,self._shape)))
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._int_flag = True
   return (self)
  @staticmethod
  def _match_axisIsSet_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_axisIsSet_(*args):
    if len(args) != 0: return False
    return True
  def _axisIsSet_alt_(self,):
    return self._axisIsSet_()
  def _axisIsSet_(self,):
   return (self._axisset)
  @staticmethod
  def _match_getAxis_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAxis_(*args):
    if len(args) != 0: return False
    return True
  def _getAxis_alt_(self,):
    return self._getAxis_()
  def _getAxis_(self,):
   return numpy.int32(self._axisidx)
  @staticmethod
  def _match_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _axis_alt_I(self,_t__0):
    return self._axis_I(numpy.int32(__0))
  def _axis_I(self,_0):
   self._axisidx = _0
   self._axisset = True
   return (self)
 return ConeDomain
mosek_fusion_ConeDomain=__mk_mosek_fusion_ConeDomain()
del __mk_mosek_fusion_ConeDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinPSDDomain():
 class LinPSDDomain(object):
  __slots__ = ['_conedim','_shape']
  def __repr__(self): return 'mosek.fusion.LinPSDDomain'
  @staticmethod
  def _ctor__3II(shp,conedim):
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init__3II(shp,conedim)
    return o
  @staticmethod
  def __match_ctor__3II(*args):
    if len(args) != 2: return False
    shp,conedim, = args
    return (__arg_match__3I__(shp) and __arg_match_I__(conedim))
  @staticmethod
  def __match_alt_ctor__3II(*args):
    if len(args) != 2: return False
    shp,conedim, = args
    return (__arg_alt_match__3I__(shp) and __arg_alt_match_I__(conedim))
  def _ctor_alt_init__3II(self,shp,conedim):
    self._ctor_init__3II(numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim))
  def _ctor_init__3II(self,shp,conedim):
   assert shp is None or isinstance(shp,numpy.ndarray)
   (self._conedim) = conedim
   self._shape = mosek.fusion.Utils.Tools._arraycopy__3I(shp)
  @staticmethod
  def _ctor__3I(shp):
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init__3I(shp)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shp, = args
    return (__arg_match__3I__(shp))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shp, = args
    return (__arg_alt_match__3I__(shp))
  def _ctor_alt_init__3I(self,shp):
    self._ctor_init__3I(numpy.array(shp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shp):
   assert shp is None or isinstance(shp,numpy.ndarray)
   self._shape = mosek.fusion.Utils.Tools._arraycopy__3I(shp)
   self._conedim = (int((self._shape).shape[0]) - 1)
  @staticmethod
  def _ctor_():
    o = LinPSDDomain.__new__(LinPSDDomain)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   self._conedim = 0
   self._shape = None
 return LinPSDDomain
mosek_fusion_LinPSDDomain=__mk_mosek_fusion_LinPSDDomain()
del __mk_mosek_fusion_LinPSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_PSDDomain():
 class PSDDomain(object):
  __slots__ = ['_axisIsSet','_conedim2','_conedim1','_key','_shape']
  def axis(self,*args):
    if False: pass
    elif mosek_fusion_PSDDomain._match_axis_II(*args): # int32,int32
      return self._axis_II(*args)
    elif mosek_fusion_PSDDomain._match_alt_axis_II(*args): # int32,int32
      return self._axis_alt_II(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDDomain.axis(int32,int32)')
  def __repr__(self): return 'mosek.fusion.PSDDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2_3III(k,shp,conedim1,conedim2):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2_3III(k,shp,conedim1,conedim2)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2_3III(*args):
    if len(args) != 4: return False
    k,shp,conedim1,conedim2, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match__3I__(shp) and __arg_match_I__(conedim1) and __arg_match_I__(conedim2))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2_3III(*args):
    if len(args) != 4: return False
    k,shp,conedim1,conedim2, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match__3I__(shp) and __arg_alt_match_I__(conedim1) and __arg_alt_match_I__(conedim2))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,conedim1,conedim2):
    self._ctor_init_Emosek_4fusion_4PSDKey_2_3III(k,numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim1),numpy.int32(conedim2))
  def _ctor_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,conedim1,conedim2):
   assert shp is None or isinstance(shp,numpy.ndarray)
   self._axisIsSet = True
   self._shape = shp
   self._key = k
   (self._conedim1) = conedim1
   (self._conedim2) = conedim2
   _0=int((self._shape).shape[0])
   if ((not ((int((self._shape).shape[0]) > conedim1) and ((int((self._shape).shape[0]) > conedim2) and ((conedim1 >= 0) and ((conedim2 >= 0) and (conedim1!=conedim2)))))) and (self._shape[conedim1]==self._shape[conedim2])): # src/fusion/domain.mbi:1084:13-1089:47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2_3I(k,shp):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2_3I(k,shp)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2_3I(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match__3I__(shp))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2_3I(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match__3I__(shp))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2_3I(self,k,shp):
    self._ctor_init_Emosek_4fusion_4PSDKey_2_3I(k,numpy.array(shp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4PSDKey_2_3I(self,k,shp):
   assert shp is None or isinstance(shp,numpy.ndarray)
   mosek_fusion_PSDDomain._ctor_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,(int((shp).shape[0]) - 2),(int((shp).shape[0]) - 1))
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2(k):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2(k)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2(self,k):
    self._ctor_init_Emosek_4fusion_4PSDKey_2(k)
  def _ctor_init_Emosek_4fusion_4PSDKey_2(self,k):
   self._shape = None
   self._key = k
   self._conedim1 = 0
   self._conedim2 = 0
   self._axisIsSet = False
  @staticmethod
  def _match_axis_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_axis_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _axis_alt_II(self,_t__0,_t__1):
    return self._axis_II(numpy.int32(__0),numpy.int32(__1))
  def _axis_II(self,_0,_1):
   (self._conedim1) = _0
   (self._conedim2) = _1
   self._axisIsSet = True
   if ((self._shape is None) and (not ((_0 >= 0) and ((_1 >= 0) and (_0!=_1))))): # src/fusion/domain.mbi:1101:17-1104:43
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
   elif ((self._shape is not None) and ((not ((int((self._shape).shape[0]) > _0) and ((int((self._shape).shape[0]) > _1) and ((_0 >= 0) and ((_1 >= 0) and (_0!=_1)))))) and (self._shape[_0]==self._shape[_1]))): # src/fusion/domain.mbi:1106:17-1112:51
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
   return (self)
 return PSDDomain
mosek_fusion_PSDDomain=__mk_mosek_fusion_PSDDomain()
del __mk_mosek_fusion_PSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_RangeDomain():
 class RangeDomain(object):
  __slots__ = ['_cardinal_flag','_scalable','_ub','_lb','_sparsity','_empty','_shape']
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_RangeDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.symmetric()')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_RangeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.integral()')
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    elif mosek_fusion_RangeDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_RangeDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.sparse()\n\tmosek.fusion.RangeDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.RangeDomain.sparse(array(int32,ndim=2))')
  def withShape(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_withShape__3I(*args): # []int32
      return self._withShape__3I(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape__3I(*args): # []int32
      return self._withShape_alt__3I(*args)
    elif mosek_fusion_RangeDomain._match_withShape_I(*args): # int32
      return self._withShape_I(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_I(*args): # int32
      return self._withShape_alt_I(*args)
    elif mosek_fusion_RangeDomain._match_withShape_II(*args): # int32,int32
      return self._withShape_II(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_II(*args): # int32,int32
      return self._withShape_alt_II(*args)
    elif mosek_fusion_RangeDomain._match_withShape_III(*args): # int32,int32,int32
      return self._withShape_III(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_III(*args): # int32,int32,int32
      return self._withShape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.withShape(array(int32,ndim=1))\n\tmosek.fusion.RangeDomain.withShape(int32)\n\tmosek.fusion.RangeDomain.withShape(int32,int32)\n\tmosek.fusion.RangeDomain.withShape(int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.RangeDomain'
  @staticmethod
  def _ctor_Z_3D_3D_3I(scalable,lb,ub,dims):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I(scalable,lb,ub,dims)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Z_3D_3D_3I(self,scalable,lb,ub,dims):
    self._ctor_init_Z_3D_3D_3I(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Z_3D_3D_3I(self,scalable,lb,ub,dims):
   assert lb is None or isinstance(lb,numpy.ndarray)
   assert ub is None or isinstance(ub,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   mosek_fusion_RangeDomain._ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,None,1)
  @staticmethod
  def _ctor_Z_3D_3D_3I_3_5I(scalable,lb,ub,dims,sp):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I_3_5I(scalable,lb,ub,dims,sp)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I_3_5I(*args):
    if len(args) != 5: return False
    scalable,lb,ub,dims,sp, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I_3_5I(*args):
    if len(args) != 5: return False
    scalable,lb,ub,dims,sp, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp))
  def _ctor_alt_init_Z_3D_3D_3I_3_5I(self,scalable,lb,ub,dims,sp):
    self._ctor_init_Z_3D_3D_3I_3_5I(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Z_3D_3D_3I_3_5I(self,scalable,lb,ub,dims,sp):
   assert lb is None or isinstance(lb,numpy.ndarray)
   assert ub is None or isinstance(ub,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   assert sp is None or isinstance(sp,numpy.ndarray)
   mosek_fusion_RangeDomain._ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,1)
  @staticmethod
  def _ctor_Z_3D_3D_3I_3_5II(scalable,lb,ub,dims,sp,steal):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I_3_5II(scalable,lb,ub,dims,sp,steal)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    scalable,lb,ub,dims,sp,steal, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp) and __arg_match_I__(steal))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    scalable,lb,ub,dims,sp,steal, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp) and __arg_alt_match_I__(steal))
  def _ctor_alt_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,steal):
    self._ctor_init_Z_3D_3D_3I_3_5II(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)),numpy.int32(steal))
  def _ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,steal):
   assert lb is None or isinstance(lb,numpy.ndarray)
   assert ub is None or isinstance(ub,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   assert sp is None or isinstance(sp,numpy.ndarray)
   self._cardinal_flag = False
   self._shape = dims
   self._sparsity = None
   (self._scalable) = scalable
   (self._ub) = ub
   (self._lb) = lb
   (self._sparsity) = sp
   (self._empty) = False
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   self._cardinal_flag = (other._cardinal_flag)
   self._sparsity = (other._sparsity)
   self._scalable = (other._scalable)
   self._shape = (other._shape)
   self._ub = (other._ub)
   self._lb = (other._lb)
   self._empty = (other._empty)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricRangeDomain._ctor_Lmosek_4fusion_4RangeDomain_2(self))
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   (self._empty) = True
   (self._sparsity) = None
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  @staticmethod
  def _match_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _withShape_alt_III(self,_t__0,_t__1,_t__2):
    return self._withShape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _withShape_III(self,_0,_1,_2):
   self._shape = numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _withShape_alt_II(self,_t__0,_t__1):
    return self._withShape_II(numpy.int32(__0),numpy.int32(__1))
  def _withShape_II(self,_0,_1):
   self._shape = numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _withShape_alt_I(self,_t__0):
    return self._withShape_I(numpy.int32(__0))
  def _withShape_I(self,_0):
   self._shape = numpy.array([_0], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _withShape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._withShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withShape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self._shape = _0
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if self._scalable: # src/fusion/domain.mbi:932:17-25
    return (True)
   elif (int((self._shape).shape[0])!=int((_0).shape[0])): # src/fusion/domain.mbi:934:17-39
    return (False)
   else:
    for _1 in range(0,int((self._shape).shape[0])):
     if (self._shape[_1]!=_0[_1]): # src/fusion/domain.mbi:938:16-34
      return (False)
   return (True)
 return RangeDomain
mosek_fusion_RangeDomain=__mk_mosek_fusion_RangeDomain()
del __mk_mosek_fusion_RangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricRangeDomain():
 class SymmetricRangeDomain(mosek_fusion_RangeDomain):
  __slots__ = ['_dim']
  def __repr__(self): return 'mosek.fusion.SymmetricRangeDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = SymmetricRangeDomain.__new__(SymmetricRangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   mosek_fusion_RangeDomain._ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other)
   if ((self._shape is not None) and ((int((self._shape).shape[0])!=2) or (self._shape[0]!=self._shape[1]))): # src/fusion/domain.mbi:1023:13-1025:37
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape[0])
 return SymmetricRangeDomain
mosek_fusion_SymmetricRangeDomain=__mk_mosek_fusion_SymmetricRangeDomain()
del __mk_mosek_fusion_SymmetricRangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricLinearDomain():
 class SymmetricLinearDomain(object):
  __slots__ = ['_sparsity','_cardinal_flag','_key','_shape','_dom','_dim']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.SymmetricLinearDomain.sparse(array(int32,ndim=2))')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.integral()')
  def __repr__(self): return 'mosek.fusion.SymmetricLinearDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = SymmetricLinearDomain.__new__(SymmetricLinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   self._dom = other
   self._shape = (other._shape)
   self._key = (other._key)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparsity = (other._sparsity)
   if ((self._shape is not None) and ((int((self._shape).shape[0])!=2) or (self._shape[0]!=self._shape[1]))): # src/fusion/domain.mbi:781:13-783:36
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape[0])
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1]==self._shape[_1]): # src/fusion/domain.mbi:791:14-32
     return (False)
   return (True)
 return SymmetricLinearDomain
mosek_fusion_SymmetricLinearDomain=__mk_mosek_fusion_SymmetricLinearDomain()
del __mk_mosek_fusion_SymmetricLinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinearDomain():
 class LinearDomain(object):
  __slots__ = ['_empty','_scalable','_sparsity','_cardinal_flag','_key','_bnd','_shape']
  def withShape(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_withShape__3I(*args): # []int32
      return self._withShape__3I(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape__3I(*args): # []int32
      return self._withShape_alt__3I(*args)
    elif mosek_fusion_LinearDomain._match_withShape_I(*args): # int32
      return self._withShape_I(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_I(*args): # int32
      return self._withShape_alt_I(*args)
    elif mosek_fusion_LinearDomain._match_withShape_II(*args): # int32,int32
      return self._withShape_II(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_II(*args): # int32,int32
      return self._withShape_alt_II(*args)
    elif mosek_fusion_LinearDomain._match_withShape_III(*args): # int32,int32,int32
      return self._withShape_III(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_III(*args): # int32,int32,int32
      return self._withShape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.withShape(array(int32,ndim=1))\n\tmosek.fusion.LinearDomain.withShape(int32)\n\tmosek.fusion.LinearDomain.withShape(int32,int32)\n\tmosek.fusion.LinearDomain.withShape(int32,int32,int32)')
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    elif mosek_fusion_LinearDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_LinearDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.sparse()\n\tmosek.fusion.LinearDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.LinearDomain.sparse(array(int32,ndim=2))')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_LinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.integral()')
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_LinearDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.symmetric()')
  def __repr__(self): return 'mosek.fusion.LinearDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,rhs,dims):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,rhs,dims)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(*args):
    if len(args) != 4: return False
    k,scalable,rhs,dims, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match_Z__(scalable) and __arg_match__3D__(rhs) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(*args):
    if len(args) != 4: return False
    k,scalable,rhs,dims, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(self,k,scalable,rhs,dims):
    self._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(self,k,scalable,rhs,dims):
   assert rhs is None or isinstance(rhs,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   mosek_fusion_LinearDomain._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,None,1)
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,rhs,dims,sp,steal):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,rhs,dims,sp,steal)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    k,scalable,rhs,dims,sp,steal, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match_Z__(scalable) and __arg_match__3D__(rhs) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp) and __arg_match_I__(steal))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    k,scalable,rhs,dims,sp,steal, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp) and __arg_alt_match_I__(steal))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,sp,steal):
    self._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)),numpy.int32(steal))
  def _ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,sp,steal):
   assert rhs is None or isinstance(rhs,numpy.ndarray)
   assert dims is None or isinstance(dims,numpy.ndarray)
   assert sp is None or isinstance(sp,numpy.ndarray)
   (self._scalable) = scalable
   (self._shape) = dims
   (self._key) = k
   (self._bnd) = rhs
   (self._sparsity) = sp
   (self._cardinal_flag) = False
   (self._empty) = False
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   self._scalable = (other._scalable)
   self._shape = (other._shape)
   self._key = (other._key)
   self._bnd = (other._bnd)
   self._sparsity = (other._sparsity)
   self._cardinal_flag = (other._cardinal_flag)
   self._empty = (other._empty)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricLinearDomain._ctor_Lmosek_4fusion_4LinearDomain_2(self))
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   (self._empty) = False
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   (self._empty) = False
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   (self._empty) = True
   (self._sparsity) = None
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  @staticmethod
  def _match_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _withShape_alt_III(self,_t__0,_t__1,_t__2):
    return self._withShape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _withShape_III(self,_0,_1,_2):
   self._shape = numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _withShape_alt_II(self,_t__0,_t__1):
    return self._withShape_II(numpy.int32(__0),numpy.int32(__1))
  def _withShape_II(self,_0,_1):
   self._shape = numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _withShape_alt_I(self,_t__0):
    return self._withShape_I(numpy.int32(__0))
  def _withShape_I(self,_0):
   self._shape = numpy.array([_0], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _withShape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._withShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withShape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   self._shape = _0
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (not self._scalable): # src/fusion/domain.mbi:681:12-24
    for _1 in range(0,int((_0).shape[0])):
     if (_0[_1]==self._shape[_1]): # src/fusion/domain.mbi:683:16-34
      return (False)
   return (True)
 return LinearDomain
mosek_fusion_LinearDomain=__mk_mosek_fusion_LinearDomain()
del __mk_mosek_fusion_LinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_Domain():
 class Domain(object):
  @staticmethod
  def lessThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_alt_D(*args)
    elif mosek_fusion_Domain._match_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list lessThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1))\n\tmosek.fusion.Domain.lessThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.lessThan(array(double,ndim=2))\n\tmosek.fusion.Domain.lessThan(double)\n\tmosek.fusion.Domain.lessThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(double,int32)\n\tmosek.fusion.Domain.lessThan(double,int32,int32)')
  @staticmethod
  def symmetric(*args):
    if False: pass
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.symmetric(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.symmetric(mosek.fusion.RangeDomain)')
  @staticmethod
  def isTrilPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isTrilPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isTrilPSD()\n\tmosek.fusion.Domain.isTrilPSD(int32)\n\tmosek.fusion.Domain.isTrilPSD(int32,int32)')
  @staticmethod
  def inDExpCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inDExpCone_(*args): # 
      return mosek_fusion_Domain._inDExpCone_(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone_(*args): # 
      return mosek_fusion_Domain._inDExpCone_alt_(*args)
    elif mosek_fusion_Domain._match_inDExpCone_I(*args): # int32
      return mosek_fusion_Domain._inDExpCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone_I(*args): # int32
      return mosek_fusion_Domain._inDExpCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inDExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inDExpCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inDExpCone_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list inDExpCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDExpCone()\n\tmosek.fusion.Domain.inDExpCone(int32)\n\tmosek.fusion.Domain.inDExpCone(array(int32,ndim=1))')
  @staticmethod
  def integral(*args):
    if False: pass
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.integral(mosek.fusion.ConeDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.RangeDomain)')
  @staticmethod
  def inPExpCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPExpCone_(*args): # 
      return mosek_fusion_Domain._inPExpCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone_(*args): # 
      return mosek_fusion_Domain._inPExpCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPExpCone_I(*args): # int32
      return mosek_fusion_Domain._inPExpCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone_I(*args): # int32
      return mosek_fusion_Domain._inPExpCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inPExpCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inPExpCone_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list inPExpCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPExpCone()\n\tmosek.fusion.Domain.inPExpCone(int32)\n\tmosek.fusion.Domain.inPExpCone(array(int32,ndim=1))')
  @staticmethod
  def inRange(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_alt_DD(*args)
    elif mosek_fusion_Domain._match_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange__3D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange_alt__3D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange__3DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange_alt__3DD(*args)
    elif mosek_fusion_Domain._match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_alt_D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3_5D_3_5D(*args): # [,]double,[,]double
      return mosek_fusion_Domain._inRange__3_5D_3_5D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3_5D_3_5D(*args): # [,]double,[,]double
      return mosek_fusion_Domain._inRange_alt__3_5D_3_5D(*args)
    elif mosek_fusion_Domain._match_inRange_DD_3I(*args): # double,double,[]int32
      return mosek_fusion_Domain._inRange_DD_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD_3I(*args): # double,double,[]int32
      return mosek_fusion_Domain._inRange_alt_DD_3I(*args)
    elif mosek_fusion_Domain._match_inRange__3D_3D_3I(*args): # []double,[]double,[]int32
      return mosek_fusion_Domain._inRange__3D_3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D_3I(*args): # []double,[]double,[]int32
      return mosek_fusion_Domain._inRange_alt__3D_3D_3I(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D_3I(*args): # double,[]double,[]int32
      return mosek_fusion_Domain._inRange_D_3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D_3I(*args): # double,[]double,[]int32
      return mosek_fusion_Domain._inRange_alt_D_3D_3I(*args)
    elif mosek_fusion_Domain._match_inRange__3DD_3I(*args): # []double,double,[]int32
      return mosek_fusion_Domain._inRange__3DD_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD_3I(*args): # []double,double,[]int32
      return mosek_fusion_Domain._inRange_alt__3DD_3I(*args)
    else:
      raise ValueError('Invalid argument list inRange('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRange(double,double)\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double)\n\tmosek.fusion.Domain.inRange(mosek.fusion.Matrix,mosek.fusion.Matrix)\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=2),array(double,ndim=2))\n\tmosek.fusion.Domain.inRange(double,double,array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double,array(int32,ndim=1))')
  @staticmethod
  def isLinPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isLinPSD_(*args): # 
      return mosek_fusion_Domain._isLinPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_(*args): # 
      return mosek_fusion_Domain._isLinPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isLinPSD_I(*args): # int32
      return mosek_fusion_Domain._isLinPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_I(*args): # int32
      return mosek_fusion_Domain._isLinPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isLinPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isLinPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isLinPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isLinPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isLinPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isLinPSD()\n\tmosek.fusion.Domain.isLinPSD(int32)\n\tmosek.fusion.Domain.isLinPSD(int32,int32)')
  @staticmethod
  def inPSDCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inPSDCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPSDCone()\n\tmosek.fusion.Domain.inPSDCone(int32)\n\tmosek.fusion.Domain.inPSDCone(int32,int32)')
  @staticmethod
  def inDPowerCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inDPowerCone_D(*args): # double
      return mosek_fusion_Domain._inDPowerCone_D(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_D(*args): # double
      return mosek_fusion_Domain._inDPowerCone_alt_D(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inDPowerCone_DI(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inDPowerCone_alt_DI(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inDPowerCone_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inDPowerCone_alt_D_3I(*args)
    else:
      raise ValueError('Invalid argument list inDPowerCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDPowerCone(double)\n\tmosek.fusion.Domain.inDPowerCone(double,int32)\n\tmosek.fusion.Domain.inDPowerCone(double,array(int32,ndim=1))')
  @staticmethod
  def inPPowerCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPPowerCone_D(*args): # double
      return mosek_fusion_Domain._inPPowerCone_D(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_D(*args): # double
      return mosek_fusion_Domain._inPPowerCone_alt_D(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inPPowerCone_DI(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inPPowerCone_alt_DI(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inPPowerCone_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inPPowerCone_alt_D_3I(*args)
    else:
      raise ValueError('Invalid argument list inPPowerCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPPowerCone(double)\n\tmosek.fusion.Domain.inPPowerCone(double,int32)\n\tmosek.fusion.Domain.inPPowerCone(double,array(int32,ndim=1))')
  @staticmethod
  def equalsTo(*args):
    if False: pass
    elif mosek_fusion_Domain._match_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo__3D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo_alt__3D(*args)
    elif mosek_fusion_Domain._match_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_alt_D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_DI(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_alt_DI(*args)
    elif mosek_fusion_Domain._match_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_DII(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list equalsTo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1))\n\tmosek.fusion.Domain.equalsTo(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=2))\n\tmosek.fusion.Domain.equalsTo(double)\n\tmosek.fusion.Domain.equalsTo(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(double,int32)\n\tmosek.fusion.Domain.equalsTo(double,int32,int32)')
  @staticmethod
  def greaterThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_alt_D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list greaterThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1))\n\tmosek.fusion.Domain.greaterThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=2))\n\tmosek.fusion.Domain.greaterThan(double)\n\tmosek.fusion.Domain.greaterThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(double,int32)\n\tmosek.fusion.Domain.greaterThan(double,int32,int32)')
  @staticmethod
  def inRotatedQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inRotatedQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRotatedQCone()\n\tmosek.fusion.Domain.inRotatedQCone(int32)\n\tmosek.fusion.Domain.inRotatedQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inRotatedQCone(int32,int32)')
  @staticmethod
  def unbounded(*args):
    if False: pass
    elif mosek_fusion_Domain._match_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_alt_(*args)
    elif mosek_fusion_Domain._match_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_alt_I(*args)
    elif mosek_fusion_Domain._match_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded__3I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded_alt__3I(*args)
    elif mosek_fusion_Domain._match_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_II(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_alt_II(*args)
    else:
      raise ValueError('Invalid argument list unbounded('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.unbounded()\n\tmosek.fusion.Domain.unbounded(int32)\n\tmosek.fusion.Domain.unbounded(array(int32,ndim=1))\n\tmosek.fusion.Domain.unbounded(int32,int32)')
  @staticmethod
  def axis(*args):
    if False: pass
    elif mosek_fusion_Domain._match_axis_Lmosek_4fusion_4ConeDomain_2I(*args): # mosek.fusion.ConeDomain,int32
      return mosek_fusion_Domain._axis_Lmosek_4fusion_4ConeDomain_2I(*args)
    elif mosek_fusion_Domain._match_alt_axis_Lmosek_4fusion_4ConeDomain_2I(*args): # mosek.fusion.ConeDomain,int32
      return mosek_fusion_Domain._axis_alt_Lmosek_4fusion_4ConeDomain_2I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.axis(mosek.fusion.ConeDomain,int32)')
  @staticmethod
  def inQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inQCone()\n\tmosek.fusion.Domain.inQCone(int32)\n\tmosek.fusion.Domain.inQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inQCone(int32,int32)')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args): # mosek.fusion.LinearDomain,[]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args): # mosek.fusion.LinearDomain,[]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args): # mosek.fusion.LinearDomain,[,]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args): # mosek.fusion.LinearDomain,[,]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args): # mosek.fusion.RangeDomain,[]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args): # mosek.fusion.RangeDomain,[]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args): # mosek.fusion.RangeDomain,[,]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args): # mosek.fusion.RangeDomain,[,]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2_3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=1))\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=2))\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=1))\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=2))')
  @staticmethod
  def binary(*args):
    if False: pass
    elif mosek_fusion_Domain._match_binary_(*args): # 
      return mosek_fusion_Domain._binary_(*args)
    elif mosek_fusion_Domain._match_alt_binary_(*args): # 
      return mosek_fusion_Domain._binary_alt_(*args)
    elif mosek_fusion_Domain._match_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary__3I(*args)
    elif mosek_fusion_Domain._match_alt_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary_alt__3I(*args)
    elif mosek_fusion_Domain._match_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_I(*args)
    elif mosek_fusion_Domain._match_alt_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_alt_I(*args)
    elif mosek_fusion_Domain._match_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_II(*args)
    elif mosek_fusion_Domain._match_alt_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_alt_II(*args)
    else:
      raise ValueError('Invalid argument list binary('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.binary()\n\tmosek.fusion.Domain.binary(array(int32,ndim=1))\n\tmosek.fusion.Domain.binary(int32)\n\tmosek.fusion.Domain.binary(int32,int32)')
  def __repr__(self): return 'mosek.fusion.Domain'
  @staticmethod
  def __dimsize_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__dimsize__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dimsize__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   _1 = fragments._c_closure_292(_0,_1) # src/fusion/domain.mbi:595:72-113
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def __mkRangedDomain_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain.__mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def __mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if (((_0._dimi)!=(_1._dimi)) or ((_0._dimj)!=(_1._dimj))): # src/fusion/domain.mbi:477:12-52
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions in domain")
   if (_0._isSparse_() and _1._isSparse_()): # src/fusion/domain.mbi:480:12-43
    _2=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _7=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _0._getDataAsTriplets__3I_3I_3D(_2,_3,_4)
    _1._getDataAsTriplets__3I_3I_3D(_5,_6,_7)
    _8=0
    _8 = fragments._c_closure_293(_2,_3,_8,_5,_6) # src/fusion/domain.mbi:491:10-506:11
    _8 = numpy.int64(_8) # postprocess
    _9=numpy.zeros((_8,2,), dtype=numpy.dtype(numpy.int32))
    _10=numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    _11=numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_294(_9,_10,_2,_3,_4,_11,_5,_6,_7) # src/fusion/domain.mbi:511:10-552:11
    return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_10,_11,numpy.array([(_0._dimi),(_0._dimj)], dtype=numpy.dtype(numpy.int32)),_9,1))
   else:
    _12=(_0._dimj)
    _13=(_0._dimi)
    _14=(_13 * _12)
    if _0._isSparse_(): # src/fusion/domain.mbi:563:14-27
     _15 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
     _17=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _18=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _19=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
     _0._getDataAsTriplets__3I_3I_3D(_17,_18,_19)
     fragments._c_closure_295(_12,_15,_17,_18,_19) # src/fusion/domain.mbi:570:12-571:48
    else:
     _15 = _0._getDataAsArray_()
    if _1._isSparse_(): # src/fusion/domain.mbi:577:14-27
     _16 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
     _20=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _21=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _22=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
     _1._getDataAsTriplets__3I_3I_3D(_20,_21,_22)
     fragments._c_closure_296(_12,_20,_21,_16,_22) # src/fusion/domain.mbi:584:12-585:48
    else:
     _16 = _1._getDataAsArray_()
    return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_15,_16,numpy.array([(_0._dimi),(_0._dimj)], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __mkRangedDomain_alt__3_5D_3_5D(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain.__mkRangedDomain__3_5D_3_5D(_0,_1)
   return _1
  @staticmethod
  def __mkRangedDomain__3_5D_3_5D(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[1])!=int((_1).shape[1]))): # src/fusion/domain.mbi:456:12-60
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions in domain")
   _2=int((_0).shape[1])
   _3=int((_0).shape[0])
   _4=(_3 * _2)
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _7=0
   _7 = fragments._c_closure_297(_3,_2,_7,_0,_5,_1,_6) # src/fusion/domain.mbi:465:8-470:11
   _7 = numpy.int32(_7) # postprocess
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_5,_6,numpy.array([_3,_2], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(__0,_1)
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if _1._isSparse_(): # src/fusion/domain.mbi:437:12-25
    _2=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _1._getDataAsTriplets__3I_3I_3D(_2,_3,_4)
    _5=numpy.zeros((int((_2).shape[0]),2,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_298(_5,_2,_3) # src/fusion/domain.mbi:444:10-447:11
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(_0,False,_4,numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32)),_5,1))
   else:
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(_0,False,_1._getDataAsArray_(),numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __prod_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__prod__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __prod__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   _1 = fragments._c_closure_299(_0,_1) # src/fusion/domain.mbi:433:71-109
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def __inRange_alt_Z_3D_3D_3_5I_3I(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,ndmin=_monty.checkShape(_t__3,2),dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__inRange_Z_3D_3D_3_5I_3I(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inRange_Z_3D_3D_3_5I_3I(_0,_1,_2,_3,_4):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if ((not _0) and (int((_1).shape[0])!=int((_2).shape[0]))): # src/fusion/domain.mbi:418:12-47
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper and lower bounds.")
   if ((_3 is not None) and (int((_3).shape[0])!=int((_1).shape[0]))): # src/fusion/domain.mbi:420:12-47
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper/lower bounds and sparsity.")
   for _5 in range(0,int((_2).shape[0])):
    if (_1[_5] > _2[_5]): # src/fusion/domain.mbi:424:14-27
     raise mosek_fusion_DomainError._ctor_S("Invalid range specified")
   if ((_4 is not None) and (mosek.fusion.Domain.__dimsize__3I(_4)!=int((_1).shape[0]))): # src/fusion/domain.mbi:427:12-53
    raise mosek_fusion_LengthError._ctor_S("Mismatching dimensions.")
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(_0,_1,_2,_4)._sparse__3_5I(_3))
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._symmetric_())
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._symmetric_())
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2_3_5I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(_0,_1)
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0._sparse__3_5I(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0._sparse__3I(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2_3_5I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(_0,_1)
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0._sparse__3_5I(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (_0._sparse__3I(_1))
  @staticmethod
  def _match_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4ConeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4ConeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4ConeDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _axis_alt_Lmosek_4fusion_4ConeDomain_2I(_t__0,_t__1):
    return mosek_fusion_Domain._axis_Lmosek_4fusion_4ConeDomain_2I(_0,numpy.int32(__1))
  @staticmethod
  def _axis_Lmosek_4fusion_4ConeDomain_2I(_0,_1):
   return (_0._axis_I(_1))
  @staticmethod
  def _match_inDPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_inDPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _inDPowerCone_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inDPowerCone_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDPowerCone_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InDPowCone,_0,numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inDPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inDPowerCone_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._inDPowerCone_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _inDPowerCone_DI(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InDPowCone,_0,numpy.array([_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_inDPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _inDPowerCone_alt_D(_t__0):
    return mosek_fusion_Domain._inDPowerCone_D(numpy.float64(__0))
  @staticmethod
  def _inDPowerCone_D(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InDPowCone,_0,None))
  @staticmethod
  def _match_inPPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_inPPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _inPPowerCone_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inPPowerCone_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPPowerCone_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InPPowCone,_0,numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPPowerCone_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._inPPowerCone_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _inPPowerCone_DI(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InPPowCone,_0,numpy.array([_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_inPPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _inPPowerCone_alt_D(_t__0):
    return mosek_fusion_Domain._inPPowerCone_D(numpy.float64(__0))
  @staticmethod
  def _inPPowerCone_D(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InPPowCone,_0,None))
  @staticmethod
  def _match_inDExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inDExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inDExpCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inDExpCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDExpCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inDExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inDExpCone_alt_I(_t__0):
    return mosek_fusion_Domain._inDExpCone_I(numpy.int32(__0))
  @staticmethod
  def _inDExpCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,numpy.array([_0,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inDExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inDExpCone_alt_():
    return mosek_fusion_Domain._inDExpCone_()
  @staticmethod
  def _inDExpCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,None))
  @staticmethod
  def _match_inPExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inPExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inPExpCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inPExpCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPExpCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPExpCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPExpCone_I(numpy.int32(__0))
  @staticmethod
  def _inPExpCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,numpy.array([_0,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPExpCone_alt_():
    return mosek_fusion_Domain._inPExpCone_()
  @staticmethod
  def _inPExpCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,None))
  @staticmethod
  def _match_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inRotatedQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRotatedQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRotatedQCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InRotatedQCone,0.0,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inRotatedQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inRotatedQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inRotatedQCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InRotatedQCone,0.0,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inRotatedQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inRotatedQCone_I(numpy.int32(__0))
  @staticmethod
  def _inRotatedQCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InRotatedQCone,0.0,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inRotatedQCone_alt_():
    return mosek_fusion_Domain._inRotatedQCone_()
  @staticmethod
  def _inRotatedQCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InRotatedQCone,0.0,None))
  @staticmethod
  def _match_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inQCone__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InQCone,0.0,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inQCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InQCone,0.0,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inQCone_I(numpy.int32(__0))
  @staticmethod
  def _inQCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InQCone,0.0,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inQCone_alt_():
    return mosek_fusion_Domain._inQCone_()
  @staticmethod
  def _inQCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2D_3I(mosek.fusion.QConeKey.InQCone,0.0,None))
  @staticmethod
  def _match_isLinPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isLinPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isLinPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isLinPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isLinPSD_II(_0,_1):
   return (mosek_fusion_LinPSDDomain._ctor__3I(mosek.fusion.Set._make_II(_1,((_0 * (_0 + 1)) // 2))))
  @staticmethod
  def _match_isLinPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isLinPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isLinPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isLinPSD_I(numpy.int32(__0))
  @staticmethod
  def _isLinPSD_I(_0):
   return (mosek_fusion_LinPSDDomain._ctor__3I(mosek.fusion.Set._make_I(((_0 * (_0 + 1)) // 2))))
  @staticmethod
  def _match_isLinPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isLinPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isLinPSD_alt_():
    return mosek_fusion_Domain._isLinPSD_()
  @staticmethod
  def _isLinPSD_():
   return (mosek_fusion_LinPSDDomain._ctor_())
  @staticmethod
  def _match_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isTrilPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isTrilPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isTrilPSD_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3III(mosek.fusion.PSDKey.IsTrilPSD,numpy.array([_1,_0,_0], dtype=numpy.dtype(numpy.int32)),1,2))
  @staticmethod
  def _match_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isTrilPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isTrilPSD_I(numpy.int32(__0))
  @staticmethod
  def _isTrilPSD_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3III(mosek.fusion.PSDKey.IsTrilPSD,numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32)),0,1))
  @staticmethod
  def _match_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isTrilPSD_alt_():
    return mosek_fusion_Domain._isTrilPSD_()
  @staticmethod
  def _isTrilPSD_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsTrilPSD))
  @staticmethod
  def _match_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPSDCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inPSDCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inPSDCone_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3I(mosek.fusion.PSDKey.IsSymPSD,numpy.array([_1,_0,_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPSDCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPSDCone_I(numpy.int32(__0))
  @staticmethod
  def _inPSDCone_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3I(mosek.fusion.PSDKey.IsSymPSD,numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPSDCone_alt_():
    return mosek_fusion_Domain._inPSDCone_()
  @staticmethod
  def _inPSDCone_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsSymPSD))
  @staticmethod
  def _match_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _binary_alt_():
    return mosek_fusion_Domain._binary_()
  @staticmethod
  def _binary_():
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),None)._integral_())
  @staticmethod
  def _match_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _binary_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._binary__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binary__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),_0)._integral_())
  @staticmethod
  def _match_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _binary_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._binary_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _binary_II(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _binary_alt_I(_t__0):
    return mosek_fusion_Domain._binary_I(numpy.int32(__0))
  @staticmethod
  def _binary_I(_0):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),numpy.array([_0], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Domain.__mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1))
  @staticmethod
  def _match_inRange__3_5D_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_inRange__3_5D_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _inRange_alt__3_5D_3_5D(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange__3_5D_3_5D(_0,_1)
   return _1
  @staticmethod
  def _inRange__3_5D_3_5D(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Domain.__mkRangedDomain__3_5D_3_5D(_0,_1))
  @staticmethod
  def _match_inRange__3D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3D__(_0) and __arg_match__3D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange__3D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt__3D_3D_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange__3D_3D_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3D_3D_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,_1,_2))
  @staticmethod
  def _match_inRange__3DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3D__(_0) and __arg_match_D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange__3DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt__3DD_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.float64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange__3DD_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3DD_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,numpy.array([_1 for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),_2))
  @staticmethod
  def _match_inRange_D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match__3D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange_D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt_D_3D_3I(_t__0,_t__1,_t__2):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange_D_3D_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_D_3D_3I(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([_0 for _3 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_1,_2))
  @staticmethod
  def _match_inRange_DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange_DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt_DD_3I(_t__0,_t__1,_t__2):
   _0=numpy.float64(_t__0)
   _1=numpy.float64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange_DD_3I(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_DD_3I(_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.float64)),_2))
  @staticmethod
  def _match_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt__3D_3D(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange__3D_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3D_3D(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,_1,numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt__3DD(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.float64(_t__1)
   _1 = mosek_fusion_Domain._inRange__3DD(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3DD(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,numpy.array([_1 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt_D_3D(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange_D_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_D_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([_0 for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_1,numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt_DD(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_DD(numpy.float64(__0),numpy.float64(__1))
  @staticmethod
  def _inRange_DD(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _greaterThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _greaterThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _greaterThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3_5D(_0)
   return _1
  @staticmethod
  def _greaterThan__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _greaterThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0 for _2 in range(0,mosek.fusion.Domain.__prod__3I(_1))], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _greaterThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._greaterThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _greaterThan_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0 for _3 in range(0,(_2 * _1))], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _greaterThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._greaterThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _greaterThan_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0 for _2 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _greaterThan_alt_D(_t__0):
    return mosek_fusion_Domain._greaterThan_D(numpy.float64(__0))
  @staticmethod
  def _greaterThan_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _lessThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _lessThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _lessThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3_5D(_0)
   return _1
  @staticmethod
  def _lessThan__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _lessThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _lessThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._lessThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _lessThan_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _lessThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._lessThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _lessThan_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _lessThan_alt_D(_t__0):
    return mosek_fusion_Domain._lessThan_D(numpy.float64(__0))
  @staticmethod
  def _lessThan_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _equalsTo_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _equalsTo_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _equalsTo_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3_5D(_0)
   return _1
  @staticmethod
  def _equalsTo__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _equalsTo_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo_D_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _equalsTo_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._equalsTo_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _equalsTo_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _equalsTo_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._equalsTo_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _equalsTo_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _equalsTo_alt_D(_t__0):
    return mosek_fusion_Domain._equalsTo_D(numpy.float64(__0))
  @staticmethod
  def _equalsTo_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _unbounded_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._unbounded__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _unbounded__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _unbounded_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._unbounded_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _unbounded_II(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _unbounded_alt_I(_t__0):
    return mosek_fusion_Domain._unbounded_I(numpy.int32(__0))
  @staticmethod
  def _unbounded_I(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _unbounded_alt_():
    return mosek_fusion_Domain._unbounded_()
  @staticmethod
  def _unbounded_():
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,True,None,None))
 return Domain
mosek_fusion_Domain=__mk_mosek_fusion_Domain()
del __mk_mosek_fusion_Domain
#BEFORE CLASS
def __mk_mosek_fusion_ExprCode():
 class ExprCode(object):
  @staticmethod
  def inplace_relocate(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_inplace_1relocate__3IIII(*args): # []int32,int32,int32,int32
      return mosek_fusion_ExprCode._inplace_1relocate__3IIII(*args)
    elif mosek_fusion_ExprCode._match_alt_inplace_1relocate__3IIII(*args): # []int32,int32,int32,int32
      return mosek_fusion_ExprCode._inplace_1relocate_alt__3IIII(*args)
    else:
      raise ValueError('Invalid argument list inplace_relocate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.inplace_relocate(array(int32,ndim=1),int32,int32,int32)')
  @staticmethod
  def emit_paramref(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1paramref__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1paramref__3III(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1paramref__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1paramref_alt__3III(*args)
    else:
      raise ValueError('Invalid argument list emit_paramref('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_paramref(array(int32,ndim=1),int32,int32)')
  @staticmethod
  def emit_add(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1add__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1add__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1add__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1add_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_add(array(int32,ndim=1),int32)')
  @staticmethod
  def emit_mul(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1mul__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1mul__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1mul__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1mul_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_mul(array(int32,ndim=1),int32)')
  @staticmethod
  def emit_sum(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1sum__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1sum__3III(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1sum__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1sum_alt__3III(*args)
    else:
      raise ValueError('Invalid argument list emit_sum('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_sum(array(int32,ndim=1),int32,int32)')
  @staticmethod
  def eval_add_list(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args): # []int32,[]int32,[]double,[]double,[]double,mosek.fusion.WorkStack
      return mosek_fusion_ExprCode._eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCode._match_alt_eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args): # []int32,[]int32,[]double,[]double,[]double,mosek.fusion.WorkStack
      return mosek_fusion_ExprCode._eval_1add_1list_alt__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCode._match_eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args): # []int32,[]int32,[]double,int32,[]double,[]double,mosek.fusion.WorkStack
      return mosek_fusion_ExprCode._eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCode._match_alt_eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args): # []int32,[]int32,[]double,int32,[]double,[]double,mosek.fusion.WorkStack
      return mosek_fusion_ExprCode._eval_1add_1list_alt__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_add_list('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.eval_add_list(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1),array(double,ndim=1),mosek.fusion.WorkStack)\n\tmosek.fusion.ExprCode.eval_add_list(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),int32,array(double,ndim=1),array(double,ndim=1),mosek.fusion.WorkStack)')
  @staticmethod
  def emit_inv(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1inv__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1inv__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1inv__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1inv_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_inv('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_inv(array(int32,ndim=1),int32)')
  @staticmethod
  def emit_neg(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1neg__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1neg__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1neg__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1neg_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_neg('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_neg(array(int32,ndim=1),int32)')
  @staticmethod
  def emit_nop(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1nop__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1nop__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1nop__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1nop_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_nop('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_nop(array(int32,ndim=1),int32)')
  @staticmethod
  def op2str(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_op2str_I(*args): # int32
      return mosek_fusion_ExprCode._op2str_I(*args)
    elif mosek_fusion_ExprCode._match_alt_op2str_I(*args): # int32
      return mosek_fusion_ExprCode._op2str_alt_I(*args)
    else:
      raise ValueError('Invalid argument list op2str('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.op2str(int32)')
  @staticmethod
  def emit_constref(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1constref__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1constref__3III(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1constref__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1constref_alt__3III(*args)
    else:
      raise ValueError('Invalid argument list emit_constref('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_constref(array(int32,ndim=1),int32,int32)')
  def __repr__(self): return 'mosek.fusion.ExprCode'
  @staticmethod
  def _match_inplace_1relocate__3IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_inplace_1relocate__3IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _inplace_1relocate_alt__3IIII(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _1 = mosek_fusion_ExprCode._inplace_1relocate__3IIII(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inplace_1relocate__3IIII(_0,_1,_2,_3):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   fragments._c_closure_300(_0,_3,_2) # src/fusion/Parameter.monty:3113:106-3118:7
  @staticmethod
  def _match_op2str_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_op2str_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _op2str_alt_I(_t__0):
    return mosek_fusion_ExprCode._op2str_I(numpy.int32(__0))
  @staticmethod
  def _op2str_I(_0):
   if (_0==0): # src/fusion/Parameter.monty:3101:16-32
    return ("NOP")
   elif (_0==1): # src/fusion/Parameter.monty:3102:16-34
    return ("PARAMREF")
   elif (_0==2): # src/fusion/Parameter.monty:3103:16-34
    return ("CONST")
   elif (_0==3): # src/fusion/Parameter.monty:3104:16-32
    return ("ADD")
   elif (_0==4): # src/fusion/Parameter.monty:3105:16-32
    return ("NEG")
   elif (_0==5): # src/fusion/Parameter.monty:3106:16-32
    return ("MUL")
   elif (_0==6): # src/fusion/Parameter.monty:3107:16-32
    return ("INV")
   elif (_0==8): # src/fusion/Parameter.monty:3108:16-32
    return ("SUM")
   else:
    return (mosek.fusion.Utils.StringBuffer()._a_S("?(")._a_I(_0)._a_S(")")._toString_())
  @staticmethod
  def _match_eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match__3D__(_5) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_6))
  @staticmethod
  def _match_alt_eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match__3D__(_5) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_6))
  @staticmethod
  def _eval_1add_1list_alt__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=_t__6
   _1 = mosek_fusion_ExprCode._eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,_3,_4,_5,_6):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   _7=_6._allocf64_I(int((_0).shape[0]))
   _8=0
   _9=(_6.f64)
   _8 = fragments._c_closure_301(_5,_0,_2,_3,_1,_7,_8,_4,_9) # src/fusion/Parameter.monty:3057:8-3095:9
   _8 = numpy.int32(_8) # postprocess
   _6._clear_()
  @staticmethod
  def _match_eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3) and __arg_match__3D__(_4) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_5))
  @staticmethod
  def _match_alt_eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_5))
  @staticmethod
  def _eval_1add_1list_alt__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprCode._eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   mosek.fusion.ExprCode._eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,0,_3,_4,_5)
  @staticmethod
  def _match_emit_1sum__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_emit_1sum__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _emit_1sum_alt__3III(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _1 = mosek_fusion_ExprCode._emit_1sum__3III(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1sum__3III(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _0[_1] = 8
   _0[(_1 + 1)] = _2
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1inv__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1inv__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1inv_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1inv__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1inv__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _0[_1] = 6
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1mul__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1mul__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1mul_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1mul__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1mul__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _0[_1] = 5
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1neg__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1neg__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1neg_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1neg__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1neg__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _0[_1] = 4
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1add__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1add__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1add_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1add__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1add__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _0[_1] = 3
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1constref__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_emit_1constref__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _emit_1constref_alt__3III(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _1 = mosek_fusion_ExprCode._emit_1constref__3III(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1constref__3III(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _0[_1] = 2
   _0[(_1 + 1)] = _2
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1paramref__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_emit_1paramref__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _emit_1paramref_alt__3III(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _1 = mosek_fusion_ExprCode._emit_1paramref__3III(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1paramref__3III(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _0[_1] = 1
   _0[(_1 + 1)] = _2
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1nop__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1nop__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1nop_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1nop__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1nop__3II(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _0[_1] = 0
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
 return ExprCode
mosek_fusion_ExprCode=__mk_mosek_fusion_ExprCode()
del __mk_mosek_fusion_ExprCode
#BEFORE CLASS
def __mk_mosek_fusion_Param():
 class Param(object):
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Param._match_repeat_Lmosek_4fusion_4Parameter_2II(*args): # mosek.fusion.Parameter,int32,int32
      return mosek_fusion_Param._repeat_Lmosek_4fusion_4Parameter_2II(*args)
    elif mosek_fusion_Param._match_alt_repeat_Lmosek_4fusion_4Parameter_2II(*args): # mosek.fusion.Parameter,int32,int32
      return mosek_fusion_Param._repeat_alt_Lmosek_4fusion_4Parameter_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.repeat(mosek.fusion.Parameter,int32,int32)')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Param._match_hstack__3Lmosek_4fusion_4Parameter_2(*args): # []mosek.fusion.Parameter
      return mosek_fusion_Param._hstack__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack__3Lmosek_4fusion_4Parameter_2(*args): # []mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_alt__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.hstack(array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.hstack(mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.hstack(mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Param._match_stack__3_3Lmosek_4fusion_4Parameter_2(*args): # [][]mosek.fusion.Parameter
      return mosek_fusion_Param._stack__3_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack__3_3Lmosek_4fusion_4Parameter_2(*args): # [][]mosek.fusion.Parameter
      return mosek_fusion_Param._stack_alt__3_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_I_3Lmosek_4fusion_4Parameter_2(*args): # int32,[]mosek.fusion.Parameter
      return mosek_fusion_Param._stack_I_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_I_3Lmosek_4fusion_4Parameter_2(*args): # int32,[]mosek.fusion.Parameter
      return mosek_fusion_Param._stack_alt_I_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # int32,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # int32,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # int32,mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # int32,mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.stack(array(array(mosek.fusion.Parameter,ndim=1),ndim=1))\n\tmosek.fusion.Param.stack(int32,array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.stack(int32,mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.stack(int32,mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Param._match_vstack__3Lmosek_4fusion_4Parameter_2(*args): # []mosek.fusion.Parameter
      return mosek_fusion_Param._vstack__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack__3Lmosek_4fusion_4Parameter_2(*args): # []mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_alt__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.vstack(array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.vstack(mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.vstack(mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  def __repr__(self): return 'mosek.fusion.Param'
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Parameter_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Parameter_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Parameter_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Param._repeat_Lmosek_4fusion_4Parameter_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Parameter_2II(_0,_1,_2):
   return (mosek.fusion.Param._stack_I_3Lmosek_4fusion_4Parameter_2(_2,numpy.array([_0 for _3 in range(0,_1)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_2) and __arg_match_Lmosek_4fusion_4Parameter_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2,_3):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_1,_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_1,_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Param._stack_I_3Lmosek_4fusion_4Parameter_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Parameter_2(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_1,_0))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Parameter_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Param._stack__3_3Lmosek_4fusion_4Parameter_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Parameter_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Param._vstack__3Lmosek_4fusion_4Parameter_2(numpy.array([mosek.fusion.Param._hstack__3Lmosek_4fusion_4Parameter_2(_0[_1]) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Parameter_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Param._hstack__3Lmosek_4fusion_4Parameter_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Parameter_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_0,1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Parameter_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Param._vstack__3Lmosek_4fusion_4Parameter_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Parameter_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_0,0))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Parameter_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Param._dstack__3Lmosek_4fusion_4Parameter_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Parameter_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_1 < 0): # src/fusion/Parameter.monty:2855:12-19
    raise mosek_fusion_IndexError._ctor_S("Invalid stacking dimension")
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _5=_0[0]._getND_()
   for _6 in range(1,int((_0).shape[0])):
    if (_5 < _0[_6]._getND_()): # src/fusion/Parameter.monty:2861:60-78
     _5 = _0[_6]._getND_()
   if (_1 < _5): # src/fusion/Parameter.monty:2862:12-21
    _7=0
    while ((_7 < int((_0).shape[0])) and (_5!=_0[_7]._getND_())):
     _7 += 1
    _4 = _0[_7]._getShape_()
    _8=0
    while ((_8 < int((_0).shape[0])) and (_5!=_0[_8]._getND_())):
     _8 += 1
    _4 = _0[_8]._getShape_()
   else:
    _4 = numpy.array([1 for _9 in range(0,(_1 + 1))], dtype=numpy.dtype(numpy.int32))
    _10=0
    while ((_10 < int((_0).shape[0])) and (_5!=_0[_10]._getND_())):
     _10 += 1
    _11=_0[_10]._getND_()
    _12=_0[_10]._getShape_()
    fragments._c_closure_302(_11,_4,_12) # src/fusion/Parameter.monty:2876:12-55
   _5 = int((_4).shape[0])
   _13=0
   _14=False
   for _15 in range(0,int((_0).shape[0])):
    _16=_0[_15]._getShape_()
    _3[_15] = mosek.fusion.Set._size__3I(_16)
    _14 = fragments._c_closure_303(_1,_14,_4,_16) # src/fusion/Parameter.monty:2886:12-2887:71
    _14,_13 = fragments._c_closure_304(_1,_14,_13,_2,_15,_5,_4,_16) # src/fusion/Parameter.monty:2888:12-2897:13
    _13 = numpy.int32(_13) # postprocess
   if _14: # src/fusion/Parameter.monty:2899:14-20
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions for stacking")
   _4[_1] = _13
   _17=numpy.array([_0[_18]._getNumNonzero_() for _18 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _19=0
   _19 = fragments._c_closure_305(_17,_19) # src/fusion/Parameter.monty:2905:22-65
   _19 = numpy.int32(_19) # postprocess
   _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int64))
   _21=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _22=1
   _22 = fragments._c_closure_306(_1,_22,_4) # src/fusion/Parameter.monty:2910:28-67
   _22 = numpy.int64(_22) # postprocess
   _23=_13
   _24=1
   _24 = fragments._c_closure_307(_1,_24,_5,_4) # src/fusion/Parameter.monty:2912:28-71
   _24 = numpy.int64(_24) # postprocess
   _25=0
   _26=0
   for _27 in range(0,int((_0).shape[0])):
    _28=_0[_27]._getNumNonzero_()
    _0[_27]._getSp__3JI(_20,_25)
    _0[_27]._getAllIndexes__3II(_21,_25)
    _26 = fragments._c_closure_308(_1,_24,_13,_2,_27,_3,_28,_25,_26,_20) # src/fusion/Parameter.monty:2921:12-2935:13
    _26 = numpy.int64(_26) # postprocess
    _25 += _28
   _29=_4[0]
   _29 = fragments._c_closure_309(_29,_5,_4) # src/fusion/Parameter.monty:2943:34-98
   _29 = numpy.int32(_29) # postprocess
   _30=numpy.zeros(((_29 + 1),), dtype=numpy.dtype(numpy.int32))
   _31=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _32=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _33=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
   _33[(_5 - 1)] = 1
   fragments._c_closure_310(_5,_4,_33) # src/fusion/Parameter.monty:2947:59-132
   fragments._c_closure_311(_31,_19) # src/fusion/Parameter.monty:2948:8-42
   for _34 in range(0,_5):
    _35=((_5 - _34) - 1)
    fragments._c_closure_312(_29,_30) # src/fusion/Parameter.monty:2951:10-48
    fragments._c_closure_313(_35,_30,_19,_4,_33,_20) # src/fusion/Parameter.monty:2952:10-73
    fragments._c_closure_314(_29,_30) # src/fusion/Parameter.monty:2953:10-54
    fragments._c_closure_315(_35,_31,_32,_30,_19,_4,_33,_20) # src/fusion/Parameter.monty:2954:10-124
    _36=_32
    _32 = _31
    _31 = _36
   _37=numpy.array([_20[_31[_38]] for _38 in range(0,_19)], dtype=numpy.dtype(numpy.int64))
   _39=numpy.array([_21[_31[_40]] for _40 in range(0,_19)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(_0[0]._getModel_(),_4,_37,_39))
 return Param
mosek_fusion_Param=__mk_mosek_fusion_Param()
del __mk_mosek_fusion_Param
#BEFORE CLASS
def __mk_mosek_fusion_ParameterImpl():
 class ParameterImpl(mosek_fusion_Parameter,object):
  __slots__ = ['_ParameterImpl__size','_ParameterImpl__nidxs','_ParameterImpl__sp','_ParameterImpl__shape','_ParameterImpl__model']
  def getValue(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getValue_(*args): # 
      return self._getValue_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getValue_(*args): # 
      return self._getValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list getValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getValue()')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.reshape(array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.toString()')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_clone_Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Model
      return self._clone_Lmosek_4fusion_4Model_2(*args)
    elif mosek_fusion_ParameterImpl._match_alt_clone_Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Model
      return self._clone_alt_Lmosek_4fusion_4Model_2(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.clone(mosek.fusion.Model)')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getSize()')
  def getAllIndexes(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getAllIndexes__3II(*args): # []int32,int32
      return self._getAllIndexes__3II(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getAllIndexes__3II(*args): # []int32,int32
      return self._getAllIndexes_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list getAllIndexes('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getAllIndexes(array(int32,ndim=1),int32)')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.asExpr()')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_ParameterImpl._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.pick(array(int32,ndim=1))\n\tmosek.fusion.ParameterImpl.pick(array(int32,ndim=2))')
  def getSp(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getSp__3JI(*args): # []int64,int32
      return self._getSp__3JI(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getSp__3JI(*args): # []int64,int32
      return self._getSp_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list getSp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getSp(array(int64,ndim=1),int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_ParameterImpl._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_ParameterImpl._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.slice(int32,int32)\n\tmosek.fusion.ParameterImpl.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getModel()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ParameterImpl._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getDim(int32)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getShape()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.isSparse()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getND()')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getIndex_I(*args): # int32
      return self._getIndex_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getIndex_I(*args): # int32
      return self._getIndex_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getIndex(int32)')
  def setValue(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_setValue_D(*args): # double
      return self._setValue_D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue_D(*args): # double
      return self._setValue_alt_D(*args)
    elif mosek_fusion_ParameterImpl._match_setValue__3D(*args): # []double
      return self._setValue__3D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue__3D(*args): # []double
      return self._setValue_alt__3D(*args)
    elif mosek_fusion_ParameterImpl._match_setValue__3_5D(*args): # [,]double
      return self._setValue__3_5D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue__3_5D(*args): # [,]double
      return self._setValue_alt__3_5D(*args)
    else:
      raise ValueError('Invalid argument list setValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.setValue(double)\n\tmosek.fusion.ParameterImpl.setValue(array(double,ndim=1))\n\tmosek.fusion.ParameterImpl.setValue(array(double,ndim=2))')
  def getNumNonzero(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getNumNonzero_(*args): # 
      return self._getNumNonzero_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getNumNonzero_(*args): # 
      return self._getNumNonzero_alt_(*args)
    else:
      raise ValueError('Invalid argument list getNumNonzero('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getNumNonzero()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_ParameterImpl._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.index(int32)\n\tmosek.fusion.ParameterImpl.index(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.ParameterImpl'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model):
    o = ParameterImpl.__new__(ParameterImpl)
    o._ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    other,model, = args
    return (__arg_match_Lmosek_4fusion_4ParameterImpl_2__(other) and __arg_match_Lmosek_4fusion_4Model_2__(model))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    other,model, = args
    return (__arg_alt_match_Lmosek_4fusion_4ParameterImpl_2__(other) and __arg_alt_match_Lmosek_4fusion_4Model_2__(model))
  def _ctor_alt_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,other,model):
    self._ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model)
  def _ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,other,model):
   (self.__model) = model
   (self.__shape) = (other.__shape)
   (self.__sp) = (other.__sp)
   (self.__size) = (other.__size)
   (self.__nidxs) = (other.__nidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(model,shape,sp,nidxs):
    o = ParameterImpl.__new__(ParameterImpl)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(model,shape,sp,nidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(*args):
    if len(args) != 4: return False
    model,shape,sp,nidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3J__(sp) and __arg_match__3I__(nidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(*args):
    if len(args) != 4: return False
    model,shape,sp,nidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sp) and __arg_alt_match__3I__(nidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3I(self,model,shape,sp,nidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int64)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(self,model,shape,sp,nidxs):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sp is None or isinstance(sp,numpy.ndarray)
   assert nidxs is None or isinstance(nidxs,numpy.ndarray)
   (self.__model) = model
   (self.__shape) = mosek.fusion.Utils.Tools._arraycopy__3I(shape)
   (self.__sp) = sp
   (self.__size) = mosek.fusion.Set._size__3I(shape)
   (self.__nidxs) = mosek.fusion.Utils.Tools._arraycopy__3I(nidxs)
  @staticmethod
  def _match_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0))
  @staticmethod
  def _match_alt_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("Parameter((")
   if (int((self.__shape).shape[0]) > 0): # src/fusion/Parameter.monty:399:12-26
    _0._a_I(self.__shape[0])
    for _1 in range(1,int((self.__shape).shape[0])):
     _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   if (self.__sp is not None): # src/fusion/Parameter.monty:405:12-22
    _0._a_S(",sparse")
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Not implemented")
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   raise mosek_fusion_UnimplementedError._ctor_S("Not implemented")
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((self.__shape).shape[0])!=int((_0).shape[0])): # src/fusion/Parameter.monty:361:12-38
    raise mosek_fusion_DimensionError._ctor_S("Index has incorrect dimension")
   else:
    for _1 in range(0,int((_0).shape[0])):
     if ((_0[_1] < 0) or (_0[_1] >= self.__shape[_1])): # src/fusion/Parameter.monty:365:16-56
      raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   if (self.__sp is None): # src/fusion/Parameter.monty:368:12-22
    _2=int((_0).shape[0])
    _3=_0[(_2 - 1)]
    _3 = fragments._c_closure_316(_0,_3,_2,self.__shape) # src/fusion/Parameter.monty:371:10-70
    _3 = numpy.int64(_3) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_3]], dtype=numpy.dtype(numpy.int32))))
   else:
    _4=int((_0).shape[0])
    _5=_0[(_4 - 1)]
    _5 = fragments._c_closure_317(_0,_5,_4,self.__shape) # src/fusion/Parameter.monty:378:10-70
    _5 = numpy.int64(_5) # postprocess
    _6=0
    _6 = fragments._c_closure_318(_5,_6,self.__sp) # src/fusion/Parameter.monty:380:21-60
    _6 = numpy.int32(_6) # postprocess
    if ((_6 < int((self.__sp).shape[0])) and (self.__sp[_6]==_5)): # src/fusion/Parameter.monty:381:14-41
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_6]], dtype=numpy.dtype(numpy.int32))))
    else:
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   if (int((self.__shape).shape[0])!=1): # src/fusion/Parameter.monty:343:12-27
    raise mosek_fusion_DimensionError._ctor_S("Index has incorrect dimension")
   elif ((_0 < 0) or (_0 >= self.__shape[0])): # src/fusion/Parameter.monty:345:16-38
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   if (self.__sp is None): # src/fusion/Parameter.monty:348:12-22
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_0]], dtype=numpy.dtype(numpy.int32))))
   else:
    _1=0
    _1 = fragments._c_closure_319(_0,_1,self.__sp) # src/fusion/Parameter.monty:352:21-59
    _1 = numpy.int32(_1) # postprocess
    if ((_1 < int((self.__sp).shape[0])) and (self.__sp[_1]==_0)): # src/fusion/Parameter.monty:353:14-40
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_1]], dtype=numpy.dtype(numpy.int32))))
    else:
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__shape).shape[0])
   _4=int((self.__nidxs).shape[0])
   _5=(self.__sp is not None)
   _0._alloc_1expr_IIIZI(_3,_4,int((self.__nidxs).shape[0]),_5,int((self.__nidxs).shape[0]))
   _6=(_0.i32)
   _7=(_0.i64)
   _8=(_0.f64)
   _9=(_0.ptr_base)
   _10=(_0.nidxs_base)
   _11=(_0.cof_base)
   _12=(_0.shape_base)
   _13=(_0.codeptr_base)
   _14=(_0.code_base)
   _15=(_0.cconst_base)
   _16=(_0.sp_base)
   fragments._c_closure_320(_5,_3,_4,self.__nidxs,_15,_14,_13,_11,_8,_6,_7,_10,_9,_12,_16,self.__shape,self.__sp) # src/fusion/Parameter.monty:323:8-338:9
  @staticmethod
  def _match_getSp__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_getSp__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1))
  def _getSp_alt__3JI(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _1 = self._getSp__3JI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getSp__3JI(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   fragments._c_closure_321(_0,self.__nidxs,_1,self.__sp) # src/fusion/Parameter.monty:291:59-298:7
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return ((self.__sp is not None))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((self.__shape).shape[0]))): # src/fusion/Parameter.monty:232:12-66
    raise mosek_fusion_DimensionError._ctor_S("Invalid index dimension")
   _2=int((_0).shape[0])
   for _3 in range(0,_2):
    if ((_0[_3] < 0) or ((_0[_3] >= _1[_3]) or (_1[_3] > self.__shape[_3]))): # src/fusion/Parameter.monty:236:14-75
     raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _4[(_2 - 1)] = 1
   fragments._c_closure_322(_2,self.__shape,_4) # src/fusion/Parameter.monty:238:53-114
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([(_1[_7] - _0[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   if (self.__sp is None): # src/fusion/Parameter.monty:242:12-22
    _8=1
    _8 = fragments._c_closure_323(_8,_2,_6) # src/fusion/Parameter.monty:243:25-64
    _8 = numpy.int32(_8) # postprocess
    _9=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
    _10=0
    _10 = fragments._c_closure_324(_0,_1,_5,_10,_2,self.__nidxs,_9,self.__shape,_4) # src/fusion/Parameter.monty:248:10-256:11
    _10 = numpy.int32(_10) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_6,None,_9))
   else:
    _11=0
    _11 = fragments._c_closure_325(_0,_1,_11,_5,_2,self.__nidxs,self.__shape,self.__sp,_4) # src/fusion/Parameter.monty:261:10-266:11
    _11 = numpy.int32(_11) # postprocess
    _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _14[(_2 - 1)] = 1
    fragments._c_closure_326(_2,_6,_14) # src/fusion/Parameter.monty:271:57-121
    _15=0
    _15 = fragments._c_closure_327(_0,_1,_5,_15,_2,self.__nidxs,_12,_13,_14,self.__shape,self.__sp,_4) # src/fusion/Parameter.monty:274:10-284:11
    _15 = numpy.int32(_15) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_6,_13,_12))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (int((self.__shape).shape[0])!=1): # src/fusion/Parameter.monty:205:12-27
    raise mosek_fusion_DimensionError._ctor_S("Invalid index dimension")
   if ((_0 < 0) or ((_1 >= _1) or (_1 > self.__size))): # src/fusion/Parameter.monty:207:12-52
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if (self.__sp is None): # src/fusion/Parameter.monty:210:12-22
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.array([0,(_1 - _0)], dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_2] for _2 in range(_0,_1)], dtype=numpy.dtype(numpy.int32))))
   else:
    _3=0
    _3 = fragments._c_closure_328(_3,self.__sp,_0,_1) # src/fusion/Parameter.monty:215:10-217:22
    _3 = numpy.int32(_3) # postprocess
    _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
    _6=0
    _6 = fragments._c_closure_329(_6,self.__nidxs,_4,_5,self.__sp,_0,_1) # src/fusion/Parameter.monty:221:10-226:13
    _6 = numpy.int32(_6) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.array([0,(_1 - _0)], dtype=numpy.dtype(numpy.int32)),_5,_4))
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (mosek.fusion.Set._size__3I(_0)!=mosek.fusion.Set._size__3I(self.__shape)): # src/fusion/Parameter.monty:199:12-45
    raise mosek_fusion_DimensionError._ctor_S("Incompatible shape for resize")
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_0,self.__sp,self.__nidxs))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(mosek.fusion.Set._size__3I(self.__shape))
  @staticmethod
  def _match_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  def _getNumNonzero_alt_(self,):
    return self._getNumNonzero_()
  def _getNumNonzero_(self,):
   return numpy.int32(int((self.__nidxs).shape[0]))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   return numpy.int32(self.__shape[_0])
  @staticmethod
  def _match_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  def _getAllIndexes_alt__3II(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = self._getAllIndexes__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getAllIndexes__3II(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   fragments._c_closure_330(_0,self.__nidxs,_1) # src/fusion/Parameter.monty:185:58-188:7
  @staticmethod
  def _match_getIndex_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getIndex_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getIndex_alt_I(self,_t__0):
    return self._getIndex_I(numpy.int32(__0))
  def _getIndex_I(self,_0):
   return numpy.int32(self.__nidxs[_0])
  @staticmethod
  def _match_getValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getValue_(*args):
    if len(args) != 0: return False
    return True
  def _getValue_alt_(self,):
    return self._getValue_()
  def _getValue_(self,):
   return (self.__model._getParameterValue__3I(self.__nidxs))
  @staticmethod
  def _match_setValue__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_setValue__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  def _setValue_alt__3_5D(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = self._setValue__3_5D(_0)
   return _1
  def _setValue__3_5D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((self._getND_()!=2) or ((int((_0).shape[0])!=self.__shape[0]) or (int((_0).shape[1])!=self.__shape[1]))): # src/fusion/Parameter.monty:156:12-84
    raise mosek_fusion_LengthError._ctor_S("Mismatching value shape")
   if (self.__sp is None): # src/fusion/Parameter.monty:159:12-22
    _1=numpy.zeros(((self.__shape[0] * self.__shape[1]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_331(self.__shape,_1,_0) # src/fusion/Parameter.monty:161:10-163:48
    self.__model._setParameterValue__3I_3D(self.__nidxs,_1)
   else:
    _2=numpy.zeros((int((self.__sp).shape[0]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_332(self.__shape,self.__sp,_2,_0) # src/fusion/Parameter.monty:168:10-170:11
    self.__model._setParameterValue__3I_3D(self.__nidxs,_2)
  @staticmethod
  def _match_setValue__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setValue__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setValue_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setValue__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setValue__3D(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (self.__sp is None): # src/fusion/Parameter.monty:137:12-22
    if (int((_0).shape[0])!=int((self.__nidxs).shape[0])): # src/fusion/Parameter.monty:138:14-39
     raise mosek_fusion_LengthError._ctor_S("Length of value array is incorrect")
    else:
     self.__model._setParameterValue__3I_3D(self.__nidxs,_0)
   else:
    if (int((_0).shape[0])!=self._getSize_()): # src/fusion/Parameter.monty:144:14-38
     raise mosek_fusion_LengthError._ctor_S("Length of value array is incorrect")
    else:
     _1=numpy.zeros((int((self.__nidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_333(_1,self.__nidxs,self.__sp,_0) # src/fusion/Parameter.monty:148:12-149:39
     self.__model._setParameterValue__3I_3D(self.__nidxs,_1)
  @staticmethod
  def _match_setValue_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_setValue_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _setValue_alt_D(self,_t__0):
    return self._setValue_D(numpy.float64(__0))
  def _setValue_D(self,_0):
   _1=numpy.zeros((self.__size,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_334(self.__size,_1,_0) # src/fusion/Parameter.monty:131:8-132:26
   self.__model._setParameterValue__3I_3D(self.__nidxs,_1)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
 return ParameterImpl
mosek_fusion_ParameterImpl=__mk_mosek_fusion_ParameterImpl()
del __mk_mosek_fusion_ParameterImpl
#BEFORE CLASS
def __mk_mosek_fusion_BaseExpression():
 class BaseExpression(mosek_fusion_Expression,object):
  __slots__ = ['_BaseExpression__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args): # []int32
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):# []int32
      self._ctor_alt_init__3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseExpression.ctor(array(int32,ndim=1))')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_BaseExpression._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getDim(int32)')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseExpression._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseExpression._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseExpression.pick(array(int32,ndim=2))')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getND()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BaseExpression._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseExpression._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.index(int32)\n\tmosek.fusion.BaseExpression.index(array(int32,ndim=1))')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getSize()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_BaseExpression._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_BaseExpression._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.toString()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BaseExpression._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseExpression._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.slice(int32,int32)\n\tmosek.fusion.BaseExpression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getShape()')
  def __repr__(self): return 'mosek.fusion.BaseExpression'
  @staticmethod
  def _ctor__3I(shape):
    o = BaseExpression.__new__(BaseExpression)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   assert shape is None or isinstance(shape,numpy.ndarray)
   (self.__shape) = shape
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("Expression()")
  def _printStack_alt_Lmosek_4fusion_4WorkStack_2(self,_t__0):
    return self._printStack_Lmosek_4fusion_4WorkStack_2(_0)
  def _printStack_Lmosek_4fusion_4WorkStack_2(self,_0):
   _1=(_0.i32)
   _2=(_0.i64)
   _3=(_0.f64)
   _4=(_0.ptr_base)
   _5=(_0.nidxs_base)
   _6=(_0.cof_base)
   _7=(_0.shape_base)
   _8=(_0.codeptr_base)
   _9=(_0.code_base)
   _10=(_0.cconst_base)
   _11=(_0.sp_base)
   _12=(_0.nelem)
   _13=(_0.nnz)
   _14=(_0.ncodeatom)
   _15=(_0.nd)
   _16=(_0.hassp)
   mosek.fusion.Debug._o_()._p_S("### ")._p_S(self._toString_())._p_S(" ###")._lf_()._p_S("  nelem     = ")._p_I(_12)._lf_()._p_S("  nnz       = ")._p_I(_13)._lf_()._p_S("  hassp     = ")._p_Z(_16)._p_S(" / ")._p_I(_1[(((_0.pi32) - _15) - 4)])._lf_()._p_S("  shape     = ")._p__3I(numpy.array([_1[(_7 + _17)] for _17 in range(0,_15)], dtype=numpy.dtype(numpy.int32)))._lf_()._p_S("  ptr       = ")._p__3I(numpy.array([_1[(_4 + _18)] for _18 in range(0,(_12 + 1))], dtype=numpy.dtype(numpy.int32)))._lf_()
   if (_0.hassp): # src/fusion/BaseExpression.monty:463:12-20
    mosek.fusion.Debug._o_()._p_S("  sp       = ")._p__3J(numpy.array([_2[(_11 + _19)] for _19 in range(0,_12)], dtype=numpy.dtype(numpy.int64)))._lf_()
   for _20 in range(0,_12):
    mosek.fusion.Debug._o_()._p_S("  row[")._p_I(_20)._p_S("]")._lf_()
    mosek.fusion.Debug._o_()._p_S("    nidx : ")._p__3J(numpy.array([_2[(_5 + _21)] for _21 in range(_1[(_4 + _20)],_1[((_4 + _20) + 1)])], dtype=numpy.dtype(numpy.int64)))._lf_()._p_S("    cof  : ")._p__3D(numpy.array([_3[(_6 + _22)] for _22 in range(_1[(_4 + _20)],_1[((_4 + _20) + 1)])], dtype=numpy.dtype(numpy.float64)))._lf_()
    if (_14 > 0): # src/fusion/BaseExpression.monty:473:14-28
     for _23 in range(_1[(_4 + _20)],_1[((_4 + _20) + 1)]):
      mosek.fusion.Debug._o_()._p_S("      code[")._p_J(_2[(_5 + _23)])._p_S("] ")._p__3I(numpy.array([_1[(_9 + _24)] for _24 in range(_1[(_8 + _23)],_1[((_8 + _23) + 1)])], dtype=numpy.dtype(numpy.int32)))._p__3D(numpy.array([_3[(_10 + _25)] for _25 in range(_1[(_8 + _23)],_1[((_8 + _23) + 1)])], dtype=numpy.dtype(numpy.float64)))._lf_()
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_0))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_335(_1,_0) # src/fusion/BaseExpression.monty:427:45-98
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=numpy.zeros((1,int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_336(_1,_0) # src/fusion/BaseExpression.monty:423:45-98
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   _1=numpy.zeros((1,1,), dtype=numpy.dtype(numpy.int32))
   _1[0,0] = _0
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprSlice._ctor_Lmosek_4fusion_4Expression_2_3I_3I(self,_0,_1))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_ExprSlice._ctor_Lmosek_4fusion_4Expression_2_3I_3I(self,numpy.array([_0], dtype=numpy.dtype(numpy.int32)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(mosek.fusion.Set._size__3I(self.__shape))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   return numpy.int32(self.__shape[_0])
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
 return BaseExpression
mosek_fusion_BaseExpression=__mk_mosek_fusion_BaseExpression()
del __mk_mosek_fusion_BaseExpression
#BEFORE CLASS
def __mk_mosek_fusion_ExprParameter():
 class ExprParameter(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprParameter__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter
      self._ctor_init_Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2(*args):# mosek.fusion.Parameter
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprParameter.ctor(mosek.fusion.Parameter)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprParameter._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprParameter._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_ExprParameter._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_ExprParameter._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_ExprParameter._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ExprParameter._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.slice(int32,int32)\n\tmosek.fusion.ExprParameter.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprParameter._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprParameter._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.toString()')
  def __repr__(self): return 'mosek.fusion.ExprParameter'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2(p):
    o = ExprParameter.__new__(ExprParameter)
    o._ctor_init_Lmosek_4fusion_4Parameter_2(p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    p, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2(self,p):
    self._ctor_init_Lmosek_4fusion_4Parameter_2(p)
  def _ctor_init_Lmosek_4fusion_4Parameter_2(self,p):
   mosek_fusion_BaseExpression._ctor_init__3I(self,p._getShape_())
   (self.__p) = p
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__p._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self.__p._slice__3I_3I(_0,_1)))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self.__p._slice_II(_0,_1)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprParameter(")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprParameter
mosek_fusion_ExprParameter=__mk_mosek_fusion_ExprParameter()
del __mk_mosek_fusion_ExprParameter
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamScalarExpr():
 class ExprMulParamScalarExpr(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamScalarExpr__e','_ExprMulParamScalarExpr__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamScalarExpr.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamScalarExpr._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamScalarExpr._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalarExpr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamScalarExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamScalarExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalarExpr.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamScalarExpr'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamScalarExpr.__new__(ExprMulParamScalarExpr)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,p._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (e._getND_()!=0): # src/fusion/Parameter.monty:2629:12-26
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   if (_6!=0): # src/fusion/Parameter.monty:2644:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.sp_base)
   _13=(_1.nidxs_base)
   _14=(_1.cof_base)
   _15=(_1.cconst_base)
   _16=(_1.codeptr_base)
   _17=(_1.code_base)
   _18=self.__p._getND_()
   _19=self.__p._getNumNonzero_()
   _20=(_8 * self.__p._getNumNonzero_())
   _21=(self.__p._getNumNonzero_() < self.__p._getSize_())
   _22=((_11 + (_20 * 4)) if ((_11 > 0) ) else (_20 * 3))
   _23=_2._alloci32_I(self.__p._getNumNonzero_())
   _24=(_2.i32)
   self.__p._getAllIndexes__3II(_24,_23)
   _0._alloc_1expr_IIIZI(_18,_19,_20,_21,_22)
   _25=(_0.i64)
   _26=(_0.f64)
   _27=(_0.i32)
   _28=(_0.ptr_base)
   _29=(_0.nidxs_base)
   _30=(_0.sp_base)
   _31=(_0.cof_base)
   _32=(_0.hassp)
   _33=(_0.shape_base)
   _34=(_0.codeptr_base)
   _35=(_0.code_base)
   _36=(_0.cconst_base)
   fragments._c_closure_337(_31,_26,_20) # src/fusion/Parameter.monty:2690:10-56
   fragments._c_closure_338(_8,_27,_19,_28) # src/fusion/Parameter.monty:2691:10-57
   for _37 in range(0,_18):
    _27[(_33 + _37)] = self.__p._getDim_I(_37)
   if _32: # src/fusion/Parameter.monty:2694:14-20
    self.__p._getSp__3JI(_25,_30)
   fragments._c_closure_339(_25,_29,_20) # src/fusion/Parameter.monty:2697:10-54
   fragments._c_closure_340(_13,_8,_25,_19,_29,_4) # src/fusion/Parameter.monty:2698:10-2705:11
   if (_22 > 0): # src/fusion/Parameter.monty:2707:14-28
    _27[_34] = 0
   fragments._c_closure_341(_15,_17,_14,_11,_8,_23,_16,_36,_35,_34,_26,_27,_19,_5,_3,_24) # src/fusion/Parameter.monty:2710:10-2762:11
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamScalarExpr(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamScalarExpr
mosek_fusion_ExprMulParamScalarExpr=__mk_mosek_fusion_ExprMulParamScalarExpr()
del __mk_mosek_fusion_ExprMulParamScalarExpr
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamScalar():
 class ExprMulParamScalar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamScalar__e','_ExprMulParamScalar__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamScalar.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamScalar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamScalar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamScalar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamScalar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamScalar'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamScalar.__new__(ExprMulParamScalar)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=0): # src/fusion/Parameter.monty:2503:12-26
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   _19=_6
   _20=_7
   _21=_8
   _22=(self.__p._getNumNonzero_() < self.__p._getSize_())
   _23=((_8 * 3) if ((_11==0) ) else ((_8 * 4) + _11))
   _0._alloc_1expr_IIIZI(_19,_20,_21,_22,_23)
   _24=(_0.i64)
   _25=(_0.f64)
   _26=(_0.i32)
   _27=(_0.ptr_base)
   _28=(_0.nidxs_base)
   _29=(_0.sp_base)
   _30=(_0.cof_base)
   _31=(_0.hassp)
   _32=(_0.shape_base)
   _33=(_0.codeptr_base)
   _34=(_0.code_base)
   _35=(_0.cconst_base)
   _36=self.__p._getIndex_I(0)
   fragments._c_closure_342(_16,_18,_15,_11,_14,_8,_36,_10,_17,_35,_34,_33,_30,_25,_31,_26,_24,_23,_19,_20,_28,_21,_27,_32,_29,_12,_13,_5,_3,_4) # src/fusion/Parameter.monty:2568:8-2614:9
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamScalar(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamScalar
mosek_fusion_ExprMulParamScalar=__mk_mosek_fusion_ExprMulParamScalar()
del __mk_mosek_fusion_ExprMulParamScalar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamDiagLeft():
 class ExprMulParamDiagLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamDiagLeft__e','_ExprMulParamDiagLeft__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamDiagLeft.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamDiagLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamDiagLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamDiagLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamDiagLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamDiagLeft'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamDiagLeft.__new__(ExprMulParamDiagLeft)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([e._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)): # src/fusion/Parameter.monty:2134:12-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if ((p._getDim_I(1)!=e._getDim_I(0)) or (p._getDim_I(0)!=e._getDim_I(1))): # src/fusion/Parameter.monty:2136:12-2137:38
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   if ((_6!=2) or ((_3[_12]!=self.__p._getDim_I(1)) or (_3[(_12 + 1)]!=self.__p._getDim_I(0)))): # src/fusion/Parameter.monty:2164:12-81
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   _19=self.__p._getNumNonzero_()
   _20=_2._alloci64_I(_19)
   _21=(_2.i64)
   self.__p._getSp__3JI(_21,_20)
   _22=self.__p._getDim_I(0)
   _23=self.__p._getDim_I(1)
   _24=_3[_12]
   _25=_3[(_12 + 1)]
   _26=_2._alloci32_I(self.__p._getNumNonzero_())
   _27=(_2.i32)
   self.__p._getAllIndexes__3II(_27,_26)
   if _9: # src/fusion/Parameter.monty:2181:12-17
    _28=_2._alloci32_I(_7)
    _29=_2._alloci32_I((_25 + 1))
    _30=(_2.i32)
    fragments._c_closure_343(_25,_29,_30) # src/fusion/Parameter.monty:2194:10-52
    fragments._c_closure_344(_25,_29,_7,_13,_4,_30) # src/fusion/Parameter.monty:2195:10-65
    fragments._c_closure_345(_25,_29,_30) # src/fusion/Parameter.monty:2196:3-57
    fragments._c_closure_346(_25,_28,_29,_7,_13,_4,_30) # src/fusion/Parameter.monty:2197:3-2201:4
    _31=0
    _32=0
    _33=0
    _33,_31,_32 = fragments._c_closure_347(_17,_25,_28,_11,_7,_23,_19,_20,_10,_33,_31,_32,_13,_3,_4,_30,_21) # src/fusion/Parameter.monty:2208:3-2246:4
    _33 = numpy.int32(_33) # postprocess
    _31 = numpy.int32(_31) # postprocess
    _32 = numpy.int32(_32) # postprocess
    _34=1
    _35=(_31 < _22)
    _0._alloc_1expr_IIIZI(_34,_31,_32,_35,_33)
    _36=(_0.ptr_base)
    _37=(_0.nidxs_base)
    _38=((_0.sp_base) if (_35 ) else _0._alloci64_I(_31))
    _39=(_0.cof_base)
    _40=(_0.hassp)
    _41=(_0.shape_base)
    _42=(_0.codeptr_base)
    _43=(_0.code_base)
    _44=(_0.cconst_base)
    _45=(_0.i64)
    _46=(_0.f64)
    _47=(_0.i32)
    fragments._c_closure_348(_16,_18,_17,_15,_25,_28,_11,_7,_14,_22,_23,_26,_19,_20,_10,_44,_43,_42,_39,_46,_47,_45,_31,_37,_32,_36,_41,_38,_13,_5,_3,_4,_30,_21) # src/fusion/Parameter.monty:2275:10-2343:4
    if (not _40): # src/fusion/Parameter.monty:2352:7-17
     _0._popi64_I(_31)
    _2._clear_()
   else:
    _48=0
    _49=0
    _50=0
    _51=(_2.i32)
    _50,_48,_49 = fragments._c_closure_349(_17,_25,_11,_23,_19,_20,_10,_50,_48,_49,_3,_21) # src/fusion/Parameter.monty:2372:3-2398:11
    _50 = numpy.int32(_50) # postprocess
    _48 = numpy.int32(_48) # postprocess
    _49 = numpy.int32(_49) # postprocess
    _52=1
    _53=(_48 < _22)
    _0._alloc_1expr_IIIZI(_52,_48,_49,_53,_50)
    _54=(_0.ptr_base)
    _55=(_0.nidxs_base)
    _56=((_0.sp_base) if (_53 ) else _0._alloci64_I(_48))
    _57=(_0.cof_base)
    _58=(_0.hassp)
    _59=(_0.shape_base)
    _60=(_0.codeptr_base)
    _61=(_0.code_base)
    _62=(_0.cconst_base)
    _63=(_0.i64)
    _64=(_0.f64)
    _65=(_0.i32)
    fragments._c_closure_350(_16,_18,_17,_15,_25,_11,_14,_22,_23,_26,_19,_20,_10,_62,_61,_60,_57,_64,_65,_63,_50,_55,_54,_59,_56,_5,_3,_4,_51,_21) # src/fusion/Parameter.monty:2427:3-2481:11
    if (not _58): # src/fusion/Parameter.monty:2483:7-17
     _0._popi64_I(_48)
    _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamDiagLeft(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamDiagLeft
mosek_fusion_ExprMulParamDiagLeft=__mk_mosek_fusion_ExprMulParamDiagLeft()
del __mk_mosek_fusion_ExprMulParamDiagLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamDiagRight():
 class ExprMulParamDiagRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamDiagRight__e','_ExprMulParamDiagRight__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):# mosek.fusion.Expression,mosek.fusion.Parameter
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamDiagRight.ctor(mosek.fusion.Expression,mosek.fusion.Parameter)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamDiagRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamDiagRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamDiagRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamDiagRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamDiagRight'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p):
    o = ExprMulParamDiagRight.__new__(ExprMulParamDiagRight)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([e._getDim_I(0)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)): # src/fusion/Parameter.monty:1753:12-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if ((p._getDim_I(1)!=e._getDim_I(0)) or (p._getDim_I(0)!=e._getDim_I(1))): # src/fusion/Parameter.monty:1755:12-1756:38
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   if ((_6!=2) or ((_3[_12]!=self.__p._getDim_I(1)) or (_3[(_12 + 1)]!=self.__p._getDim_I(0)))): # src/fusion/Parameter.monty:1785:5-74
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   _19=self.__p._getNumNonzero_()
   _20=_2._alloci64_I(_19)
   _21=(_2.i64)
   _22=_2._alloci32_I(self.__p._getNumNonzero_())
   _23=(_2.i32)
   self.__p._getAllIndexes__3II(_23,_22)
   self.__p._getSp__3JI(_21,_20)
   _24=self.__p._getDim_I(0)
   _25=self.__p._getDim_I(1)
   _26=_3[_12]
   _27=_3[(_12 + 1)]
   _28=_2._alloci32_I(_19)
   _29=_2._alloci32_I((_25 + 1))
   _30=(_2.i32)
   fragments._c_closure_351(_25,_29,_30) # src/fusion/Parameter.monty:1806:8-50
   fragments._c_closure_352(_25,_19,_29,_20,_30,_21) # src/fusion/Parameter.monty:1807:8-63
   fragments._c_closure_353(_25,_29,_30) # src/fusion/Parameter.monty:1808:8-62
   fragments._c_closure_354(_25,_19,_28,_29,_20,_30,_21) # src/fusion/Parameter.monty:1809:8-1813:9
   if _9: # src/fusion/Parameter.monty:1815:5-10
    _31=0
    _32=0
    _33=0
    _34=0
    _35=0
    _35,_34,_31,_32,_33 = fragments._c_closure_355(_17,_27,_35,_34,_11,_7,_25,_19,_28,_20,_10,_31,_32,_33,_13,_3,_4,_30,_21) # src/fusion/Parameter.monty:1820:3-1858:11
    _35 = numpy.int32(_35) # postprocess
    _34 = numpy.int32(_34) # postprocess
    _31 = numpy.int32(_31) # postprocess
    _32 = numpy.int32(_32) # postprocess
    _33 = numpy.int32(_33) # postprocess
    _36=1
    _37=(_32 < _26)
    _0._alloc_1expr_IIIZI(_36,_32,_33,_37,_31)
    _38=(_0.ptr_base)
    _39=(_0.nidxs_base)
    _40=((_0.sp_base) if (_37 ) else _0._alloci64_I(_32))
    _41=(_0.cof_base)
    _42=(_0.hassp)
    _43=(_0.shape_base)
    _44=(_0.codeptr_base)
    _45=(_0.code_base)
    _46=(_0.cconst_base)
    _47=(_0.i64)
    _48=(_0.f64)
    _49=(_0.i32)
    if (_32 > 0): # src/fusion/Parameter.monty:1895:14-24
     _49[_38] = 0
     if (_31 > 0): # src/fusion/Parameter.monty:1897:16-30
      _49[_44] = 0
     _49[_43] = numpy.int32(_26)
     _50=0
     _51=0
     _52=0
     _53=0
     _54=0
     _50,_51,_54,_53,_52 = fragments._c_closure_356(_16,_18,_50,_17,_15,_27,_51,_54,_53,_11,_7,_14,_52,_25,_22,_19,_28,_20,_10,_46,_45,_44,_41,_48,_49,_47,_39,_38,_40,_13,_5,_3,_4,_30,_21) # src/fusion/Parameter.monty:1904:5-1965:6
     _50 = numpy.int32(_50) # postprocess
     _51 = numpy.int32(_51) # postprocess
     _54 = numpy.int32(_54) # postprocess
     _53 = numpy.int32(_53) # postprocess
     _52 = numpy.int32(_52) # postprocess
     if (_32 > _49[_43]): # src/fusion/Parameter.monty:1969:16-37
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid shape")
     if (_51!=_32): # src/fusion/Parameter.monty:1970:16-30
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num elements")
     if (_52!=_52): # src/fusion/Parameter.monty:1971:16-26
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num nonzeros")
    if (not _42): # src/fusion/Parameter.monty:1981:14-24
     _0._popi64_I(_32)
    _2._clear_()
   else:
    _55=0
    _56=0
    _57=0
    _58=0
    _58,_55,_56,_57 = fragments._c_closure_357(_17,_27,_58,_11,_25,_19,_28,_20,_10,_55,_56,_57,_3,_30,_21) # src/fusion/Parameter.monty:1996:10-2016:11
    _58 = numpy.int32(_58) # postprocess
    _55 = numpy.int32(_55) # postprocess
    _56 = numpy.int32(_56) # postprocess
    _57 = numpy.int32(_57) # postprocess
    _59=1
    _60=(_56 < _26)
    _0._alloc_1expr_IIIZI(_59,_56,_57,_60,_55)
    _61=(_0.ptr_base)
    _62=(_0.nidxs_base)
    _63=((_0.sp_base) if (_60 ) else _0._alloci64_I(_56))
    _64=(_0.cof_base)
    _65=(_0.hassp)
    _66=(_0.shape_base)
    _67=(_0.codeptr_base)
    _68=(_0.code_base)
    _69=(_0.cconst_base)
    _70=(_0.i64)
    _71=(_0.f64)
    _72=(_0.i32)
    _72[_61] = 0
    if (_55 > 0): # src/fusion/Parameter.monty:2054:16-30
     _72[_67] = 0
    _72[_66] = numpy.int32(_26)
    _73=0
    _74=0
    _75=0
    _76=0
    _73,_74,_76,_75 = fragments._c_closure_358(_16,_18,_73,_17,_15,_27,_74,_76,_11,_14,_75,_25,_22,_19,_28,_20,_10,_69,_68,_67,_64,_71,_72,_70,_62,_61,_63,_5,_3,_4,_30,_21) # src/fusion/Parameter.monty:2059:12-2101:13
    _73 = numpy.int32(_73) # postprocess
    _74 = numpy.int32(_74) # postprocess
    _76 = numpy.int32(_76) # postprocess
    _75 = numpy.int32(_75) # postprocess
    if (_56 > _72[_66]): # src/fusion/Parameter.monty:2107:16-37
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid shape")
    if (_74!=_56): # src/fusion/Parameter.monty:2108:16-30
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num elements")
    if (_75!=_57): # src/fusion/Parameter.monty:2109:16-27
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num nonzeros")
    if (not _65): # src/fusion/Parameter.monty:2117:14-24
     _0._popi64_I(_56)
    _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamDiagRight(")._a_S(self.__e._toString_())._a_S(",")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprMulParamDiagRight
mosek_fusion_ExprMulParamDiagRight=__mk_mosek_fusion_ExprMulParamDiagRight()
del __mk_mosek_fusion_ExprMulParamDiagRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprDotParam():
 class ExprDotParam(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDotParam__e','_ExprDotParam__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDotParam.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprDotParam._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDotParam._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDotParam.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprDotParam._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprDotParam._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDotParam.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDotParam'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprDotParam.__new__(ExprDotParam)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=e._getND_()): # src/fusion/Parameter.monty:1552:12-34
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   for _0 in range(0,p._getND_()):
    if (p._getDim_I(_0)!=e._getDim_I(_0)): # src/fusion/Parameter.monty:1555:14-40
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   _19=self.__p._getNumNonzero_()
   _20=_2._alloci64_I(_19)
   self.__p._getSp__3JI((_2.i64),_20)
   _21=_2._alloci32_I(self.__p._getNumNonzero_())
   _22=(_2.i32)
   self.__p._getAllIndexes__3II(_22,_21)
   _23=(_2.i64)
   _24=0
   _25=1
   _26=0
   _26,_24 = fragments._c_closure_359(_17,_9,_11,_7,_19,_20,_10,_26,_24,_13,_3,_4,_23) # src/fusion/Parameter.monty:1597:8-1620:9
   _26 = numpy.int32(_26) # postprocess
   _24 = numpy.int32(_24) # postprocess
   _27=1
   _27 = fragments._c_closure_360(_6,_27,_12,_3) # src/fusion/Parameter.monty:1623:27-68
   _27 = numpy.int64(_27) # postprocess
   _0._alloc_1expr_IIIZI(0,_25,_24,False,_26)
   _28=(_0.ptr_base)
   _29=(_0.nidxs_base)
   _30=(_0.cof_base)
   _31=(_0.hassp)
   _32=(_0.shape_base)
   _33=(_0.codeptr_base)
   _34=(_0.code_base)
   _35=(_0.cconst_base)
   _36=(_0.i64)
   _37=(_0.f64)
   _38=(_0.i32)
   _38[_28] = 0
   _38[(_28 + 1)] = _24
   if (_26 > 0): # src/fusion/Parameter.monty:1643:12-26
    _38[_33] = 0
   if _9: # src/fusion/Parameter.monty:1645:12-17
    _39=0
    _40=0
    _41=0
    _42=0
    _43=0
    _39,_42,_40,_43 = fragments._c_closure_361(_16,_18,_39,_17,_15,_42,_11,_7,_14,_40,_43,_21,_19,_20,_10,_35,_34,_33,_30,_37,_38,_36,_29,_13,_5,_3,_4,_22,_23) # src/fusion/Parameter.monty:1648:10-1686:11
    _39 = numpy.int32(_39) # postprocess
    _42 = numpy.int32(_42) # postprocess
    _40 = numpy.int32(_40) # postprocess
    _43 = numpy.int32(_43) # postprocess
    if (_41!=_25): # src/fusion/Parameter.monty:1687:14-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken elmi")
    if (_40!=_24): # src/fusion/Parameter.monty:1688:14-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken nzi")
    if (_39!=_26): # src/fusion/Parameter.monty:1689:14-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken codei")
   else:
    _44=0
    _45=0
    _44,_45 = fragments._c_closure_362(_16,_18,_44,_17,_15,_11,_14,_45,_21,_19,_20,_10,_35,_34,_33,_30,_37,_38,_36,_29,_5,_3,_4,_22,_23) # src/fusion/Parameter.monty:1693:10-1725:11
    _44 = numpy.int32(_44) # postprocess
    _45 = numpy.int32(_45) # postprocess
    if (_45!=_24): # src/fusion/Parameter.monty:1733:14-25
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nzi")
    if (_44!=_26): # src/fusion/Parameter.monty:1734:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid codei")
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDotParam(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprDotParam
mosek_fusion_ExprDotParam=__mk_mosek_fusion_ExprDotParam()
del __mk_mosek_fusion_ExprDotParam
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamElem():
 class ExprMulParamElem(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamElem__e','_ExprMulParamElem__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamElem.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamElem._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamElem._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamElem.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamElem._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamElem._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamElem.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamElem'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamElem.__new__(ExprMulParamElem)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=e._getND_()): # src/fusion/Parameter.monty:1320:12-34
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   for _0 in range(0,p._getND_()):
    if (p._getDim_I(_0)!=e._getDim_I(_0)): # src/fusion/Parameter.monty:1323:14-40
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   _19=self.__p._getNumNonzero_()
   _20=_2._alloci64_I(_19)
   self.__p._getSp__3JI((_2.i64),_20)
   _21=_2._alloci32_I(self.__p._getNumNonzero_())
   _22=(_2.i32)
   self.__p._getAllIndexes__3II(_22,_21)
   _23=(_2.i64)
   _24=_6
   _25=0
   _26=0
   _27=0
   _27,_26,_25 = fragments._c_closure_363(_17,_9,_11,_7,_19,_20,_10,_27,_26,_25,_13,_3,_4,_23) # src/fusion/Parameter.monty:1366:8-1393:9
   _27 = numpy.int32(_27) # postprocess
   _26 = numpy.int32(_26) # postprocess
   _25 = numpy.int32(_25) # postprocess
   _28=1
   _28 = fragments._c_closure_364(_6,_28,_12,_3) # src/fusion/Parameter.monty:1396:27-68
   _28 = numpy.int64(_28) # postprocess
   _29=(_26 < _28)
   _0._alloc_1expr_IIIZI(_24,_26,_25,_29,_27)
   _30=(_0.ptr_base)
   _31=(_0.nidxs_base)
   _32=((_0.sp_base) if (_29 ) else _0._alloci64_I(_26))
   _33=(_0.cof_base)
   _34=(_0.hassp)
   _35=(_0.shape_base)
   _36=(_0.codeptr_base)
   _37=(_0.code_base)
   _38=(_0.cconst_base)
   _39=(_0.i64)
   _40=(_0.f64)
   _41=(_0.i32)
   fragments._c_closure_365(_6,_41,_35,_12,_3) # src/fusion/Parameter.monty:1417:8-1418:41
   _41[_30] = 0
   if (_27 > 0): # src/fusion/Parameter.monty:1421:12-26
    _41[_36] = 0
   if _9: # src/fusion/Parameter.monty:1423:12-17
    _42=0
    _43=0
    _44=0
    _45=0
    _46=0
    _42,_45,_44,_43,_46 = fragments._c_closure_366(_16,_18,_42,_17,_15,_45,_44,_11,_7,_14,_43,_46,_21,_19,_20,_10,_38,_37,_36,_33,_40,_41,_39,_31,_30,_32,_13,_5,_3,_4,_22,_23) # src/fusion/Parameter.monty:1426:10-1471:11
    _42 = numpy.int32(_42) # postprocess
    _45 = numpy.int32(_45) # postprocess
    _44 = numpy.int32(_44) # postprocess
    _43 = numpy.int32(_43) # postprocess
    _46 = numpy.int32(_46) # postprocess
    if (_44!=_26): # src/fusion/Parameter.monty:1472:14-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken elmi")
    if (_43!=_25): # src/fusion/Parameter.monty:1473:14-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken nzi")
    if (_42!=_27): # src/fusion/Parameter.monty:1474:14-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken codei")
   else:
    _47=0
    _48=0
    _47,_48 = fragments._c_closure_367(_16,_18,_47,_17,_15,_11,_14,_48,_21,_19,_20,_10,_38,_37,_36,_33,_40,_41,_39,_31,_30,_32,_5,_3,_4,_22,_23) # src/fusion/Parameter.monty:1478:10-1514:11
    _47 = numpy.int32(_47) # postprocess
    _48 = numpy.int32(_48) # postprocess
    if (_27!=_47): # src/fusion/Parameter.monty:1515:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Invalid code list result")
   if (not _34): # src/fusion/Parameter.monty:1533:12-22
    _0._popi64_I(_26)
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamElem(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamElem
mosek_fusion_ExprMulParamElem=__mk_mosek_fusion_ExprMulParamElem()
del __mk_mosek_fusion_ExprMulParamElem
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamRight():
 class ExprMulParamRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamRight__e','_ExprMulParamRight__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):# mosek.fusion.Expression,mosek.fusion.Parameter
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamRight.ctor(mosek.fusion.Expression,mosek.fusion.Parameter)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamRight'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p):
    o = ExprMulParamRight.__new__(ExprMulParamRight)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([e._getDim_I(0),p._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)): # src/fusion/Parameter.monty:938:12-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if (p._getDim_I(0)!=e._getDim_I(1)): # src/fusion/Parameter.monty:940:12-38
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   if ((_6!=2) or (self.__p._getDim_I(0)!=_3[(_12 + 1)])): # src/fusion/Parameter.monty:969:12-51
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _19=_3[_12]
   _20=_3[(_12 + 1)]
   _21=self.__p._getDim_I(0)
   _22=self.__p._getDim_I(1)
   _23=self.__p._getNumNonzero_()
   _24=_2._alloci32_I(self.__p._getNumNonzero_())
   _25=(_2.i32)
   self.__p._getAllIndexes__3II(_25,_24)
   _26=_2._alloci32_I(_23)
   _27=_2._alloci64_I(_23)
   self.__p._getSp__3JI((_2.i64),_27)
   _28=_2._alloci32_I((_22 + 1))
   _29=(_2.i32)
   _30=(_2.i64)
   fragments._c_closure_368(_22,_28,_29) # src/fusion/Parameter.monty:994:10-52
   fragments._c_closure_369(_22,_23,_28,_27,_29,_30) # src/fusion/Parameter.monty:995:10-69
   fragments._c_closure_370(_22,_28,_29) # src/fusion/Parameter.monty:996:10-64
   fragments._c_closure_371(_22,_23,_26,_28,_27,_29,_30) # src/fusion/Parameter.monty:997:10-1000:11
   _31=(_2.i32)
   _32=(_2.i64)
   _33=0
   _34=0
   _35=0
   if ((not self.__p._isSparse_()) and (not _9)): # src/fusion/Parameter.monty:1008:12-42
    _35 = (_8 * _22)
    _34 = (_19 * _22)
    _33 = (((_11 + (_8 * 4)) * _22) if ((_11 > 0) ) else ((_8 * _22) * 3))
   elif (not _9): # src/fusion/Parameter.monty:1014:16-25
    _33,_34,_35 = fragments._c_closure_372(_17,_19,_20,_11,_22,_23,_26,_27,_10,_33,_34,_35,_3,_31,_32) # src/fusion/Parameter.monty:1014:27-1037:9
    _33 = numpy.int32(_33) # postprocess
    _34 = numpy.int32(_34) # postprocess
    _35 = numpy.int32(_35) # postprocess
   else:
    _33,_34,_35 = fragments._c_closure_373(_17,_20,_11,_7,_22,_23,_26,_27,_10,_33,_34,_35,_13,_3,_4,_31,_32) # src/fusion/Parameter.monty:1039:13-1119:9
    _33 = numpy.int32(_33) # postprocess
    _34 = numpy.int32(_34) # postprocess
    _35 = numpy.int32(_35) # postprocess
   _36=2
   _37=(_34 < (_22 * _19))
   _0._alloc_1expr_IIIZI(_36,_34,_35,_37,_33)
   _38=(_0.ptr_base)
   _39=(_0.nidxs_base)
   _40=((_0.sp_base) if (_37 ) else _0._alloci64_I(_34))
   _41=(_0.cof_base)
   _42=(_0.hassp)
   _43=(_0.shape_base)
   _44=(_0.codeptr_base)
   _45=(_0.code_base)
   _46=(_0.cconst_base)
   _47=(_0.i64)
   _48=(_0.f64)
   _49=(_0.i32)
   _49[_38] = 0
   if (_33 > 0): # src/fusion/Parameter.monty:1148:12-26
    _49[_44] = 0
   _49[_43] = _19
   _49[(_43 + 1)] = _22
   _50=0
   _51=0
   _52=0
   _50,_51,_52 = fragments._c_closure_374(_16,_18,_50,_17,_15,_19,_20,_51,_9,_11,_7,_14,_52,_22,_24,_23,_26,_27,_10,_46,_45,_44,_41,_48,_49,_47,_39,_38,_40,_13,_5,_3,_4,_31,_32) # src/fusion/Parameter.monty:1161:8-1289:9
   _50 = numpy.int32(_50) # postprocess
   _51 = numpy.int32(_51) # postprocess
   _52 = numpy.int32(_52) # postprocess
   if (not _42): # src/fusion/Parameter.monty:1297:12-22
    _0._popi64_I(_34)
   if (_51!=_34): # src/fusion/Parameter.monty:1301:12-29
    raise mosek_fusion_UnexpectedError._ctor_S("broken elmi")
   if (_52!=_35): # src/fusion/Parameter.monty:1302:12-27
    raise mosek_fusion_UnexpectedError._ctor_S("broken nzi")
   if (_50!=_33): # src/fusion/Parameter.monty:1303:12-33
    raise mosek_fusion_UnexpectedError._ctor_S("broken codei")
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamRight(")._a_S(self.__e._toString_())._a_S(",")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprMulParamRight
mosek_fusion_ExprMulParamRight=__mk_mosek_fusion_ExprMulParamRight()
del __mk_mosek_fusion_ExprMulParamRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamLeft():
 class ExprMulParamLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamLeft__e','_ExprMulParamLeft__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamLeft.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamLeft'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamLeft.__new__(ExprMulParamLeft)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([p._getDim_I(0),e._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)): # src/fusion/Parameter.monty:443:12-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if (p._getDim_I(1)!=e._getDim_I(0)): # src/fusion/Parameter.monty:445:12-38
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ncodeatom)
   _11=(_1.ptr_base)
   _12=(_1.code_base)
   _13=(_1.cconst_base)
   _14=(_1.codeptr_base)
   _15=(_1.shape_base)
   _16=(_1.sp_base)
   _17=(_1.nidxs_base)
   _18=(_1.cof_base)
   _19=(_1.cconst_base)
   if ((_6!=2) or (_3[_15]!=self.__p._getDim_I(1))): # src/fusion/Parameter.monty:476:12-49
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _20=self.__p._getDim_I(0)
   _21=self.__p._getDim_I(1)
   _22=_3[_15]
   _23=_3[(_15 + 1)]
   _24=self.__p._getNumNonzero_()
   _25=_2._alloci32_I(self.__p._getNumNonzero_())
   _26=(_2.i32)
   self.__p._getAllIndexes__3II(_26,_25)
   if ((not _9) and (not self.__p._isSparse_())): # src/fusion/Parameter.monty:491:12-42
    _27=2
    _28=(_23 * self.__p._getDim_I(0))
    _29=(_8 * self.__p._getDim_I(0))
    _30=(((self.__p._getDim_I(0) * _10) + (4 * _29)) if ((_10 > 0) ) else (3 * _29))
    _31=False
    _0._alloc_1expr_IIIZI(_27,_28,_29,_31,_30)
    _32=(_0.i64)
    _33=(_0.f64)
    _34=(_0.i32)
    _35=(_0.ptr_base)
    _36=(_0.nidxs_base)
    _37=(_0.cof_base)
    _38=(_0.code_base)
    _39=(_0.codeptr_base)
    _40=(_0.cconst_base)
    _41=(_0.hassp)
    _42=(_0.shape_base)
    _34[_42] = _20
    _34[(_42 + 1)] = _23
    _34[_35] = 0
    _34[_39] = 0
    _43=0
    _44=0
    _45=0
    for _46 in range(0,self.__p._getDim_I(0)):
     for _47 in range(0,self.__e._getDim_I(1)):
      for _48 in range(0,self.__p._getDim_I(1)):
       _45,_43 = fragments._c_closure_375(_13,_12,_45,_14,_18,_23,_46,_47,_48,_10,_17,_43,_21,_25,_11,_40,_38,_39,_37,_33,_34,_32,_36,_5,_3,_4,_26) # src/fusion/Parameter.monty:527:45-556:17
       _45 = numpy.int32(_45) # postprocess
       _43 = numpy.int32(_43) # postprocess
      _34[((_35 + _44) + 1)] = _43
      _44 += 1
    if (_45!=_30): # src/fusion/Parameter.monty:566:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect a-code length")
    if (_43!=_29): # src/fusion/Parameter.monty:567:16-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_44!=_28): # src/fusion/Parameter.monty:568:16-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    for _49 in range(0,_28):
     if (_34[(_35 + _49)] > _34[((_35 + _49) + 1)]): # src/fusion/Parameter.monty:569:40-69
      raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr indexes")
   elif (not _9): # src/fusion/Parameter.monty:574:16-25
    _50=_7
    _51=_24
    _52=_2._alloci64_I(_51)
    _53=(_2.i64)
    self.__p._getSp__3JI(_53,_52)
    _54=0
    _55=0
    _56=0
    _56,_54,_55 = fragments._c_closure_376(_14,_23,_10,_21,_24,_11,_56,_54,_55,_3,_53,_52) # src/fusion/Parameter.monty:587:10-611:11
    _56 = numpy.int32(_56) # postprocess
    _54 = numpy.int32(_54) # postprocess
    _55 = numpy.int32(_55) # postprocess
    _57=(_54 < (_20 * _23))
    _58=2
    _0._alloc_1expr_IIIZI(_58,_54,_55,_57,_56)
    _59=(_0.ptr_base)
    _60=(_0.nidxs_base)
    _61=((_0.sp_base) if (_57 ) else _0._alloci64_I(_54))
    _62=(_0.cof_base)
    _63=(_0.hassp)
    _64=(_0.shape_base)
    _65=(_0.codeptr_base)
    _66=(_0.code_base)
    _67=(_0.cconst_base)
    _68=(_0.i64)
    _69=(_0.f64)
    _70=(_0.i32)
    _70[_64] = _20
    _70[(_64 + 1)] = _23
    _71=0
    _72=0
    _73=0
    if (_56 > 0): # src/fusion/Parameter.monty:641:16-30
     _70[_65] = 0
    _70[_59] = 0
    fragments._c_closure_377(_62,_69,_55) # src/fusion/Parameter.monty:644:12-53
    _74=0
    _73,_72,_74,_71 = fragments._c_closure_378(_13,_12,_73,_14,_18,_23,_72,_74,_10,_17,_71,_21,_25,_24,_11,_67,_66,_65,_69,_70,_68,_60,_59,_61,_5,_3,_4,_26,_53,_52) # src/fusion/Parameter.monty:647:12-688:13
    _73 = numpy.int32(_73) # postprocess
    _72 = numpy.int32(_72) # postprocess
    _74 = numpy.int32(_74) # postprocess
    _71 = numpy.int32(_71) # postprocess
    if (_73!=_56): # src/fusion/Parameter.monty:699:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect code list")
    if (_71!=_55): # src/fusion/Parameter.monty:700:16-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_72!=_54): # src/fusion/Parameter.monty:701:16-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    if (_70[(_59 + _54)]!=_55): # src/fusion/Parameter.monty:702:16-41
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr")
    if (not _63): # src/fusion/Parameter.monty:705:14-24
     _0._popi64_I(_54)
    _2._clear_()
   else:
    _75=_7
    _76=_2._alloci32_I(_75)
    _77=self.__p._getNumNonzero_()
    _78=_2._alloci64_I(_77)
    _79=_2._alloci32_I((_3[(_15 + 1)] + 1))
    _80=(_2.i32)
    _81=(_2.i64)
    self.__p._getSp__3JI(_81,_78)
    fragments._c_closure_379(_7,_15,_16,_3,_4,_80,_76,_79) # src/fusion/Parameter.monty:725:10-734:11
    _82=0
    _83=0
    _84=0
    _85=_3[(_15 + 1)]
    _86=_3[_15]
    _87=self.__p._getDim_I(1)
    _88=self.__p._getDim_I(0)
    _84,_82,_83 = fragments._c_closure_380(_14,_85,_10,_7,_87,_77,_11,_84,_82,_83,_16,_3,_4,_80,_81,_76,_78) # src/fusion/Parameter.monty:746:10-790:11
    _84 = numpy.int32(_84) # postprocess
    _82 = numpy.int32(_82) # postprocess
    _83 = numpy.int32(_83) # postprocess
    _89=2
    _90=(_82 < (_88 * _85))
    _0._alloc_1expr_IIIZI(_89,_82,_83,_90,_84)
    _91=(_0.ptr_base)
    _92=(_0.nidxs_base)
    _93=((_0.sp_base) if (_90 ) else _0._alloci64_I(_82))
    _94=(_0.cof_base)
    _95=(_0.shape_base)
    _96=(_0.codeptr_base)
    _97=(_0.code_base)
    _98=(_0.cconst_base)
    _99=(_0.i64)
    _100=(_0.f64)
    _101=(_0.i32)
    fragments._c_closure_381(_101,_82,_91) # src/fusion/Parameter.monty:817:10-57
    _101[_91] = 0
    if (_84 > 0): # src/fusion/Parameter.monty:821:16-30
     _101[_96] = 0
    _101[_95] = _88
    _101[(_95 + 1)] = _85
    _102=0
    _103=0
    _104=0
    fragments._c_closure_382(_94,_100,_83) # src/fusion/Parameter.monty:831:12-56
    _105=0
    _104,_103,_102,_105 = fragments._c_closure_383(_13,_12,_104,_14,_18,_85,_103,_10,_7,_17,_102,_87,_25,_77,_105,_11,_98,_97,_96,_100,_101,_99,_92,_91,_93,_16,_5,_3,_4,_80,_81,_76,_78) # src/fusion/Parameter.monty:834:12-903:13
    _104 = numpy.int32(_104) # postprocess
    _103 = numpy.int32(_103) # postprocess
    _102 = numpy.int32(_102) # postprocess
    _105 = numpy.int32(_105) # postprocess
    if (_104!=_84): # src/fusion/Parameter.monty:911:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect a-code length")
    if (_102!=_83): # src/fusion/Parameter.monty:912:16-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_103!=_82): # src/fusion/Parameter.monty:913:16-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    if (_101[(_91 + _103)]!=_83): # src/fusion/Parameter.monty:915:16-39
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr")
    if (not _90): # src/fusion/Parameter.monty:917:14-24
     _0._popi64_I(_82)
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamLeft(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamLeft
mosek_fusion_ExprMulParamLeft=__mk_mosek_fusion_ExprMulParamLeft()
del __mk_mosek_fusion_ExprMulParamLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprOptimizeCode():
 class ExprOptimizeCode(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprOptimizeCode__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprOptimizeCode.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprOptimizeCode._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprOptimizeCode._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprOptimizeCode.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprOptimizeCode._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprOptimizeCode._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprOptimizeCode.toString()')
  def __repr__(self): return 'mosek.fusion.ExprOptimizeCode'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprOptimizeCode.__new__(ExprOptimizeCode)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def __compress_1code_alt_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11,_t__12):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.int32(_t__5)
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int32(_t__7)
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.int32(_t__9)
   _10=numpy.int32(_t__10)
   _11=numpy.int32(_t__11)
   _12=numpy.int32(_t__12)
   _1 = mosek_fusion_ExprOptimizeCode.__compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _8 is None or isinstance(_8,numpy.ndarray)
   _13=_4[(_5 + _1)]
   _14=_0._alloci32_I((_13 + 2))
   _15=0
   _16=_0._alloci32_I((_13 + 2))
   _17=_0._alloci32_I((_13 + 3))
   _18=_0._allocf64_I((_13 + 2))
   _19=_0._alloci32_I((_13 + 2))
   _20=0
   _21=(- 1)
   _22=(_0.i32)
   _23=(_0.f64)
   _24=_22
   _25=_23
   _26=_22
   _27=(_0.pi32)
   _28=(_0.pi64)
   _29=(_0.pf64)
   _26[_12] = 0
   _30=0
   _30,_21,_15,_20 = fragments._c_closure_384(_16,_17,_2,_3,_8,_9,_30,_21,_6,_7,_1,_4,_5,_14,_15,_24,_10,_25,_11,_26,_12,_18,_19,_20,_23,_22) # src/fusion/ExprCompress.monty:820:8-1203:9
   _30 = numpy.int32(_30) # postprocess
   _21 = numpy.int32(_21) # postprocess
   _15 = numpy.int32(_15) # postprocess
   _20 = numpy.int32(_20) # postprocess
   (_0.pi32) = _27
   (_0.pi64) = _28
   (_0.pf64) = _29
   if (_21 >= 0): # src/fusion/ExprCompress.monty:1210:12-25
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid parameterization code list")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.hassp)
   _8=(_1.ncodeatom)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   if (_8==0): # src/fusion/ExprCompress.monty:551:12-26
    _0._alloc_1expr_IIIZI(_3,_5,_6,_7,0)
    _19=(_0.ptr_base)
    _20=(_0.sp_base)
    _21=(_0.nidxs_base)
    _22=(_0.cof_base)
    _23=(_0.shape_base)
    _24=(_0.i32)
    _25=(_0.i64)
    _26=(_0.f64)
    fragments._c_closure_385(_5,_9,_24,_19,_16) # src/fusion/ExprCompress.monty:563:10-64
    fragments._c_closure_386(_3,_24,_23,_4,_16) # src/fusion/ExprCompress.monty:564:10-66
    fragments._c_closure_387(_11,_6,_25,_21,_17) # src/fusion/ExprCompress.monty:565:10-66
    fragments._c_closure_388(_12,_6,_22,_26,_18) # src/fusion/ExprCompress.monty:566:10-64
    fragments._c_closure_389(_7,_5,_25,_20,_10,_17) # src/fusion/ExprCompress.monty:567:10-568:63
   else:
    _27=_2._alloci32_I((_8 + (_6 * 2)))
    _28=_2._alloci32_I((_6 + 1))
    _29=_2._allocf64_I((_8 + (_6 * 2)))
    mosek.fusion.ExprOptimizeCode.__compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_2,_6,_16,_13,_16,_14,_18,_12,_18,_15,_27,_29,_28)
    _30=(_2.i32)
    _31=(_2.f64)
    _32=0
    _33=0
    _34=0
    _32,_34,_33 = fragments._c_closure_390(_12,_5,_9,_32,_34,_33,_18,_16,_27,_28,_30) # src/fusion/ExprCompress.monty:604:10-625:11
    _32 = numpy.int32(_32) # postprocess
    _34 = numpy.int32(_34) # postprocess
    _33 = numpy.int32(_33) # postprocess
    _35=False
    _35 = fragments._c_closure_391(_3,_35,_34,_4,_16) # src/fusion/ExprCompress.monty:629:10-634:11
    _0._alloc_1expr_IIIZI(_3,_34,_33,_35,_32)
    _36=(_0.ptr_base)
    _37=(_0.sp_base)
    _38=(_0.shape_base)
    _39=(_0.nidxs_base)
    _40=(_0.cof_base)
    _41=(_0.code_base)
    _42=(_0.codeptr_base)
    _43=(_0.cconst_base)
    _44=(_0.i32)
    _45=(_0.i64)
    _46=(_0.f64)
    fragments._c_closure_392(_3,_44,_38,_4,_16) # src/fusion/ExprCompress.monty:651:10-61
    if (_32==0): # src/fusion/ExprCompress.monty:653:14-29
     fragments._c_closure_393(_12,_7,_5,_11,_6,_9,_40,_46,_44,_45,_39,_36,_37,_10,_18,_17) # src/fusion/ExprCompress.monty:653:31-659:11
    else:
     _47=0
     _48=0
     _49=0
     _44[_36] = 0
     if (_32 > 0): # src/fusion/ExprCompress.monty:664:16-30
      _44[_42] = 0
     _47,_48,_49 = fragments._c_closure_394(_47,_12,_48,_5,_11,_49,_9,_43,_41,_42,_40,_46,_35,_44,_45,_39,_36,_37,_10,_18,_16,_17,_29,_27,_28,_31,_30) # src/fusion/ExprCompress.monty:668:12-734:13
     _47 = numpy.int32(_47) # postprocess
     _48 = numpy.int32(_48) # postprocess
     _49 = numpy.int32(_49) # postprocess
     if (_48!=_34): # src/fusion/ExprCompress.monty:740:16-31
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result nelem")
     if (_49!=_33): # src/fusion/ExprCompress.monty:741:16-29
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result nnz")
     if (_47!=_32): # src/fusion/ExprCompress.monty:742:16-35
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result num code atoms")
     if (_32 > 0): # src/fusion/ExprCompress.monty:743:16-30
      if (_44[(_42 + _33)]!=_32): # src/fusion/ExprCompress.monty:744:18-51
       raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprOptimizeCode(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprOptimizeCode
mosek_fusion_ExprOptimizeCode=__mk_mosek_fusion_ExprOptimizeCode()
del __mk_mosek_fusion_ExprOptimizeCode
#BEFORE CLASS
def __mk_mosek_fusion_ExprCompress():
 class ExprCompress(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCompress__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCompress.ctor(mosek.fusion.Expression)')
  @staticmethod
  def arg_sort(*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32
      return mosek_fusion_ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args)
    elif mosek_fusion_ExprCompress._match_alt_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32
      return mosek_fusion_ExprCompress._arg_1sort_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args)
    else:
      raise ValueError('Invalid argument list arg_sort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.arg_sort(mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32)')
  @staticmethod
  def merge_sort(*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_merge_1sort_IIIIII_3I_3J(*args): # int32,int32,int32,int32,int32,int32,[]int32,[]int64
      return mosek_fusion_ExprCompress._merge_1sort_IIIIII_3I_3J(*args)
    elif mosek_fusion_ExprCompress._match_alt_merge_1sort_IIIIII_3I_3J(*args): # int32,int32,int32,int32,int32,int32,[]int32,[]int64
      return mosek_fusion_ExprCompress._merge_1sort_alt_IIIIII_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list merge_sort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.merge_sort(int32,int32,int32,int32,int32,int32,array(int32,ndim=1),array(int64,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCompress._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprCompress._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.toString()')
  def __repr__(self): return 'mosek.fusion.ExprCompress'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprCompress.__new__(ExprCompress)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5) and __arg_match_I__(_6))
  @staticmethod
  def _match_alt_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5) and __arg_alt_match_I__(_6))
  @staticmethod
  def _arg_1sort_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
    return mosek_fusion_ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_0,_1,numpy.int32(__2),numpy.int32(__3),numpy.int32(__4),numpy.int32(__5),numpy.int32(__6))
  @staticmethod
  def _arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_0,_1,_2,_3,_4,_5,_6):
   _7=0
   _8=(_0.i32)
   _7 = fragments._c_closure_395(_7,_3,_5,_8) # src/fusion/ExprCompress.monty:380:8-381:89
   _7 = numpy.int32(_7) # postprocess
   _9=(_1._alloci32_I((_7 * 2)) if ((_7 > 2) ) else 99999)
   _10=(_1.i32)
   _8 = (_0.i32)
   _11=(_0.i64)
   fragments._c_closure_396(_3,_6,_2,_5,_8,_11,_9,_10) # src/fusion/ExprCompress.monty:388:8-499:9
  @staticmethod
  def _match_merge_1sort_IIIIII_3I_3J(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5) and __arg_match__3I__(_6) and __arg_match__3J__(_7))
  @staticmethod
  def _match_alt_merge_1sort_IIIIII_3I_3J(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3J__(_7))
  @staticmethod
  def _merge_1sort_alt_IIIIII_3I_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_ExprCompress._merge_1sort_IIIIII_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _merge_1sort_IIIIII_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7):
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   fragments._c_closure_397(_2,_5,_3,_0,_1,_4,_6,_7) # src/fusion/ExprCompress.monty:313:36-367:7
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.hassp)
   _8=(_1.ncodeatom)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=True
   _20=(_2.i32)
   _21=(_2.i64)
   _22=(_2.f64)
   _19 = fragments._c_closure_398(_19,_5,_11,_9,_16,_17) # src/fusion/ExprCompress.monty:65:10-67:75
   _19 = fragments._c_closure_399(_15,_13,_14,_12,_19,_8,_6,_18,_16) # src/fusion/ExprCompress.monty:70:10-83:99
   if _19: # src/fusion/ExprCompress.monty:88:12-21
    _0._alloc_1expr_IIIZI(_3,_5,_6,_7,_8)
    _23=(_0.ptr_base)
    _24=(_0.nidxs_base)
    _25=(_0.sp_base)
    _26=(_0.cof_base)
    _27=(_0.shape_base)
    _28=(_0.code_base)
    _29=(_0.codeptr_base)
    _30=(_0.cconst_base)
    _31=(_0.i32)
    _32=(_0.i64)
    _33=(_0.f64)
    fragments._c_closure_400(_15,_13,_14,_12,_7,_8,_3,_5,_11,_6,_9,_30,_28,_29,_26,_33,_31,_32,_24,_23,_27,_25,_4,_10,_18,_16,_17) # src/fusion/ExprCompress.monty:113:10-126:11
    if (_8 > 0): # src/fusion/ExprCompress.monty:135:14-27
     if (_31[(_29 + _6)]!=_8): # src/fusion/ExprCompress.monty:136:16-47
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
   else:
    _34=_2._alloci32_I(_6)
    mosek.fusion.ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_1,_2,_34,_5,_6,_9,_11)
    _35=(_2.i32)
    _36=0
    _37=_8
    _38=(_0.i32)
    _37,_36 = fragments._c_closure_401(_12,_8,_5,_11,_34,_9,_37,_36,_18,_16,_17,_35) # src/fusion/ExprCompress.monty:153:12-178:13
    _37 = numpy.int32(_37) # postprocess
    _36 = numpy.int32(_36) # postprocess
    _0._alloc_1expr_IIIZI(_3,_5,_36,_7,_37)
    _39=(_0.nidxs_base)
    _40=(_0.shape_base)
    _41=(_0.sp_base)
    _42=(_0.cof_base)
    _43=(_0.ptr_base)
    _44=(_0.code_base)
    _45=(_0.codeptr_base)
    _46=(_0.cconst_base)
    _47=(_0.i32)
    _48=(_0.i64)
    _49=(_0.f64)
    fragments._c_closure_402(_3,_47,_40,_4,_16) # src/fusion/ExprCompress.monty:207:12-208:45
    fragments._c_closure_403(_7,_5,_48,_41,_10,_17) # src/fusion/ExprCompress.monty:209:12-210:62
    _50=0
    _51=0
    _51,_50 = fragments._c_closure_404(_15,_13,_51,_14,_12,_8,_5,_11,_50,_34,_9,_46,_44,_45,_42,_49,_47,_48,_37,_39,_43,_18,_16,_17,_35) # src/fusion/ExprCompress.monty:214:12-279:13
    _51 = numpy.int32(_51) # postprocess
    _50 = numpy.int32(_50) # postprocess
    if (_37!=_51): # src/fusion/ExprCompress.monty:288:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ncodeatom")
    if (_50!=_36): # src/fusion/ExprCompress.monty:289:16-34
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
    if (_36!=_47[(_43 + _5)]): # src/fusion/ExprCompress.monty:290:16-46
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
    if (_37 > 0): # src/fusion/ExprCompress.monty:293:14-28
     if (_47[(_45 + _36)]!=_37): # src/fusion/ExprCompress.monty:294:16-49
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprCompress(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprCompress
mosek_fusion_ExprCompress=__mk_mosek_fusion_ExprCompress()
del __mk_mosek_fusion_ExprCompress
#BEFORE CLASS
def __mk_mosek_fusion_ExprConst():
 class ExprConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprConst__sparsity','_ExprConst__bfix']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I_3J_3D(*args): # []int32,[]int64,[]double
      self._ctor_init__3I_3J_3D(*args)
    elif self.__match_alt_ctor__3I_3J_3D(*args):# []int32,[]int64,[]double
      self._ctor_alt_init__3I_3J_3D(*args)
    elif self.__match_ctor__3I_3JD(*args): # []int32,[]int64,double
      self._ctor_init__3I_3JD(*args)
    elif self.__match_alt_ctor__3I_3JD(*args):# []int32,[]int64,double
      self._ctor_alt_init__3I_3JD(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprConst.ctor(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.ExprConst.ctor(array(int32,ndim=1),array(int64,ndim=1),double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprConst'
  @staticmethod
  def _ctor__3I_3J_3D(shape,sparsity,bfix):
    o = ExprConst.__new__(ExprConst)
    o._ctor_init__3I_3J_3D(shape,sparsity,bfix)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3D__(bfix))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3D__(bfix))
  def _ctor_alt_init__3I_3J_3D(self,shape,sparsity,bfix):
    self._ctor_init__3I_3J_3D(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,shape,sparsity,bfix):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,shape)
   (self.__bfix) = mosek.fusion.Utils.Tools._arraycopy__3D(bfix)
   (self.__sparsity) = (mosek.fusion.Utils.Tools._arraycopy__3J(sparsity) if ((sparsity is not None) ) else None)
   mosek.fusion.ExprConst.__validate__3I_3D_3J(shape,bfix,sparsity)
  @staticmethod
  def _ctor__3I_3JD(shape,sparsity,bfix):
    o = ExprConst.__new__(ExprConst)
    o._ctor_init__3I_3JD(shape,sparsity,bfix)
    return o
  @staticmethod
  def __match_ctor__3I_3JD(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match_D__(bfix))
  @staticmethod
  def __match_alt_ctor__3I_3JD(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match_D__(bfix))
  def _ctor_alt_init__3I_3JD(self,shape,sparsity,bfix):
    self._ctor_init__3I_3JD(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.float64(bfix))
  def _ctor_init__3I_3JD(self,shape,sparsity,bfix):
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert sparsity is None or isinstance(sparsity,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,shape)
   _0=(mosek.fusion.Set._size__3I(shape) if ((sparsity is None) ) else int((sparsity).shape[0]))
   (self.__bfix) = numpy.array([bfix for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64))
   (self.__sparsity) = (mosek.fusion.Utils.Tools._arraycopy__3J(sparsity) if ((sparsity is not None) ) else None)
   mosek.fusion.ExprConst.__validate__3I_3D_3J(shape,(self.__bfix),sparsity)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self._getShape_()
   _4=int((_3).shape[0])
   _5=0
   _5 = fragments._c_closure_405(self.__bfix,_5) # src/fusion/ExprConst.monty:48:23-101
   _5 = numpy.int32(_5) # postprocess
   _6=int((self.__bfix).shape[0])
   _7=((self.__sparsity is not None) and (int((self.__sparsity).shape[0]) < mosek.fusion.Set._size__3I(_3)))
   _0._alloc_1expr_IIIZI(_4,_6,_5,_7,0)
   _8=(_0.shape_base)
   _9=(_0.ptr_base)
   _10=(_0.sp_base)
   _11=(_0.nidxs_base)
   _12=(_0.cof_base)
   _13=(_0.i32)
   _14=(_0.i64)
   _15=(_0.f64)
   fragments._c_closure_406(_4,_13,_8,_3) # src/fusion/ExprConst.monty:64:8-54
   _16=0
   _13[_9] = 0
   fragments._c_closure_407(_7,_6,_14,_10,self.__sparsity) # src/fusion/ExprConst.monty:67:8-69:38
   _16 = fragments._c_closure_408(self.__bfix,_6,_16,_12,_15,_13,_14,_11,_9) # src/fusion/ExprConst.monty:70:8-77:9
   _16 = numpy.int32(_16) # postprocess
  @staticmethod
  def __validate_alt__3I_3D_3J(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_ExprConst.__validate__3I_3D_3J(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate__3I_3D_3J(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=mosek.fusion.Set._size__3I(_0)
   if (_2 is not None): # src/fusion/ExprConst.monty:12:12-28
    if (int((_2).shape[0])!=int((_1).shape[0])): # src/fusion/ExprConst.monty:13:14-40
     raise mosek_fusion_LengthError._ctor_S("Mismatching data lengths")
    _4=False
    _4 = fragments._c_closure_409(_4,_2,_3) # src/fusion/ExprConst.monty:16:10-18:25
    if _4: # src/fusion/ExprConst.monty:19:14-17
     raise mosek_fusion_IndexError._ctor_S("Invalid sparsity index")
   else:
    if (int((_1).shape[0])!=_3): # src/fusion/ExprConst.monty:23:14-29
     raise mosek_fusion_LengthError._ctor_S("Mismatching data length")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprConst()")
 return ExprConst
mosek_fusion_ExprConst=__mk_mosek_fusion_ExprConst()
del __mk_mosek_fusion_ExprConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprPick():
 class ExprPick(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprPick__idxs','_ExprPick__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args): # mosek.fusion.Expression,[,]int32
      self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):# mosek.fusion.Expression,[,]int32
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3J(*args): # mosek.fusion.Expression,[]int64
      self._ctor_init_Lmosek_4fusion_4Expression_2_3J(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3J(*args):# mosek.fusion.Expression,[]int64
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPick.ctor(mosek.fusion.Expression,array(int32,ndim=2))\n\tmosek.fusion.ExprPick.ctor(mosek.fusion.Expression,array(int64,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprPick._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprPick._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPick.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprPick._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprPick._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPick.toString()')
  def __repr__(self): return 'mosek.fusion.ExprPick'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3_5I(expr,idxs):
    o = ExprPick.__new__(ExprPick)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(expr,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3_5I__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3_5I__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I(self,expr,idxs):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(expr,numpy.array(idxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3_5I(self,expr,idxs):
   assert idxs is None or isinstance(idxs,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([int((idxs).shape[0])], dtype=numpy.dtype(numpy.int32)))
   _0=expr._getShape_()
   _1=int((_0).shape[0])
   (self.__expr) = expr
   (self.__idxs) = numpy.zeros((int((idxs).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _2=(self.__idxs)
   if (int((idxs).shape[1])!=_1): # src/fusion/ExprSlice.monty:218:12-29
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and index dimensions")
   _3=False
   _3 = fragments._c_closure_410(idxs,_1,_0,_3) # src/fusion/ExprSlice.monty:222:8-225:32
   if _3: # src/fusion/ExprSlice.monty:226:12-22
    raise mosek_fusion_IndexError._ctor_S("Pick index out of bounds")
   fragments._c_closure_411(idxs,_1,_0,_2) # src/fusion/ExprSlice.monty:229:8-237:9
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3J(expr,idxs):
    o = ExprPick.__new__(ExprPick)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3J(expr,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3J__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3J__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3J(self,expr,idxs):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3J(expr,numpy.array(idxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3J(self,expr,idxs):
   assert idxs is None or isinstance(idxs,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([int((idxs).shape[0])], dtype=numpy.dtype(numpy.int32)))
   (self.__expr) = expr
   _0=expr._getShape_()
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   _2 = fragments._c_closure_412(idxs,_1,_2) # src/fusion/ExprSlice.monty:198:8-200:30
   if _2: # src/fusion/ExprSlice.monty:201:12-22
    raise mosek_fusion_IndexError._ctor_S("Pick index out of bounds")
   (self.__idxs) = mosek.fusion.Utils.Tools._arraycopy__3J(idxs)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=(self.__idxs)
   if (not _8): # src/fusion/ExprSlice.monty:264:12-21
    _20=int((_19).shape[0])
    _21=1
    _22=0
    _23=0
    _23,_22 = fragments._c_closure_413(_14,_19,_7,_9,_23,_22,_16) # src/fusion/ExprSlice.monty:270:10-274:11
    _23 = numpy.int32(_23) # postprocess
    _22 = numpy.int32(_22) # postprocess
    _0._alloc_1expr_IIIZI(_21,_20,_22,False,_23)
    _24=(_0.cof_base)
    _25=(_0.nidxs_base)
    _26=(_0.ptr_base)
    _27=(_0.shape_base)
    _28=(_0.code_base)
    _29=(_0.codeptr_base)
    _30=(_0.cconst_base)
    pass
    _31=(_0.i32)
    _32=(_0.i64)
    _33=(_0.f64)
    _31[_27] = int((_19).shape[0])
    _34=0
    _35=0
    _31[_26] = 0
    _34,_35 = fragments._c_closure_414(_15,_13,_34,_14,_12,_19,_35,_7,_11,_9,_30,_28,_29,_24,_33,_31,_32,_25,_26,_18,_16,_17) # src/fusion/ExprSlice.monty:295:10-310:11
    _34 = numpy.int32(_34) # postprocess
    _35 = numpy.int32(_35) # postprocess
   else:
    _36=1
    _37=int((_19).shape[0])
    _38=0
    _39=0
    _40=(self.__idxs)
    _41=_2._alloci32_I(int((_40).shape[0]))
    _42=(_2.i32)
    _39,_38 = fragments._c_closure_415(_14,_40,_7,_5,_9,_39,_38,_10,_41,_16,_17,_42) # src/fusion/ExprSlice.monty:323:10-341:11
    _39 = numpy.int32(_39) # postprocess
    _38 = numpy.int32(_38) # postprocess
    _0._alloc_1expr_IIIZI(_36,_37,_38,False,_39)
    _43=(_0.ptr_base)
    _44=(_0.nidxs_base)
    _45=(_0.cof_base)
    _46=(_0.shape_base)
    _47=(_0.code_base)
    _48=(_0.codeptr_base)
    _49=(_0.cconst_base)
    _50=(_0.i32)
    _51=(_0.i64)
    _52=(_0.f64)
    _50[_46] = int((_40).shape[0])
    _50[_43] = 0
    _53=0
    _54=0
    _53,_54 = fragments._c_closure_416(_15,_13,_53,_14,_12,_40,_54,_7,_11,_9,_49,_47,_48,_45,_52,_50,_51,_44,_43,_41,_18,_16,_17,_42) # src/fusion/ExprSlice.monty:362:10-383:11
    _53 = numpy.int32(_53) # postprocess
    _54 = numpy.int32(_54) # postprocess
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprPick()")
 return ExprPick
mosek_fusion_ExprPick=__mk_mosek_fusion_ExprPick()
del __mk_mosek_fusion_ExprPick
#BEFORE CLASS
def __mk_mosek_fusion_ExprSlice():
 class ExprSlice(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSlice__last','_ExprSlice__first','_ExprSlice__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args): # mosek.fusion.Expression,[]int32,[]int32
      self._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):# mosek.fusion.Expression,[]int32,[]int32
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSlice.ctor(mosek.fusion.Expression,array(int32,ndim=1),array(int32,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSlice._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSlice._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSlice.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprSlice._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprSlice._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSlice.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSlice'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3I_3I(expr,first,last):
    o = ExprSlice.__new__(ExprSlice)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(expr,first,last)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
    if len(args) != 3: return False
    expr,first,last, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3I__(first) and __arg_match__3I__(last))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
    if len(args) != 3: return False
    expr,first,last, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3I__(first) and __arg_alt_match__3I__(last))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3I_3I(self,expr,first,last):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(expr,numpy.array(first,dtype=numpy.dtype(numpy.int32)),numpy.array(last,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(self,expr,first,last):
   assert first is None or isinstance(first,numpy.ndarray)
   assert last is None or isinstance(last,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprSlice.__makeShape__3I_3I_3I(expr._getShape_(),first,last))
   (self.__expr) = expr
   (self.__first) = first
   (self.__last) = last
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _19[(_3 - 1)] = 1
   fragments._c_closure_417(_3,_8,_19,_16) # src/fusion/ExprSlice.monty:60:45-111
   _20=0
   _21=0
   _22=0
   _20,_21,_22 = fragments._c_closure_418(_14,self.__first,_7,self.__last,_6,_3,_4,_9,_20,_21,_22,_8,_10,_19,_16,_17) # src/fusion/ExprSlice.monty:64:8-92:9
   _20 = numpy.int32(_20) # postprocess
   _21 = numpy.int32(_21) # postprocess
   _22 = numpy.int32(_22) # postprocess
   _23=numpy.array([(self.__last[_24] - self.__first[_24]) for _24 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
   _25=(_21 < mosek.fusion.Set._size__3I(_23))
   _0._alloc_1expr_IIIZI(_3,_21,_22,_25,_20)
   _26=(_0.shape_base)
   _27=(_0.cof_base)
   _28=(_0.nidxs_base)
   _29=((_0.sp_base) if (_25 ) else _0._alloci64_I(_21))
   _30=(_0.ptr_base)
   _31=(_0.code_base)
   _32=(_0.codeptr_base)
   _33=(_0.cconst_base)
   _34=(_0.i32)
   _35=(_0.i64)
   _36=(_0.f64)
   fragments._c_closure_419(_3,_34,_23,_26) # src/fusion/ExprSlice.monty:113:8-60
   _34[_30] = 0
   if (_6 > 0): # src/fusion/ExprSlice.monty:116:12-25
    _34[_32] = 0
   _37=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _37[(_3 - 1)] = 1
   fragments._c_closure_420(_3,_23,_37) # src/fusion/ExprSlice.monty:118:47-106
   _38=0
   _39=0
   _40=0
   _38,_39,_40 = fragments._c_closure_421(_15,_13,_38,_14,_12,self.__first,_7,_39,_40,self.__last,_6,_3,_4,_11,_9,_33,_31,_32,_27,_36,_34,_35,_28,_30,_29,_37,_8,_10,_19,_18,_16,_17) # src/fusion/ExprSlice.monty:122:8-177:9
   _38 = numpy.int32(_38) # postprocess
   _39 = numpy.int32(_39) # postprocess
   _40 = numpy.int32(_40) # postprocess
   if (not _25): # src/fusion/ExprSlice.monty:178:12-22
    _0._popi64_I(_21)
  @staticmethod
  def __makeShape_alt__3I_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprSlice.__makeShape__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __makeShape__3I_3I_3I(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((_2).shape[0]))): # src/fusion/ExprSlice.monty:18:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid or mismatching index lengths")
   for _3 in range(0,int((_0).shape[0])):
    if ((_1[_3] < 0) or ((_2[_3] < _1[_3]) or (_2[_3] > _0[_3]))): # src/fusion/ExprSlice.monty:21:14-70
     raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   return (numpy.array([(_2[_4] - _1[_4]) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprSlice([")._a_I(self.__first[0])._a_S(":")._a_I(self.__last[0])
   for _1 in range(1,int((self.__first).shape[0])):
    _0._a_S(",")._a_I(self.__first[_1])._a_S(":")._a_I(self.__last[_1])
   _0._a_S("],")._a_S(self.__expr._toString_())._a_S(")")
   return (_0._toString_())
 return ExprSlice
mosek_fusion_ExprSlice=__mk_mosek_fusion_ExprSlice()
del __mk_mosek_fusion_ExprSlice
#BEFORE CLASS
def __mk_mosek_fusion_ExprPermuteDims():
 class ExprPermuteDims(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprPermuteDims__dperm','_ExprPermuteDims__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3ILmosek_4fusion_4Expression_2(*args): # []int32,mosek.fusion.Expression
      self._ctor_init__3ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):# []int32,mosek.fusion.Expression
      self._ctor_alt_init__3ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPermuteDims.ctor(array(int32,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprPermuteDims._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprPermuteDims._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPermuteDims.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprPermuteDims'
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2(perm,expr):
    o = ExprPermuteDims.__new__(ExprPermuteDims)
    o._ctor_init__3ILmosek_4fusion_4Expression_2(perm,expr)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    perm,expr, = args
    return (__arg_match__3I__(perm) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    perm,expr, = args
    return (__arg_alt_match__3I__(perm) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2(self,perm,expr):
    self._ctor_init__3ILmosek_4fusion_4Expression_2(numpy.array(perm,dtype=numpy.dtype(numpy.int32)),expr)
  def _ctor_init__3ILmosek_4fusion_4Expression_2(self,perm,expr):
   assert perm is None or isinstance(perm,numpy.ndarray)
   mosek_fusion_ExprPermuteDims._ctor_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,1)
   _0=expr._getShape_()
   if (int((perm).shape[0])!=int((_0).shape[0])): # src/fusion/ExprTranspose.monty:171:12-35
    raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
   _1=numpy.array([0 for _2 in range(0,int((perm).shape[0]))], dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_1).shape[0])):
    if ((perm[_3] < 0) or (perm[_3] > int((_0).shape[0]))): # src/fusion/ExprTranspose.monty:176:14-49
     raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
    _1[perm[_3]] += 1
   for _4 in range(0,int((_1).shape[0])):
    if ((_1[_4] < 1) or (_1[_4] > 1)): # src/fusion/ExprTranspose.monty:182:14-42
     raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2I(perm,expr,validated):
    o = ExprPermuteDims.__new__(ExprPermuteDims)
    o._ctor_init__3ILmosek_4fusion_4Expression_2I(perm,expr,validated)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 3: return False
    perm,expr,validated, = args
    return (__arg_match__3I__(perm) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 3: return False
    perm,expr,validated, = args
    return (__arg_alt_match__3I__(perm) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,validated):
    self._ctor_init__3ILmosek_4fusion_4Expression_2I(numpy.array(perm,dtype=numpy.dtype(numpy.int32)),expr,numpy.int32(validated))
  def _ctor_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,validated):
   assert perm is None or isinstance(perm,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprPermuteDims.__computeshape__3I_3I(perm,expr._getShape_()))
   (self.__expr) = expr
   self.__dperm = mosek.fusion.Utils.Tools._arraycopy__3I(perm)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _9[(_3 - 1)] = 1
   for _10 in range(1,_3):
    _9[((_3 - _10) - 1)] = (_9[(_3 - _10)] * (_1.i32)[((_8 + _3) - _10)])
   _11=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _11[(_3 - 1)] = 1
   for _12 in range(1,_3):
    _11[((_3 - _12) - 1)] = (_11[(_3 - _12)] * (_1.i32)[(_8 + self.__dperm[(_3 - _12)])])
   _13=(_1.ptr_base)
   _14=(_1.sp_base)
   _15=(_1.nidxs_base)
   _16=(_1.cof_base)
   _17=(_1.code_base)
   _18=(_1.codeptr_base)
   _19=(_1.cconst_base)
   _20=(_1.i32)
   _21=(_1.i64)
   _22=(_1.f64)
   _0._alloc_1expr_IIIZI(_3,_4,_5,_7,_6)
   _23=(_0.ptr_base)
   _24=(_0.shape_base)
   _25=(_0.nidxs_base)
   _26=(_0.sp_base)
   _27=(_0.cof_base)
   _28=(_0.code_base)
   _29=(_0.codeptr_base)
   _30=(_0.cconst_base)
   _31=(_0.i32)
   _32=(_0.i64)
   _33=(_0.f64)
   fragments._c_closure_422(self.__dperm,_3,_31,_24,_8,_20) # src/fusion/ExprTranspose.monty:225:8-71
   if _7: # src/fusion/ExprTranspose.monty:227:12-17
    _34=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_423(self.__dperm,_11,_14,_3,_4,_8,_34,_9,_20,_21) # src/fusion/ExprTranspose.monty:229:10-235:11
    _35=numpy.array([_36 for _36 in range(0,_4)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_35,_34,None,0,_4)
    _31[_23] = 0
    if (_6 > 0): # src/fusion/ExprTranspose.monty:242:14-27
     _31[_29] = 0
    _37=0
    _38=0
    _39=0
    _37,_38,_39 = fragments._c_closure_424(_19,_17,_37,_18,_16,_15,_13,_38,_39,_6,_4,_35,_30,_28,_29,_27,_33,_31,_32,_25,_23,_26,_34,_22,_20,_21) # src/fusion/ExprTranspose.monty:246:10-265:11
    _37 = numpy.int32(_37) # postprocess
    _38 = numpy.int32(_38) # postprocess
    _39 = numpy.int32(_39) # postprocess
   else:
    fragments._c_closure_425(_19,_17,_18,self.__dperm,_11,_16,_15,_13,_6,_3,_4,_30,_28,_29,_27,_33,_31,_32,_25,_23,_8,_9,_22,_20,_21) # src/fusion/ExprTranspose.monty:267:13-293:9
  @staticmethod
  def __computeshape_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprPermuteDims.__computeshape__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape__3I_3I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (numpy.array([_1[_0[_2]] for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
 return ExprPermuteDims
mosek_fusion_ExprPermuteDims=__mk_mosek_fusion_ExprPermuteDims()
del __mk_mosek_fusion_ExprPermuteDims
#BEFORE CLASS
def __mk_mosek_fusion_ExprTranspose():
 class ExprTranspose(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprTranspose__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprTranspose.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprTranspose._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprTranspose._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprTranspose.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprTranspose._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprTranspose._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprTranspose.toString()')
  def __repr__(self): return 'mosek.fusion.ExprTranspose'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprTranspose.__new__(ExprTranspose)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprTranspose.__transposeShape__3I(expr._getShape_()))
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   if ((_1.nd)!=2): # src/fusion/ExprTranspose.monty:27:12-22
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   else:
    _3=(_1.shape_base)
    _4=(_1.nelem)
    _5=(_1.nnz)
    _6=(_1.hassp)
    _7=(_1.ncodeatom)
    _8=(_1.ptr_base)
    _9=(_1.sp_base)
    _10=(_1.nidxs_base)
    _11=(_1.cof_base)
    _12=(_1.code_base)
    _13=(_1.codeptr_base)
    _14=(_1.cconst_base)
    _15=(_1.i32)[_3]
    _16=(_1.i32)[(_3 + 1)]
    _17=(_1.i32)
    _18=(_1.i64)
    _19=(_1.f64)
    _0._alloc_1expr_IIIZI(2,_4,_5,_6,_7)
    _20=(_0.ptr_base)
    _21=(_0.nidxs_base)
    _22=(_0.sp_base)
    _23=(_0.cof_base)
    _24=(_0.shape_base)
    _25=(_0.code_base)
    _26=(_0.codeptr_base)
    _27=(_0.cconst_base)
    _28=(_0.i32)
    _29=(_0.i64)
    _30=(_0.f64)
    _28[_24] = _16
    _28[(_24 + 1)] = _15
    _28[_20] = 0
    if (_7 > 0): # src/fusion/ExprTranspose.monty:68:14-27
     _28[_26] = 0
    if _6: # src/fusion/ExprTranspose.monty:71:14-19
     _31=_2._alloci32_I(_4)
     _32=_2._alloci32_I((_16 + 1))
     _33=(_2.i32)
     fragments._c_closure_426(_14,_12,_13,_15,_16,_11,_10,_8,_9,_7,_4,_31,_32,_27,_25,_26,_23,_30,_28,_29,_21,_20,_22,_19,_17,_18,_33) # src/fusion/ExprTranspose.monty:76:12-113:13
    else:
     fragments._c_closure_427(_14,_12,_13,_15,_16,_11,_10,_8,_7,_27,_25,_26,_23,_30,_28,_29,_21,_20,_19,_17,_18) # src/fusion/ExprTranspose.monty:115:15-140:11
    _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprTranspose(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
  @staticmethod
  def __transposeShape_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprTranspose.__transposeShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __transposeShape__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])!=2): # src/fusion/ExprTranspose.monty:8:12-27
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   else:
    return (numpy.array([_0[1],_0[0]], dtype=numpy.dtype(numpy.int32)))
 return ExprTranspose
mosek_fusion_ExprTranspose=__mk_mosek_fusion_ExprTranspose()
del __mk_mosek_fusion_ExprTranspose
#BEFORE CLASS
def __mk_mosek_fusion_ExprRepeat():
 class ExprRepeat(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprRepeat__n','_ExprRepeat__dim','_ExprRepeat__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      self._ctor_init_Lmosek_4fusion_4Expression_2II(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2II(*args):# mosek.fusion.Expression,int32,int32
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprRepeat.ctor(mosek.fusion.Expression,int32,int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprRepeat._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprRepeat._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprRepeat.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprRepeat._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprRepeat._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprRepeat.toString()')
  def __repr__(self): return 'mosek.fusion.ExprRepeat'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2II(expr,dim,n):
    o = ExprRepeat.__new__(ExprRepeat)
    o._ctor_init_Lmosek_4fusion_4Expression_2II(expr,dim,n)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    expr,dim,n, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(dim) and __arg_match_I__(n))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    expr,dim,n, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(dim) and __arg_alt_match_I__(n))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2II(self,expr,dim,n):
    self._ctor_init_Lmosek_4fusion_4Expression_2II(expr,numpy.int32(dim),numpy.int32(n))
  def _ctor_init_Lmosek_4fusion_4Expression_2II(self,expr,dim,n):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprRepeat.__getshape_Lmosek_4fusion_4Expression_2II(expr,dim,n))
   (self.__expr) = expr
   (self.__dim) = dim
   (self.__n) = n
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=(_3 if ((self.__dim < _3) ) else (_3 + 1))
   _20=(_5 * self.__n)
   _21=(_6 * self.__n)
   _22=(_7 * self.__n)
   _0._alloc_1expr_IIIZI(_19,_20,_21,_8,_22)
   _23=(_0.i32)
   _24=(_0.i64)
   _25=(_0.f64)
   _26=(_0.shape_base)
   _27=(_0.ptr_base)
   _28=(_0.sp_base)
   _29=(_0.nidxs_base)
   _30=(_0.cof_base)
   _31=(_0.code_base)
   _32=(_0.codeptr_base)
   _33=(_0.cconst_base)
   _34=1
   _34 = fragments._c_closure_428(_34,self.__dim,_4,_16) # src/fusion/ExprStack.monty:510:21-62
   _34 = numpy.int32(_34) # postprocess
   _35=(_16[(_4 + self.__dim)] if ((self.__dim < _3) ) else 1)
   _36=(self.__n * _35)
   _37=1
   _37 = fragments._c_closure_429(_37,self.__dim,_3,_4,_16) # src/fusion/ExprStack.monty:513:21-65
   _37 = numpy.int32(_37) # postprocess
   fragments._c_closure_430(_15,_13,_14,_12,_34,_35,_37,self.__dim,_8,self.__n,_7,_3,_5,_11,_9,_33,_31,_32,_30,_36,_25,_23,_24,_22,_29,_27,_26,_28,_4,_10,_18,_16,_17) # src/fusion/ExprStack.monty:516:8-619:9
  @staticmethod
  def __getshape_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_ExprRepeat.__getshape_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __getshape_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   _3=_0._getShape_()
   _4=int((_3).shape[0])
   if (_1 < _4): # src/fusion/ExprStack.monty:447:12-20
    _3[_1] *= _2
    return (_3)
   else:
    _5=(numpy.zeros(((_4 + 1),), dtype=numpy.dtype(numpy.int32)) if ((_1==_4) ) else _3)
    fragments._c_closure_431(_4,_5,_3) # src/fusion/ExprStack.monty:453:10-51
    _5[_1] = _2
    return (_5)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprRepeat(dim=")._a_I(self.__dim)._a_S(",")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprRepeat
mosek_fusion_ExprRepeat=__mk_mosek_fusion_ExprRepeat()
del __mk_mosek_fusion_ExprRepeat
#BEFORE CLASS
def __mk_mosek_fusion_ExprStack():
 class ExprStack(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprStack__dim','_ExprStack__exprs']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Expression_2I(*args): # []mosek.fusion.Expression,int32
      self._ctor_init__3Lmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Expression_2I(*args):# []mosek.fusion.Expression,int32
      self._ctor_alt_init__3Lmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprStack.ctor(array(mosek.fusion.Expression,ndim=1),int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprStack._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprStack._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprStack.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprStack._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprStack._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprStack.toString()')
  def __repr__(self): return 'mosek.fusion.ExprStack'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2I(exprs,dim):
    o = ExprStack.__new__(ExprStack)
    o._ctor_init__3Lmosek_4fusion_4Expression_2I(exprs,dim)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    exprs,dim, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(exprs) and __arg_match_I__(dim))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    exprs,dim, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(exprs) and __arg_alt_match_I__(dim))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2I(self,exprs,dim):
    self._ctor_init__3Lmosek_4fusion_4Expression_2I(numpy.array(exprs,dtype=numpy.dtype(object)),numpy.int32(dim))
  def _ctor_init__3Lmosek_4fusion_4Expression_2I(self,exprs,dim):
   assert exprs is None or isinstance(exprs,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprStack.__getshape__3Lmosek_4fusion_4Expression_2I(exprs,dim))
   (self.__exprs) = numpy.array([exprs[_0] for _0 in range(0,int((exprs).shape[0]))], dtype=numpy.dtype(object))
   (self.__dim) = dim
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__exprs).shape[0])
   if (_3==1): # src/fusion/ExprStack.monty:59:12-18
    self.__exprs[0]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
   else:
    for _4 in range(0,_3):
     self.__exprs[((_3 - _4) - 1)]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _10=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _11=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _12=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _13=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _14=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _15=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _16=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _17=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    for _18 in range(0,_3):
     _1._pop_1expr_()
     _5[_18] = (_1.nd)
     _6[_18] = (_1.shape_base)
     _7[_18] = (_1.nelem)
     _8[_18] = (_1.nnz)
     _9[_18] = (_1.ncodeatom)
     _10[_18] = (1 if ((_1.hassp) ) else 0)
     _11[_18] = (_1.ptr_base)
     _13[_18] = (_1.sp_base)
     _12[_18] = (_1.nidxs_base)
     _14[_18] = (_1.cof_base)
     _15[_18] = (_1.code_base)
     _16[_18] = (_1.codeptr_base)
     _17[_18] = (_1.cconst_base)
    _19=(_1.i32)
    _20=(_1.i64)
    _21=(_1.f64)
    _22=_5[0]
    _23=_6[0]
    _24=(_10[0]==0)
    _25=False
    _24,_25 = fragments._c_closure_432(_24,self.__dim,_10,_25,_3,_22,_5,_23,_6,_19) # src/fusion/ExprStack.monty:109:10-118:11
    if _25: # src/fusion/ExprStack.monty:119:14-30
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression dimensions")
    _26=0
    _26 = fragments._c_closure_433(self.__dim,_3,_22,_26,_6,_19) # src/fusion/ExprStack.monty:123:10-124:24
    _26 = numpy.int32(_26) # postprocess
    _27=(_22 if ((self.__dim < _22) ) else (_22 + 1))
    if (_27!=self._getND_()): # src/fusion/ExprStack.monty:128:14-28
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Mismatching dimensions")
    _28=0
    _29=0
    _30=0
    _31=False
    _31,_28,_29,_30 = fragments._c_closure_434(_3,_9,_7,_8,_31,_28,_29,_30) # src/fusion/ExprStack.monty:134:10-140:11
    _28 = numpy.int32(_28) # postprocess
    _29 = numpy.int32(_29) # postprocess
    _30 = numpy.int32(_30) # postprocess
    _32=1
    _32 = fragments._c_closure_435(_32,self.__dim,_23,_19) # src/fusion/ExprStack.monty:142:26-70
    _32 = numpy.int32(_32) # postprocess
    _33=(numpy.array([_19[(_6[_34] + self.__dim)] for _34 in range(0,_3)], dtype=numpy.dtype(numpy.int32)) if ((self.__dim < _22) ) else numpy.array([1 for _35 in range(0,_3)], dtype=numpy.dtype(numpy.int32)))
    _36=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _36[0] = 0
    fragments._c_closure_436(_33,_3,_36) # src/fusion/ExprStack.monty:144:51-105
    _37=0
    _37 = fragments._c_closure_437(_37,_33,_3) # src/fusion/ExprStack.monty:145:26-58
    _37 = numpy.int32(_37) # postprocess
    _38=1
    _38 = fragments._c_closure_438(_38,self.__dim,_22,_23,_19) # src/fusion/ExprStack.monty:146:26-70
    _38 = numpy.int32(_38) # postprocess
    if _24: # src/fusion/ExprStack.monty:148:14-19
     _0._alloc_1expr_IIIZI(_27,_29,_30,False,_28)
     _39=(_0.ptr_base)
     _40=(_0.shape_base)
     _41=(_0.nidxs_base)
     _42=(_0.cof_base)
     _43=(_0.code_base)
     _44=(_0.codeptr_base)
     _45=(_0.cconst_base)
     _46=(_0.i32)
     _47=(_0.i64)
     _48=(_0.f64)
     _49=(_2._alloci32_I((_29 + 1)) if ((_28 > 0) ) else (- 9999))
     _50=(_2.i32)
     fragments._c_closure_439(_22,_46,_40,_23,_19) # src/fusion/ExprStack.monty:166:12-63
     _46[(_40 + self.__dim)] = _26
     fragments._c_closure_440(_17,_15,_16,_14,_32,_33,_38,_3,_9,_12,_31,_11,_45,_43,_44,_42,_48,_46,_47,_41,_39,_21,_19,_20) # src/fusion/ExprStack.monty:169:12-207:13
    else:
     _51=1
     _51 = fragments._c_closure_441(self.__dim,_51,_23,_19) # src/fusion/ExprStack.monty:211:12-61
     _51 = numpy.int32(_51) # postprocess
     _51 *= _26
     _51 = fragments._c_closure_442(self.__dim,_22,_51,_23,_19) # src/fusion/ExprStack.monty:213:12-64
     _51 = numpy.int32(_51) # postprocess
     _52=(_29 < _51)
     _0._alloc_1expr_IIIZI(_27,_29,_30,_52,_28)
     _53=(_0.ptr_base)
     _54=(_0.nidxs_base)
     _55=((_0.sp_base) if (_52 ) else _0._alloci64_I(_29))
     _56=(_0.cof_base)
     _57=(_0.code_base)
     _58=(_0.codeptr_base)
     _59=(_0.cconst_base)
     _60=(_0.shape_base)
     for _61 in range(0,_22):
      (_0.i32)[(_60 + _61)] = _19[(_23 + _61)]
     (_0.i32)[(_60 + self.__dim)] = _26
     _62=(_0.i32)
     _63=(_0.i64)
     _64=(_0.f64)
     if (self.__dim==0): # src/fusion/ExprStack.monty:241:16-24
      fragments._c_closure_443(_17,_15,_16,_14,_10,_3,_9,_22,_7,_12,_11,_59,_57,_58,_56,_64,_62,_63,_28,_54,_53,_55,_6,_13,_21,_19,_20) # src/fusion/ExprStack.monty:241:26-299:13
     else:
      _65=0
      _65 = fragments._c_closure_444(_65,_62,_27,_60) # src/fusion/ExprStack.monty:302:30-104
      _65 = numpy.int32(_65) # postprocess
      _66=_2._alloci64_I(_29)
      _67=_2._alloci32_I(_29)
      _68=_2._alloci32_I(_29)
      _69=_2._alloci32_I(_29)
      _70=_2._alloci32_I(_29)
      _71=_2._alloci32_I((_65 + 1))
      _72=(_2.i32)
      _73=(_2.i64)
      fragments._c_closure_445(_33,_38,_10,_3,_7,_36,_26,_13,_67,_68,_66,_20,_72,_73) # src/fusion/ExprStack.monty:314:14-347:15
      _69,_70 = fragments._c_closure_446(_69,_62,_27,_29,_60,_70,_66,_72,_73,_71) # src/fusion/ExprStack.monty:352:14-379:15
      _69 = numpy.int32(_69) # postprocess
      _70 = numpy.int32(_70) # postprocess
      fragments._c_closure_447(_17,_15,_16,_14,_69,_9,_12,_31,_11,_59,_57,_58,_56,_64,_62,_63,_28,_29,_54,_53,_55,_67,_68,_66,_21,_19,_20,_72,_73) # src/fusion/ExprStack.monty:384:14-423:15
     if (not _52): # src/fusion/ExprStack.monty:425:16-26
      _0._popi64_I(_29)
  @staticmethod
  def __getshape_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprStack.__getshape__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __getshape__3Lmosek_4fusion_4Expression_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])==0): # src/fusion/ExprStack.monty:17:12-24
    raise mosek_fusion_LengthError._ctor_S("Cannot stack empty list")
   elif (int((_0).shape[0])==1): # src/fusion/ExprStack.monty:19:16-28
    return (_0[0]._getShape_())
   else:
    _2=_monty.initJaggedArray([_0[_3]._getShape_() for _3 in range(0,int((_0).shape[0]))], 1)
    _4=_2[0]
    _5=int((_4).shape[0])
    for _6 in range(1,int((_2).shape[0])):
     if (_5!=int((_2[_6]).shape[0])): # src/fusion/ExprStack.monty:26:16-36
      raise mosek_fusion_DimensionError._ctor_S("Mismatching expression dimensions")
     for _7 in range(0,_1):
      if (_4[_7]!=_2[_6][_7]): # src/fusion/ExprStack.monty:29:18-42
       raise mosek_fusion_DimensionError._ctor_S("mismatching expression dimensions")
     for _8 in range((_1 + 1),_5):
      if (_4[_8]!=_2[_6][_8]): # src/fusion/ExprStack.monty:32:18-42
       raise mosek_fusion_DimensionError._ctor_S("mismatching expression dimensions")
    if (_1==_5): # src/fusion/ExprStack.monty:35:14-23
     _9=numpy.zeros(((_5 + 1),), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_448(_5,_9,_4) # src/fusion/ExprStack.monty:36:43-86
     _9[_5] = int((_2).shape[0])
     return (_9)
    else:
     _10=_4
     fragments._c_closure_449(_1,_10,_2) # src/fusion/ExprStack.monty:42:12-43:46
     return (_10)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprStack(dim=")._a_I(self.__dim)._a_S(",[")._a_S(self.__exprs[0]._toString_())
   for _1 in range(1,int((self.__exprs).shape[0])):
    _0._a_S(",")._a_S(self.__exprs[_1]._toString_())
   _0._a_S("])")
   return (_0._toString_())
 return ExprStack
mosek_fusion_ExprStack=__mk_mosek_fusion_ExprStack()
del __mk_mosek_fusion_ExprStack
#BEFORE CLASS
def __mk_mosek_fusion_ExprInner():
 class ExprInner(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprInner__vcof','_ExprInner__vsub','_ExprInner__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3D(*args):# mosek.fusion.Expression,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args): # mosek.fusion.Expression,[]int64,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):# mosek.fusion.Expression,[]int64,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3J_3D(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args): # mosek.fusion.Expression,[,]int32,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):# mosek.fusion.Expression,[,]int32,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(int32,ndim=2),array(double,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprInner._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprInner._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprInner.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprInner._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprInner._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprInner.toString()')
  def __repr__(self): return 'mosek.fusion.ExprInner'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3J_3D(expr,vsub,vcof):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(expr,vsub,vcof)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
    if len(args) != 3: return False
    expr,vsub,vcof, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3J__(vsub) and __arg_match__3D__(vcof))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
    if len(args) != 3: return False
    expr,vsub,vcof, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3J__(vsub) and __arg_alt_match__3D__(vcof))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr,vsub,vcof):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(expr,numpy.array(vsub,dtype=numpy.dtype(numpy.int64)),numpy.array(vcof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr,vsub,vcof):
   assert vsub is None or isinstance(vsub,numpy.ndarray)
   assert vcof is None or isinstance(vcof,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   (self.__expr) = expr
   (self.__vsub) = vsub
   (self.__vcof) = vcof
   if (int((vsub).shape[0])!=int((vcof).shape[0])): # src/fusion/ExprMul.monty:2338:12-34
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of vcof and vsub")
   _0=expr._getShape_()
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   _3=False
   _3,_2 = fragments._c_closure_450(_3,_2,_1,vsub) # src/fusion/ExprMul.monty:2346:8-2354:9
   if _2: # src/fusion/ExprMul.monty:2355:12-22
    raise mosek_fusion_IndexError._ctor_S("Unordered coefficcient subscripts")
   if _3: # src/fusion/ExprMul.monty:2357:12-22
    raise mosek_fusion_IndexError._ctor_S("Coefficient subscript out of bounds")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3D(expr,vcof):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3D(expr,vcof)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    expr,vcof, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3D__(vcof))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    expr,vcof, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3D__(vcof))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3D(self,expr,vcof):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3D(expr,numpy.array(vcof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3D(self,expr,vcof):
   assert vcof is None or isinstance(vcof,numpy.ndarray)
   mosek_fusion_ExprInner._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr,mosek.fusion.ExprInner.__range_I(int((vcof).shape[0])),vcof)
   _0=expr._getShape_()
   if ((int((_0).shape[0])!=1) or (_0[0]!=int((vcof).shape[0]))): # src/fusion/ExprMul.monty:2326:12-54
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(expr,vsub,vcof):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(expr,vsub,vcof)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
    if len(args) != 3: return False
    expr,vsub,vcof, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3_5I__(vsub) and __arg_match__3D__(vcof))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
    if len(args) != 3: return False
    expr,vsub,vcof, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3_5I__(vsub) and __arg_alt_match__3D__(vcof))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I_3D(self,expr,vsub,vcof):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(expr,numpy.array(vsub,dtype=numpy.dtype(numpy.int32)),numpy.array(vcof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(self,expr,vsub,vcof):
   assert vsub is None or isinstance(vsub,numpy.ndarray)
   assert vcof is None or isinstance(vcof,numpy.ndarray)
   mosek_fusion_ExprInner._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr,mosek.fusion.ExprInner.__convert__3I_3_5I(expr._getShape_(),vsub),vcof)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.nidxs_base)
   _11=(_1.sp_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=0
   _19 = fragments._c_closure_451(_7,_4,_9,_19,_11,self.__vsub,_16,_17) # src/fusion/ExprMul.monty:2386:8-2401:9
   _19 = numpy.int32(_19) # postprocess
   _20=((_6 + (2 * _5)) if ((_6 > 0) ) else 0)
   _0._alloc_1expr_IIIZI(0,1,_19,False,_20)
   _21=(_0.ptr_base)
   _22=(_0.nidxs_base)
   _23=(_0.cof_base)
   _24=(_0.code_base)
   _25=(_0.codeptr_base)
   _26=(_0.cconst_base)
   _27=(_0.i32)
   _28=(_0.i64)
   _29=(_0.f64)
   _27[_21] = 0
   _27[(_21 + 1)] = _19
   if (_20 > 0): # src/fusion/ExprMul.monty:2421:12-26
    _27[_25] = 0
   _30=0
   _31=0
   _30,_31 = fragments._c_closure_452(_15,_13,_30,_14,_12,_7,_31,_4,_10,_9,_26,_24,_25,_23,_29,_27,_28,_20,_22,_11,self.__vcof,self.__vsub,_18,_16,_17) # src/fusion/ExprMul.monty:2426:8-2489:9
   _30 = numpy.int32(_30) # postprocess
   _31 = numpy.int32(_31) # postprocess
  @staticmethod
  def __range_alt_I(_t__0):
    return mosek_fusion_ExprInner.__range_I(numpy.int32(__0))
  @staticmethod
  def __range_I(_0):
   return (numpy.array([_1 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def __convert_alt__3I_3_5I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprInner.__convert__3I_3_5I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __convert__3I_3_5I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=int((_0).shape[0])
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _3[(_2 - 1)] = 1
   fragments._c_closure_453(_2,_3,_0) # src/fusion/ExprMul.monty:2308:43-97
   _4=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_454(_2,_4,_3,_1) # src/fusion/ExprMul.monty:2310:8-2312:39
   return (_4)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprInner()")
 return ExprInner
mosek_fusion_ExprInner=__mk_mosek_fusion_ExprInner()
del __mk_mosek_fusion_ExprInner
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulDiagRight():
 class ExprMulDiagRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulDiagRight__expr','_ExprMulDiagRight__mval','_ExprMulDiagRight__msubj','_ExprMulDiagRight__msubi','_ExprMulDiagRight__mdim1','_ExprMulDiagRight__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulDiagRight.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulDiagRight'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulDiagRight.__new__(ExprMulDiagRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim1], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulDiagRight.__new__(ExprMulDiagRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprMulDiagRight._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulDiagRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.codeptr_base)
   _14=(_1.code_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=_16[_8]
   _20=_16[(_8 + 1)]
   _21=int((self.__mval).shape[0])
   _22=_2._alloci32_I(_21)
   _23=_2._alloci32_I((self.__mdim1 + 1))
   _24=(_2.i32)
   fragments._c_closure_455(self.__mdim1,_21,self.__msubj,_24,_23,_22) # src/fusion/ExprMul.monty:2079:8-2085:9
   _25=0
   _26=0
   _27=0
   _25,_27,_26 = fragments._c_closure_456(_13,_20,_7,self.__mdim1,_21,self.__msubi,self.__msubj,_6,_5,_9,_25,_27,_26,_10,_16,_17,_24,_22) # src/fusion/ExprMul.monty:2094:8-2138:9
   _25 = numpy.int32(_25) # postprocess
   _27 = numpy.int32(_27) # postprocess
   _26 = numpy.int32(_26) # postprocess
   _28=(_27 < _19)
   _0._alloc_1expr_IIIZI(1,_27,_26,_28,_25)
   _29=(_0.ptr_base)
   _30=(_0.nidxs_base)
   _31=((_0.sp_base) if (_28 ) else _0._alloci64_I(_27))
   _32=(_0.cof_base)
   _33=(_0.shape_base)
   _34=(_0.code_base)
   _35=(_0.codeptr_base)
   _36=(_0.cconst_base)
   _37=(_0.i64)
   _38=(_0.f64)
   _39=(_0.i32)
   _40=(_2.i32)
   _41=0
   _42=0
   _43=0
   _39[_29] = 0
   if (_25 > 0): # src/fusion/ExprMul.monty:2168:14-28
    _39[_35] = 0
   _39[_33] = self.__mdim1
   _41,_43,_42 = fragments._c_closure_457(_15,_14,_41,_13,_12,_20,_43,_7,self.__mdim1,_21,self.__msubi,self.__msubj,self.__mval,_6,_5,_11,_42,_9,_36,_34,_35,_32,_38,_39,_37,_30,_29,_31,_10,_18,_16,_17,_40,_22) # src/fusion/ExprMul.monty:2173:10-2284:11
   _41 = numpy.int32(_41) # postprocess
   _43 = numpy.int32(_43) # postprocess
   _42 = numpy.int32(_42) # postprocess
   if (not _28): # src/fusion/ExprMul.monty:2285:14-24
    _0._popi64_I(_27)
   if (not (_26==_42)): # src/fusion/ExprMul.monty:2289:14-31
    raise mosek_fusion_UnexpectedError._ctor_S("Incorrect number of non-zeros")
   if (not (_27==_43)): # src/fusion/ExprMul.monty:2290:14-32
    raise mosek_fusion_UnexpectedError._ctor_S("Incorrect number of elements")
   _2._clear_()
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulDiagRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=_5._getShape_()
   if (int((_6).shape[0]) > 2): # src/fusion/ExprMul.monty:1965:12-27
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or ((_1 < 0) or ((_7 < 0) or (_8 < 0)))): # src/fusion/ExprMul.monty:1971:12-60
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_0!=_8) or (_1!=_7)): # src/fusion/ExprMul.monty:1973:12-44
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:1975:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   _11=False
   _10,_11 = fragments._c_closure_458(_10,_11,_0,_1,_9,_2,_3) # src/fusion/ExprMul.monty:1982:8-1992:9
   if _10: # src/fusion/ExprMul.monty:1993:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _11: # src/fusion/ExprMul.monty:1995:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulDiagRight(")._a_S(self.__expr._toString_())._a_S(",m)")._toString_())
 return ExprMulDiagRight
mosek_fusion_ExprMulDiagRight=__mk_mosek_fusion_ExprMulDiagRight()
del __mk_mosek_fusion_ExprMulDiagRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulDiagLeft():
 class ExprMulDiagLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulDiagLeft__expr','_ExprMulDiagLeft__mval','_ExprMulDiagLeft__msubj','_ExprMulDiagLeft__msubi','_ExprMulDiagLeft__mdim1','_ExprMulDiagLeft__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulDiagLeft.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulDiagLeft'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulDiagLeft.__new__(ExprMulDiagLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim0], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulDiagLeft.__new__(ExprMulDiagLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprMulDiagLeft._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulDiagLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ncodeatom)
   _11=(_1.ptr_base)
   _12=(_1.code_base)
   _13=(_1.cconst_base)
   _14=(_1.codeptr_base)
   _15=(_1.shape_base)
   _16=(_1.sp_base)
   _17=(_1.nidxs_base)
   _18=(_1.cof_base)
   _19=(_1.cconst_base)
   if (_6!=2): # src/fusion/ExprMul.monty:1689:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _20=_3[_15]
   _21=_3[(_15 + 1)]
   _22=int((self.__msubi).shape[0])
   if (not _9): # src/fusion/ExprMul.monty:1697:12-21
    _23=0
    _24=0
    _25=0
    _26=0
    _26,_25,_24,_23 = fragments._c_closure_459(_14,_21,_26,self.__msubi,self.__msubj,_10,_11,_25,_24,_23,_3) # src/fusion/ExprMul.monty:1704:10-1714:11
    _26 = numpy.int32(_26) # postprocess
    _25 = numpy.int32(_25) # postprocess
    _24 = numpy.int32(_24) # postprocess
    _23 = numpy.int32(_23) # postprocess
    _27=(_24 < self.__mdim0)
    _0._alloc_1expr_IIIZI(1,_24,_23,_27,_25)
    _28=(_0.ptr_base)
    _29=(_0.nidxs_base)
    _30=((_0.sp_base) if (_27 ) else _0._alloci64_I(_24))
    _31=(_0.cof_base)
    _32=(_0.shape_base)
    _33=(_0.code_base)
    _34=(_0.codeptr_base)
    _35=(_0.cconst_base)
    _36=(_0.i64)
    _37=(_0.f64)
    _38=(_0.i32)
    fragments._c_closure_460(_13,_12,_14,_18,_21,self.__mdim0,self.__msubi,self.__msubj,self.__mval,_10,_17,_11,_35,_33,_34,_31,_37,_38,_36,_25,_29,_28,_32,_30,_5,_3,_4) # src/fusion/ExprMul.monty:1731:10-1773:11
    if (not _27): # src/fusion/ExprMul.monty:1774:14-24
     _0._popi64_I(_24)
   else:
    _39=_2._alloci32_I((_21 + 1))
    _40=_2._alloci32_I(_7)
    _41=_2._alloci32_I((self.__mdim0 + 1))
    _42=(_2.i32)
    _43=0
    _44=0
    _45=0
    _43,_45,_44 = fragments._c_closure_461(_14,_21,self.__msubi,self.__msubj,_10,_7,_11,_43,_45,_44,_16,_3,_4,_39,_40,_42) # src/fusion/ExprMul.monty:1786:10-1832:11
    _43 = numpy.int32(_43) # postprocess
    _45 = numpy.int32(_45) # postprocess
    _44 = numpy.int32(_44) # postprocess
    _46=(_45 < self.__mdim0)
    _0._alloc_1expr_IIIZI(1,_45,_44,_46,_43)
    _47=(_0.ptr_base)
    _48=(_0.nidxs_base)
    _49=((_0.sp_base) if (_46 ) else _0._alloci64_I(_45))
    _50=(_0.cof_base)
    _51=(_0.shape_base)
    _52=(_0.code_base)
    _53=(_0.codeptr_base)
    _54=(_0.cconst_base)
    _55=(_0.i64)
    _56=(_0.f64)
    _57=(_0.i32)
    _58=0
    _59=0
    _60=0
    _61=0
    _62=0
    _57[_47] = 0
    if (_10 > 0): # src/fusion/ExprMul.monty:1856:16-29
     _57[_53] = 0
    _57[_51] = self.__mdim0
    _60,_58,_61,_62,_59 = fragments._c_closure_462(_13,_12,_60,_14,_18,_21,_58,_61,_62,self.__msubi,self.__msubj,self.__mval,_10,_7,_17,_59,_11,_54,_52,_53,_50,_56,_57,_55,_48,_47,_49,_16,_5,_3,_4,_40,_42) # src/fusion/ExprMul.monty:1860:12-1912:13
    _60 = numpy.int32(_60) # postprocess
    _58 = numpy.int32(_58) # postprocess
    _61 = numpy.int32(_61) # postprocess
    _62 = numpy.int32(_62) # postprocess
    _59 = numpy.int32(_59) # postprocess
    if (_59!=_44): # src/fusion/ExprMul.monty:1916:16-27
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of non-zeros")
    if (_58!=_45): # src/fusion/ExprMul.monty:1917:16-30
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of elements")
    if (not _46): # src/fusion/ExprMul.monty:1920:14-24
     _0._popi64_I(_45)
   _2._clear_()
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulDiagLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=_5._getShape_()
   if (int((_6).shape[0])!=2): # src/fusion/ExprMul.monty:1580:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:1586:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_1!=_7) or (_0!=_8)): # src/fusion/ExprMul.monty:1588:12-44
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:1590:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   _11=False
   _10,_11 = fragments._c_closure_463(_10,_11,_0,_1,_9,_2,_3) # src/fusion/ExprMul.monty:1597:8-1607:9
   if _10: # src/fusion/ExprMul.monty:1608:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _11: # src/fusion/ExprMul.monty:1610:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulDiagLeft(m,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulDiagLeft
mosek_fusion_ExprMulDiagLeft=__mk_mosek_fusion_ExprMulDiagLeft()
del __mk_mosek_fusion_ExprMulDiagLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulElement():
 class ExprMulElement(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulElement__expr','_ExprMulElement__msp','_ExprMulElement__mcof']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3D_3JLmosek_4fusion_4Expression_2(*args): # []double,[]int64,mosek.fusion.Expression
      self._ctor_init__3D_3JLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):# []double,[]int64,mosek.fusion.Expression
      self._ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulElement.ctor(array(double,ndim=1),array(int64,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulElement._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulElement._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulElement.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulElement._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulElement._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulElement.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulElement'
  @staticmethod
  def _ctor__3D_3JLmosek_4fusion_4Expression_2(mcof,msp,expr):
    o = ExprMulElement.__new__(ExprMulElement)
    o._ctor_init__3D_3JLmosek_4fusion_4Expression_2(mcof,msp,expr)
    return o
  @staticmethod
  def __match_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    mcof,msp,expr, = args
    return (__arg_match__3D__(mcof) and __arg_match__3J__(msp) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    mcof,msp,expr, = args
    return (__arg_alt_match__3D__(mcof) and __arg_alt_match__3J__(msp) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2(self,mcof,msp,expr):
    self._ctor_init__3D_3JLmosek_4fusion_4Expression_2(numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),numpy.array(msp,dtype=numpy.dtype(numpy.int64)),expr)
  def _ctor_init__3D_3JLmosek_4fusion_4Expression_2(self,mcof,msp,expr):
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   assert msp is None or isinstance(msp,numpy.ndarray)
   mosek_fusion_ExprMulElement._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(self,mcof,msp,expr,1)
   _0=expr._getShape_()
   if (int((mcof).shape[0])!=int((msp).shape[0])): # src/fusion/ExprMul.monty:1359:12-33
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix specification")
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   _3=False
   _2,_3 = fragments._c_closure_464(_2,_3,msp,_1) # src/fusion/ExprMul.monty:1365:8-1373:9
   if _2: # src/fusion/ExprMul.monty:1374:12-20
    raise mosek_fusion_IndexError._ctor_S("Invalid matrix data")
   if _3: # src/fusion/ExprMul.monty:1377:12-22
    raise mosek_fusion_IndexError._ctor_S("Matrix data not sorted")
  @staticmethod
  def _ctor__3D_3JLmosek_4fusion_4Expression_2I(cof,msp,expr,validated):
    o = ExprMulElement.__new__(ExprMulElement)
    o._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(cof,msp,expr,validated)
    return o
  @staticmethod
  def __match_ctor__3D_3JLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    cof,msp,expr,validated, = args
    return (__arg_match__3D__(cof) and __arg_match__3J__(msp) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    cof,msp,expr,validated, = args
    return (__arg_alt_match__3D__(cof) and __arg_alt_match__3J__(msp) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2I(self,cof,msp,expr,validated):
    self._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(msp,dtype=numpy.dtype(numpy.int64)),expr,numpy.int32(validated))
  def _ctor_init__3D_3JLmosek_4fusion_4Expression_2I(self,cof,msp,expr,validated):
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert msp is None or isinstance(msp,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
   (self.__mcof) = cof
   (self.__msp) = msp
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.nidxs_base)
   _11=(_1.sp_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=0
   _20=0
   _21=0
   _19,_21,_20 = fragments._c_closure_465(_14,_7,self.__msp,_6,_4,_9,_19,_21,_20,_11,_16,_17) # src/fusion/ExprMul.monty:1406:8-1432:9
   _19 = numpy.int32(_19) # postprocess
   _21 = numpy.int32(_21) # postprocess
   _20 = numpy.int32(_20) # postprocess
   _22=1
   _22 = fragments._c_closure_466(_3,_22,_8,_16) # src/fusion/ExprMul.monty:1435:24-67
   _22 = numpy.int64(_22) # postprocess
   _23=(_21 < _22)
   _24=_3
   _0._alloc_1expr_IIIZI(_24,_21,_20,_23,_19)
   _25=(_0.ptr_base)
   _26=(_0.shape_base)
   _27=(_0.nidxs_base)
   _28=((_0.sp_base) if (_23 ) else _0._alloci64_I(_21))
   _29=(_0.cof_base)
   _30=(_0.code_base)
   _31=(_0.codeptr_base)
   _32=(_0.cconst_base)
   _33=(_0.i32)
   _34=(_0.i64)
   _35=(_0.f64)
   fragments._c_closure_467(_15,_13,_14,_12,_7,self.__mcof,self.__msp,_6,_4,_10,_9,_32,_30,_31,_29,_35,_33,_34,_19,_24,_27,_25,_26,_28,_8,_11,_18,_16,_17) # src/fusion/ExprMul.monty:1454:8-1535:9
   if (not _23): # src/fusion/ExprMul.monty:1536:12-22
    _0._popi64_I(_21)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulElement(M,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulElement
mosek_fusion_ExprMulElement=__mk_mosek_fusion_ExprMulElement()
del __mk_mosek_fusion_ExprMulElement
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulScalarConst():
 class ExprMulScalarConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulScalarConst__expr','_ExprMulScalarConst__c']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      self._ctor_init_DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_DLmosek_4fusion_4Expression_2(*args):# double,mosek.fusion.Expression
      self._ctor_alt_init_DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulScalarConst.ctor(double,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulScalarConst'
  @staticmethod
  def _ctor_DLmosek_4fusion_4Expression_2(c,expr):
    o = ExprMulScalarConst.__new__(ExprMulScalarConst)
    o._ctor_init_DLmosek_4fusion_4Expression_2(c,expr)
    return o
  @staticmethod
  def __match_ctor_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    c,expr, = args
    return (__arg_match_D__(c) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    c,expr, = args
    return (__arg_alt_match_D__(c) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_DLmosek_4fusion_4Expression_2(self,c,expr):
    self._ctor_init_DLmosek_4fusion_4Expression_2(numpy.float64(c),expr)
  def _ctor_init_DLmosek_4fusion_4Expression_2(self,c,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__c) = c
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ncodeatom)
   _11=(_1.ptr_base)
   _12=(_1.code_base)
   _13=(_1.cconst_base)
   _14=(_1.codeptr_base)
   _15=(_1.shape_base)
   _16=(_1.sp_base)
   _17=(_1.nidxs_base)
   _18=(_1.cof_base)
   _19=(_1.cconst_base)
   _20=(0 if ((_10==0) ) else (_10 + (2 * _8)))
   _0._alloc_1expr_IIIZI(_6,_7,_8,_9,_20)
   _21=(_0.i64)
   _22=(_0.f64)
   _23=(_0.i32)
   _24=(_0.ptr_base)
   _25=(_0.nidxs_base)
   _26=(_0.cof_base)
   _27=(_0.code_base)
   _28=(_0.codeptr_base)
   _29=(_0.cconst_base)
   _30=(_0.hassp)
   _31=(_0.shape_base)
   _32=(_0.sp_base)
   fragments._c_closure_468(self.__c,_13,_12,_14,_18,_9,_10,_6,_7,_17,_8,_11,_29,_27,_28,_26,_22,_23,_21,_25,_24,_31,_32,_15,_16,_5,_3,_4) # src/fusion/ExprMul.monty:1295:8-1326:9
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulScalarConst()")
 return ExprMulScalarConst
mosek_fusion_ExprMulScalarConst=__mk_mosek_fusion_ExprMulScalarConst()
del __mk_mosek_fusion_ExprMulScalarConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprScalarMul():
 class ExprScalarMul(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprScalarMul__expr','_ExprScalarMul__mval','_ExprScalarMul__msubj','_ExprScalarMul__msubi','_ExprScalarMul__mdim1','_ExprScalarMul__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprScalarMul.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprScalarMul._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScalarMul.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprScalarMul._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScalarMul.toString()')
  def __repr__(self): return 'mosek.fusion.ExprScalarMul'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprScalarMul.__new__(ExprScalarMul)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim0,mdim1], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprScalarMul.__new__(ExprScalarMul)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprScalarMul._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprScalarMul.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.hassp)
   _7=(_1.ncodeatom)
   _8=(_1.ptr_base)
   _9=(_1.sp_base)
   _10=(_1.nidxs_base)
   _11=(_1.cof_base)
   _12=(_1.code_base)
   _13=(_1.codeptr_base)
   _14=(_1.cconst_base)
   _15=(_1.i32)
   _16=(_1.i64)
   _17=(_1.f64)
   _18=int((self.__mval).shape[0])
   if (_3!=0): # src/fusion/ExprMul.monty:1157:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid expression shape")
   if (_4==0): # src/fusion/ExprMul.monty:1160:12-22
    _0._alloc_1expr_IIIZ(2,0,0,True)
    (_0.i32)[(_0.shape_base)] = self.__mdim0
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdim1
   else:
    _19=(_18 * (_7 + ((2 * _5) if ((_7 > 0) ) else 0)))
    _0._alloc_1expr_IIIZI(2,_18,(_18 * _5),True,_19)
    _20=(_0.ptr_base)
    _21=(_0.nidxs_base)
    _22=(_0.sp_base)
    _23=(_0.cof_base)
    _24=(_0.shape_base)
    _25=(_0.code_base)
    _26=(_0.codeptr_base)
    _27=(_0.cconst_base)
    _28=(_0.i32)
    _29=(_0.i64)
    _30=(_0.f64)
    _28[_24] = self.__mdim0
    _28[(_24 + 1)] = self.__mdim1
    _31=0
    _32=0
    _28[_20] = 0
    _31,_32 = fragments._c_closure_469(_14,_12,_31,_13,_11,self.__mdim1,_18,self.__msubi,self.__msubj,self.__mval,_7,_10,_5,_32,_27,_25,_26,_23,_30,_28,_29,_21,_20,_22,_17,_15,_16) # src/fusion/ExprMul.monty:1186:10-1223:13
    _31 = numpy.int32(_31) # postprocess
    _32 = numpy.int32(_32) # postprocess
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprScalarMul.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=_5._getND_()
   if (_6!=0): # src/fusion/ExprMul.monty:1057:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:1059:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:1061:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _7=int((_2).shape[0])
   _8=False
   _9=False
   _8,_9 = fragments._c_closure_470(_8,_9,_0,_1,_7,_2,_3) # src/fusion/ExprMul.monty:1068:8-1078:9
   if _8: # src/fusion/ExprMul.monty:1079:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _9: # src/fusion/ExprMul.monty:1081:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprScalarMul(M,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprScalarMul
mosek_fusion_ExprScalarMul=__mk_mosek_fusion_ExprScalarMul()
del __mk_mosek_fusion_ExprScalarMul
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulRight():
 class ExprMulRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulRight__expr','_ExprMulRight__mval','_ExprMulRight__msubj','_ExprMulRight__msubi','_ExprMulRight__mdim1','_ExprMulRight__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulRight.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulRight'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulRight.__new__(ExprMulRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulRight.__computeshape_I_3I(mdim1,expr._getShape_()))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulRight.__new__(ExprMulRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprMulRight._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   if (_6!=2): # src/fusion/ExprMul.monty:609:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.ncodeatom)
   _10=(_1.hassp)
   _11=(_1.ptr_base)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.codeptr_base)
   _17=(_1.code_base)
   _18=(_1.cconst_base)
   _19=_3[_12]
   _20=_3[(_12 + 1)]
   _21=int((self.__mval).shape[0])
   _22=(_21 < (numpy.int64(self.__mdim0) * numpy.int64(self.__mdim1)))
   if _22: # src/fusion/ExprMul.monty:631:12-15
    _23=_2._alloci32_I((self.__mdim1 + 1))
    _24=_2._alloci32_I(_21)
    _25=_2._alloci32_I((_19 + 1))
    _26=(_2.i32)
    fragments._c_closure_471(_19,_25,_23,self.__mdim1,_21,_24,self.__msubj,_26) # src/fusion/ExprMul.monty:638:10-651:11
    if _10: # src/fusion/ExprMul.monty:654:14-19
     _27=0
     _28=0
     _29=0
     _27,_28,_29 = fragments._c_closure_472(_16,_20,_21,_24,self.__msubi,self.__msubj,self.__mval,_9,_7,_11,_27,_28,_29,_13,_3,_4,_26) # src/fusion/ExprMul.monty:662:12-697:13
     _27 = numpy.int32(_27) # postprocess
     _28 = numpy.int32(_28) # postprocess
     _29 = numpy.int64(_29) # postprocess
     _30=(_28 < (_19 * self.__mdim1))
     _0._alloc_1expr_IIIZI(2,_28,numpy.int32(_29),_30,_27)
     _31=(_0.ptr_base)
     _32=(_0.nidxs_base)
     _33=((_0.sp_base) if (_30 ) else _0._alloci64_I(_28))
     _34=(_0.cof_base)
     _35=(_0.shape_base)
     _36=(_0.codeptr_base)
     _37=(_0.code_base)
     _38=(_0.cconst_base)
     _39=(_0.i32)
     _40=(_0.i64)
     _41=(_0.f64)
     _39[_35] = _19
     _39[(_35 + 1)] = self.__mdim1
     _39[_31] = 0
     if (_27 > 0): # src/fusion/ExprMul.monty:720:16-30
      _39[_36] = 0
     _42=0
     _43=0
     _44=0
     _45=0
     _43,_44,_42,_45 = fragments._c_closure_473(_18,_17,_43,_16,_15,_20,_44,_42,self.__mdim1,_21,_24,self.__msubi,self.__msubj,self.__mval,_9,_7,_14,_45,_11,_38,_37,_36,_34,_41,_39,_40,_32,_31,_33,_13,_5,_3,_4,_26) # src/fusion/ExprMul.monty:729:14-784:15
     _43 = numpy.int32(_43) # postprocess
     _44 = numpy.int32(_44) # postprocess
     _42 = numpy.int32(_42) # postprocess
     _45 = numpy.int32(_45) # postprocess
     if (_45!=_29): # src/fusion/ExprMul.monty:790:18-29
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
     if (_44!=_28): # src/fusion/ExprMul.monty:791:18-32
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
     if (_39[(_31 + _28)]!=_29): # src/fusion/ExprMul.monty:792:18-43
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
     if (not _30): # src/fusion/ExprMul.monty:794:16-26
      _0._popi64_I(_28)
    else:
     _46=0
     _47=(_19 * self.__mdim1)
     _48=0
     _46,_48 = fragments._c_closure_474(_16,_19,_20,_23,self.__mdim1,_24,self.__msubi,_9,_11,_46,_48,_3,_26) # src/fusion/ExprMul.monty:801:12-811:15
     _46 = numpy.int32(_46) # postprocess
     _48 = numpy.int32(_48) # postprocess
     _49=(_47 < (_19 * self.__mdim1))
     if (not (_48 <= 2147483647)): # src/fusion/ExprMul.monty:815:16-40
      raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceeded in multiplication")
     _0._alloc_1expr_IIIZI(2,_47,numpy.int32(_48),_49,_46)
     _50=(_0.shape_base)
     _51=(_0.ptr_base)
     _52=(_0.nidxs_base)
     _53=((_0.sp_base) if (_49 ) else _0._alloci64_I(_47))
     _54=(_0.cof_base)
     _55=(_0.code_base)
     _56=(_0.codeptr_base)
     _57=(_0.cconst_base)
     _58=(_0.i32)
     _59=(_0.i64)
     _60=(_0.f64)
     _58[_50] = _19
     _58[(_50 + 1)] = self.__mdim1
     _61=0
     _62=0
     _63=0
     _58[_51] = 0
     if (_46 > 0): # src/fusion/ExprMul.monty:838:16-30
      _58[_56] = 0
     _61,_63,_62 = fragments._c_closure_475(_18,_17,_61,_16,_15,_19,_20,_23,self.__mdim1,_24,self.__msubi,self.__mval,_14,_63,_11,_57,_55,_56,_54,_62,_60,_58,_59,_46,_52,_51,_53,_5,_3,_4,_26) # src/fusion/ExprMul.monty:840:12-879:15
     _61 = numpy.int32(_61) # postprocess
     _63 = numpy.int32(_63) # postprocess
     _62 = numpy.int32(_62) # postprocess
     if (not _49): # src/fusion/ExprMul.monty:881:16-26
      _0._popi64_I(_47)
    _2._clear_()
   else:
    _64=_2._alloci32_I((_19 + 1))
    _65=(_2.i32)
    fragments._c_closure_476(_19,_65,_64) # src/fusion/ExprMul.monty:890:10-55
    _66=(numpy.int64(_8) * self.__mdim1)
    _67=(_19 * self.__mdim1)
    _68=((_9 * self.__mdim1) + (0 if ((_9==0) ) else (numpy.int32(_66) * 2)))
    _69=False
    _70=2
    if (not (_66 <= 2147483647)): # src/fusion/ExprMul.monty:899:14-38
     raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceeded in multiplication")
    _0._alloc_1expr_IIIZI(_70,_67,numpy.int32(_66),_69,_68)
    _71=(_0.i32)
    _72=(_0.i64)
    _73=(_0.f64)
    _74=(_0.shape_base)
    _75=(_0.ptr_base)
    _76=(_0.nidxs_base)
    _77=(_0.sp_base)
    _78=(_0.cof_base)
    _79=(_0.code_base)
    _80=(_0.codeptr_base)
    _81=(_0.cconst_base)
    _71[_74] = _19
    _71[(_74 + 1)] = self.__mdim1
    _82=0
    _83=0
    _84=0
    _71[_75] = 0
    if (_68 > 0): # src/fusion/ExprMul.monty:923:14-28
     _71[_80] = 0
    if _10: # src/fusion/ExprMul.monty:924:14-19
     _82,_84,_83 = fragments._c_closure_477(_18,_17,_82,_16,_15,_19,_20,_84,self.__mdim1,self.__mval,_9,_7,_14,_83,_11,_81,_79,_80,_78,_73,_71,_72,_76,_75,_13,_5,_3,_4,_65,_64) # src/fusion/ExprMul.monty:925:12-965:13
     _82 = numpy.int32(_82) # postprocess
     _84 = numpy.int32(_84) # postprocess
     _83 = numpy.int32(_83) # postprocess
     if (_83!=_66): # src/fusion/ExprMul.monty:966:16-27
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num nonzeros")
     if (_84!=_67): # src/fusion/ExprMul.monty:967:16-30
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num elements")
     if (_82!=_68): # src/fusion/ExprMul.monty:968:16-35
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num code atoms")
    else:
     _82,_84,_83 = fragments._c_closure_478(_18,_17,_82,_16,_15,_19,_20,_84,self.__mdim1,self.__mval,_9,_14,_83,_11,_81,_79,_80,_78,_73,_71,_72,_76,_75,_5,_3,_4) # src/fusion/ExprMul.monty:970:15-1006:11
     _82 = numpy.int32(_82) # postprocess
     _84 = numpy.int32(_84) # postprocess
     _83 = numpy.int32(_83) # postprocess
    _2._clear_()
  @staticmethod
  def __computeshape_alt_I_3I(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprMulRight.__computeshape_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape_I_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (int((_1).shape[0])==1): # src/fusion/ExprMul.monty:566:12-24
    return (numpy.array([1,_0], dtype=numpy.dtype(numpy.int32)))
   else:
    return (numpy.array([_1[0],_0], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _6=_5._getShape_()
   if (int((_6).shape[0])!=2): # src/fusion/ExprMul.monty:504:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or ((_1 < 0) or ((_7 < 0) or (_8 < 0)))): # src/fusion/ExprMul.monty:511:12-60
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if (_0!=_8): # src/fusion/ExprMul.monty:513:12-26
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:515:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   _10 = fragments._c_closure_479(_10,_0,_1,_9,_2,_3) # src/fusion/ExprMul.monty:522:10-524:63
   if _10: # src/fusion/ExprMul.monty:525:14-17
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _11=False
   _11 = fragments._c_closure_480(_11,_9,_2,_3) # src/fusion/ExprMul.monty:530:10-532:82
   if _11: # src/fusion/ExprMul.monty:533:14-17
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulRight(M,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulRight
mosek_fusion_ExprMulRight=__mk_mosek_fusion_ExprMulRight()
del __mk_mosek_fusion_ExprMulRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulLeft():
 class ExprMulLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulLeft__expr','_ExprMulLeft__mval','_ExprMulLeft__msubj','_ExprMulLeft__msubi','_ExprMulLeft__mdim1','_ExprMulLeft__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulLeft.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulLeft'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulLeft.__new__(ExprMulLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulLeft.__computeshape_II_3I(mdim0,mdim1,expr._getShape_()))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulLeft.__new__(ExprMulLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mval is None or isinstance(mval,numpy.ndarray)
   mosek_fusion_ExprMulLeft._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.codeptr_base)
   _14=(_1.code_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   if (_3!=2): # src/fusion/ExprMul.monty:166:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _19=9999
   _20=9999
   _21=9999
   _22=_16[_8]
   _23=_16[(_8 + 1)]
   _24=int((self.__msubi).shape[0])
   _25=(_24 < (numpy.int64(self.__mdim0) * numpy.int64(self.__mdim1)))
   _26=False
   _27=0
   _28=0
   _29=0
   if _7: # src/fusion/ExprMul.monty:180:12-17
    _19 = _2._alloci32_I(_5)
    _20 = _2._alloci32_I(_5)
    _21 = _2._alloci32_I((_23 + 1))
    _30=(_2.i32)
    fragments._c_closure_481(_23,_19,_21,_5,_10,_17,_30) # src/fusion/ExprMul.monty:188:10-200:11
    _27,_28,_29 = fragments._c_closure_482(_13,_23,_19,_21,self.__mdim0,_25,_24,self.__msubi,self.__msubj,_6,_4,_9,_27,_28,_29,_10,_16,_17,_30) # src/fusion/ExprMul.monty:203:10-238:11
    _27 = numpy.int32(_27) # postprocess
    _28 = numpy.int32(_28) # postprocess
    _29 = numpy.int64(_29) # postprocess
   else:
    _27,_28,_29 = fragments._c_closure_483(_13,_23,self.__mdim0,_25,_24,self.__msubi,self.__msubj,_6,_4,_9,_27,_28,_29,_16) # src/fusion/ExprMul.monty:240:13-269:9
    _27 = numpy.int32(_27) # postprocess
    _28 = numpy.int32(_28) # postprocess
    _29 = numpy.int64(_29) # postprocess
   if (not (_29 <= 2147483647)): # src/fusion/ExprMul.monty:273:12-36
    raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceeded in multiplication")
   _26 = (_28 < (self.__mdim0 * _23))
   _31=2
   _0._alloc_1expr_IIIZI(_31,_28,numpy.int32(_29),_26,_27)
   _32=(_0.ptr_base)
   _33=(_0.nidxs_base)
   _34=((_0.sp_base) if (_26 ) else _0._alloci64_I(_28))
   _35=(_0.cof_base)
   _36=(_0.shape_base)
   _37=(_0.code_base)
   _38=(_0.codeptr_base)
   _39=(_0.cconst_base)
   _40=(_0.i64)
   _41=(_0.f64)
   _42=(_0.i32)
   _43=(_2.i32)
   _42[_36] = self.__mdim0
   _42[(_36 + 1)] = _23
   _42[_32] = 0
   if (_27 > 0): # src/fusion/ExprMul.monty:309:12-26
    _42[_38] = 0
   if _7: # src/fusion/ExprMul.monty:312:12-17
    if _25: # src/fusion/ExprMul.monty:313:14-19
     fragments._c_closure_484(_15,_14,_13,_12,_23,_19,_21,_24,self.__msubi,self.__msubj,self.__mval,_11,_9,_39,_37,_38,_35,_41,_42,_40,_27,_33,_32,_34,_10,_18,_16,_17,_43) # src/fusion/ExprMul.monty:313:21-363:11
    else:
     _44=0
     _45=0
     _46=0
     _44,_45,_46 = fragments._c_closure_485(_15,_14,_44,_13,_12,_23,_45,_19,_21,self.__mdim0,self.__mdim1,self.__mval,_11,_46,_9,_39,_37,_38,_35,_41,_42,_40,_27,_33,_32,_10,_18,_16,_17,_43) # src/fusion/ExprMul.monty:371:12-402:15
     _44 = numpy.int32(_44) # postprocess
     _45 = numpy.int32(_45) # postprocess
     _46 = numpy.int32(_46) # postprocess
     if (_45!=_28): # src/fusion/ExprMul.monty:404:16-30
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of elements")
     if (_46!=_29): # src/fusion/ExprMul.monty:405:16-28
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of non-zeros")
     if (_44!=_27): # src/fusion/ExprMul.monty:406:16-35
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of code atoms")
   else:
    _47=0
    _48=0
    _49=0
    _50=0
    _47,_49,_48,_50 = fragments._c_closure_486(_15,_14,_47,_13,_12,_23,_49,_24,_48,self.__msubi,self.__msubj,self.__mval,_11,_50,_9,_39,_37,_38,_35,_41,_42,_40,_27,_33,_32,_34,_18,_16,_17) # src/fusion/ExprMul.monty:413:10-454:11
    _47 = numpy.int32(_47) # postprocess
    _49 = numpy.int32(_49) # postprocess
    _48 = numpy.int32(_48) # postprocess
    _50 = numpy.int32(_50) # postprocess
    if (_49!=_28): # src/fusion/ExprMul.monty:455:14-28
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of elements")
    if (_50!=_29): # src/fusion/ExprMul.monty:456:14-26
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of non-zeros")
    if (_47!=_27): # src/fusion/ExprMul.monty:457:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of code atoms")
   if (not _26): # src/fusion/ExprMul.monty:460:12-22
    _0._popi64_I(_28)
   _2._clear_()
  @staticmethod
  def __computeshape_alt_II_3I(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprMulLeft.__computeshape_II_3I(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape_II_3I(_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (int((_2).shape[0])!=2): # src/fusion/ExprMul.monty:97:12-24
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   elif (_1!=_2[0]): # src/fusion/ExprMul.monty:99:16-27
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   return (numpy.array([_0,_2[1]], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   if (_5._getND_()!=2): # src/fusion/ExprMul.monty:36:12-29
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _6=_5._getDim_I(0)
   _7=_5._getDim_I(0)
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:42:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if (_1!=_6): # src/fusion/ExprMul.monty:44:12-26
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:46:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _8=int((_2).shape[0])
   _9=False
   _10=False
   _9,_10 = fragments._c_closure_487(_9,_10,_0,_1,_8,_2,_3) # src/fusion/ExprMul.monty:53:8-61:9
   if _9: # src/fusion/ExprMul.monty:62:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _10: # src/fusion/ExprMul.monty:64:12-24
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulLeft(M(")._a_I(self.__mdim0)._a_S(",")._a_I(self.__mdim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulLeft
mosek_fusion_ExprMulLeft=__mk_mosek_fusion_ExprMulLeft()
del __mk_mosek_fusion_ExprMulLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulVar():
 class ExprMulVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulVar__left','_ExprMulVar__x','_ExprMulVar__mcof','_ExprMulVar__msubj','_ExprMulVar__msubi','_ExprMulVar__mdimj','_ExprMulVar__mdimi']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args): # bool,int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):# bool,int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulVar.ctor(bool,int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Variable)')
  def eval_right(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1right_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_right('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval_right(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def eval_left(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1left_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_left('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval_left(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.toString()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprMulVar'
  @staticmethod
  def _ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,mdimi,mdimj,msubi,msubj,mcof,x):
    o = ExprMulVar.__new__(ExprMulVar)
    o._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,mdimi,mdimj,msubi,msubj,mcof,x)
    return o
  @staticmethod
  def __match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 7: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_match_Z__(left) and __arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 7: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_alt_match_Z__(left) and __arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(self,left,mdimi,mdimj,msubi,msubj,mcof,x):
    self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x)
  def _ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(self,left,mdimi,mdimj,msubi,msubj,mcof,x):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   mosek_fusion_ExprMulVar._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,1)
   _0=x._getShape_()
   _1=int((_0).shape[0])
   if (_1!=2): # src/fusion/ExprMulVar.monty:265:12-19
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   elif (left and (_0[0]!=mdimj)): # src/fusion/ExprMulVar.monty:267:16-43
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   elif ((not left) and (_0[1]!=mdimi)): # src/fusion/ExprMulVar.monty:269:16-47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((msubi).shape[0])!=int((msubj).shape[0])) or (int((msubi).shape[0])!=int((mcof).shape[0]))): # src/fusion/ExprMulVar.monty:272:12-63
    raise mosek_fusion_LengthError._ctor_S("Mismatching matrix data lengths")
   self.__validate_II_3I_3I_3D(mdimi,mdimj,msubi,msubj,mcof)
  @staticmethod
  def _ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    o = ExprMulVar.__new__(ExprMulVar)
    o._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_)
    return o
  @staticmethod
  def __match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 8: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_match_Z__(left) and __arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 8: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_alt_match_Z__(left) and __arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x,numpy.int32(unchecked_))
  def _ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulVar.__resshape_II_3IZ(mdimi,mdimj,x._getShape_(),left))
   (self.__left) = left
   (self.__x) = x
   (self.__mdimi) = mdimi
   (self.__mdimj) = mdimj
   (self.__msubi) = mosek.fusion.Utils.Tools._arraycopy__3I(msubi)
   (self.__msubj) = mosek.fusion.Utils.Tools._arraycopy__3I(msubj)
   (self.__mcof) = mosek.fusion.Utils.Tools._arraycopy__3D(mcof)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   if self.__left: # src/fusion/ExprMulVar.monty:741:12-16
    self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
   else:
    self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  @staticmethod
  def _match_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_1right_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=(_1.pi32)
   _4=(_1.pi64)
   _5=self.__x._numInst_()
   _6=_1._alloci64_I(_5)
   _7=_1._alloci64_I(_5)
   _8=_1._alloci32_I(_5)
   _9=_1._alloci32_I(_5)
   _10=self.__x._getShape_()
   _11=int((_10).shape[0])
   _12=(_10[0] * _10[1])
   _13=_10[1]
   _14=_10[0]
   _15=_1._alloci32_I((_14 + 1))
   _16=int(((self.__msubi)).shape[0])
   _17=(self.__msubi)
   _18=(self.__msubj)
   _19=(self.__mcof)
   _20=(self.__mdimi)
   _21=(self.__mdimj)
   _22=((_16 // _20)==_21)
   _23=_1._alloci32_I(_16)
   _24=_1._alloci32_I((self.__mdimj + 1))
   _25=(_1.i32)
   _26=(_1.i64)
   _27=0
   _28=0
   self.__x._inst_I_3JI_3J(_7,_26,_6,_26)
   if _22: # src/fusion/ExprMulVar.monty:497:12-22
    _29=0
    _29 = fragments._c_closure_488(_5,_7,_26,_29,_14,_13) # src/fusion/ExprMulVar.monty:501:10-514:11
    _29 = numpy.int32(_29) # postprocess
    _28 = (_29 * _21)
    _27 = (_5 * _21)
    _30=(_29 < _14)
    _0._alloc_1expr_IIIZ(2,_28,_27,_30)
    _31=(_0.ptr_base)
    _32=(_0.shape_base)
    _33=(_0.nidxs_base)
    _34=((_0.sp_base) if (_30 ) else _0._alloci64_I(_28))
    _35=(_0.cof_base)
    _36=(_0.i32)
    _37=(_0.i64)
    _38=(_0.f64)
    _36[_32] = _14
    _36[(_32 + 1)] = _21
    fragments._c_closure_489(_19,_21,_6,_5,_35,_38,_36,_37,_33,_31,_34,_7,_26,_13) # src/fusion/ExprMulVar.monty:534:10-557:11
    if (not _30): # src/fusion/ExprMulVar.monty:558:14-23
     _0._popi64_I(_28)
   else:
    fragments._c_closure_490(_21,self.__mdimj,_24,_18,_16,_23,_25) # src/fusion/ExprMulVar.monty:563:10-582:11
    if ((_5 // _14)==_13): # src/fusion/ExprMulVar.monty:584:14-33
     _39=0
     _39 = fragments._c_closure_491(_18,_39,_16,_23,_25) # src/fusion/ExprMulVar.monty:587:12-594:13
     _39 = numpy.int32(_39) # postprocess
     _28 = (_39 * _14)
     _27 = (_16 * _14)
     _40=(_39 < _21)
     _0._alloc_1expr_IIIZ(2,_28,_27,_40)
     _41=(_0.ptr_base)
     _42=(_0.shape_base)
     _43=(_0.nidxs_base)
     _44=((_0.sp_base) if (_40 ) else _0._alloci64_I(_28))
     _45=(_0.cof_base)
     (_0.i32)[_42] = _14
     (_0.i32)[(_42 + 1)] = _21
     _46=(_0.i32)
     _47=(_0.i64)
     _48=(_0.f64)
     _46[_41] = 0
     _49=0
     _50=0
     _49,_50 = fragments._c_closure_492(_49,_50,_19,_21,_17,_18,_6,_16,_23,_45,_48,_46,_47,_43,_41,_44,_25,_26,_14,_13) # src/fusion/ExprMulVar.monty:620:12-639:13
     _49 = numpy.int32(_49) # postprocess
     _50 = numpy.int32(_50) # postprocess
     if (not _40): # src/fusion/ExprMulVar.monty:641:16-26
      _0._popi64_I(_28)
    else:
     fragments._c_closure_493(_15,_25,_14) # src/fusion/ExprMulVar.monty:645:14-55
     fragments._c_closure_494(_11,_5,_15,_7,_25,_26,_14,_10,_8,_9) # src/fusion/ExprMulVar.monty:647:12-659:13
     _28,_27 = fragments._c_closure_495(self.__mdimj,_24,_17,_28,_27,_23,_15,_25,_14,_9) # src/fusion/ExprMulVar.monty:663:12-682:15
     _28 = numpy.int32(_28) # postprocess
     _27 = numpy.int32(_27) # postprocess
     _51=(_28 < (_13 * self.__mdimi))
     _0._alloc_1expr_IIIZ(2,_28,_27,_51)
     _52=(_0.ptr_base)
     _53=(_0.shape_base)
     _54=(_0.nidxs_base)
     _55=(_0.sp_base)
     _56=(_0.cof_base)
     (_0.i32)[_53] = _14
     (_0.i32)[(_53 + 1)] = self.__mdimj
     _57=(_0.i32)
     _58=(_0.i64)
     _59=(_0.f64)
     fragments._c_closure_496(_19,self.__mdimj,_24,_17,_6,_23,_15,_56,_59,_57,_58,_54,_52,_55,_25,_26,_14,_9) # src/fusion/ExprMulVar.monty:699:12-729:13
     if (not _51): # src/fusion/ExprMulVar.monty:730:16-26
      _0._popi64_I(_28)
   (_1.pi32) = _3
   (_1.pi64) = _4
  @staticmethod
  def _match_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_1left_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.__x._numInst_()
   _4=self.__x._getShape_()
   _5=int((_4).shape[0])
   _6=_2._alloci64_I(_3)
   _7=_2._alloci64_I(_3)
   _8=_2._alloci32_I(_3)
   _9=_2._alloci32_I(_3)
   _10=_2._alloci32_I(_3)
   _11=_2._alloci32_I((self.__mdimi + 1))
   _12=self.__x._getShape_()
   _13=int((_12).shape[0])
   _14=(1 if ((_13==1) ) else _12[1])
   _15=_12[0]
   _16=_2._alloci32_I((_14 + 1))
   _17=(self.__msubi)
   _18=(self.__msubj)
   _19=(self.__mcof)
   _20=(self.__mdimi)
   _21=(self.__mdimj)
   _22=0
   _23=0
   _24=(_2.i32)
   _25=(_2.i64)
   _26=int((_19).shape[0])
   self.__x._inst_I_3JI_3J(_7,_25,_6,_25)
   if (self.__x._numInst_() < self.__x._getSize_()): # src/fusion/ExprMulVar.monty:312:12-37
    _23,_22 = fragments._c_closure_497(_20,_11,_17,_18,_13,_3,_10,_16,_23,_22,_7,_14,_24,_25,_8,_9) # src/fusion/ExprMulVar.monty:312:39-368:9
    _23 = numpy.int32(_23) # postprocess
    _22 = numpy.int32(_22) # postprocess
   else:
    _23,_22 = fragments._c_closure_498(_26,_17,_23,_22,_14) # src/fusion/ExprMulVar.monty:368:15-378:9
    _23 = numpy.int32(_23) # postprocess
    _22 = numpy.int32(_22) # postprocess
   _27=(True if ((_23 < (_14 * _20)) ) else False)
   _28=_13
   _0._alloc_1expr_IIIZ(_28,_23,_22,_27)
   _29=(_0.ptr_base)
   _30=(_0.shape_base)
   _31=(_0.nidxs_base)
   _32=((_0.sp_base) if (_27 ) else _0._alloci64_I(_23))
   _33=(_0.cof_base)
   _34=(_0.i32)
   _35=(_0.i64)
   _36=(_0.f64)
   _34[_30] = _20
   if (_13 > 1): # src/fusion/ExprMulVar.monty:396:12-18
    _34[(_30 + 1)] = _14
   if (self.__x._numInst_() < self.__x._getSize_()): # src/fusion/ExprMulVar.monty:400:12-37
    fragments._c_closure_499(_19,_20,_11,_18,_6,_10,_16,_33,_36,_34,_35,_31,_29,_32,_14,_24,_25,_8) # src/fusion/ExprMulVar.monty:400:39-432:9
   else:
    fragments._c_closure_500(_19,_26,_17,_18,_6,_33,_36,_34,_35,_31,_29,_32,_14,_25) # src/fusion/ExprMulVar.monty:432:15-452:8
   if (not _27): # src/fusion/ExprMulVar.monty:454:12-22
    _0._popi64_I(_23)
   _2._clear_()
  def __validate_alt_II_3I_3I_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__validate_II_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __validate_II_3I_3I_3D(self,_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=True
   _5 = fragments._c_closure_501(_0,_1,_2,_3,_5) # src/fusion/ExprMulVar.monty:231:8-240:9
   if (not _5): # src/fusion/ExprMulVar.monty:242:12-18
    raise mosek_fusion_IndexError._ctor_S("Invalid matrix data")
  @staticmethod
  def __resshape_alt_II_3IZ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=_t__3
   _1 = mosek_fusion_ExprMulVar.__resshape_II_3IZ(_0,_1,_2,_3)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __resshape_II_3IZ(_0,_1,_2,_3):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if _3: # src/fusion/ExprMulVar.monty:190:12-16
    return (numpy.array([_0,_2[1]], dtype=numpy.dtype(numpy.int32)))
   else:
    return (numpy.array([_2[0],_1], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   if self.__left: # src/fusion/ExprMulVar.monty:183:12-16
    return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulVar(M,")._a_S(self.__x._toString_())._a_S(")")._toString_())
   else:
    return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulVar(")._a_S(self.__x._toString_())._a_S(",M)")._toString_())
 return ExprMulVar
mosek_fusion_ExprMulVar=__mk_mosek_fusion_ExprMulVar()
del __mk_mosek_fusion_ExprMulVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulScalarVar():
 class ExprMulScalarVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulScalarVar__x','_ExprMulScalarVar__mcof','_ExprMulScalarVar__msubj','_ExprMulScalarVar__msubi','_ExprMulScalarVar__mdimj','_ExprMulScalarVar__mdimi']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulScalarVar.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Variable)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarVar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulScalarVar'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(mdimi,mdimj,msubi,msubj,mcof,x):
    o = ExprMulScalarVar.__new__(ExprMulScalarVar)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(mdimi,mdimj,msubi,msubj,mcof,x)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 6: return False
    mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 6: return False
    mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(self,mdimi,mdimj,msubi,msubj,mcof,x):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(self,mdimi,mdimj,msubi,msubj,mcof,x):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   mosek_fusion_ExprMulScalarVar._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,mosek.fusion.Utils.Tools._arraycopy__3I(msubi),mosek.fusion.Utils.Tools._arraycopy__3I(msubj),mosek.fusion.Utils.Tools._arraycopy__3D(mcof),x,1)
   if (x._getND_()!=0): # src/fusion/ExprMulVar.monty:105:12-26
    raise mosek_fusion_DimensionError._ctor_S("Invalid Variable size")
   if ((mdimi < 0) or ((mdimj < 0) or ((int((msubi).shape[0])!=int((msubj).shape[0])) or (int((msubi).shape[0])!=int((mcof).shape[0]))))): # src/fusion/ExprMulVar.monty:108:12-89
    raise mosek_fusion_LengthError._ctor_S("Invalid Matrix data")
   _0=False
   _0 = fragments._c_closure_502(_0,mdimi,mdimj,msubi,msubj) # src/fusion/ExprMulVar.monty:112:8-115:28
   if _0: # src/fusion/ExprMulVar.monty:116:12-20
    raise mosek_fusion_IndexError._ctor_S("Invalid Matrix data")
   _1=False
   _1 = fragments._c_closure_503(_1,msubi,msubj) # src/fusion/ExprMulVar.monty:120:8-123:30
   if _1: # src/fusion/ExprMulVar.monty:124:12-22
    raise mosek_fusion_IndexError._ctor_S("Matrix data not correctly sorted")
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    o = ExprMulScalarVar.__new__(ExprMulScalarVar)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(mdimi,mdimj,msubi,msubj,mcof,x,unchecked_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 7: return False
    mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 7: return False
    mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x,numpy.int32(unchecked_))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
   assert msubi is None or isinstance(msubi,numpy.ndarray)
   assert msubj is None or isinstance(msubj,numpy.ndarray)
   assert mcof is None or isinstance(mcof,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdimi,mdimj], dtype=numpy.dtype(numpy.int32)))
   (self.__mdimi) = mdimi
   (self.__mdimj) = mdimj
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mcof) = mcof
   (self.__x) = x
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   if (self.__x._numInst_()==0): # src/fusion/ExprMulVar.monty:129:12-28
    _0._alloc_1expr_IIIZ(2,0,0,False)
    (_0.i32)[(_0.shape_base)] = self.__mdimi
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdimj
   else:
    _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
    self.__x._inst_I_3J(0,_3)
    _4=_3[0]
    _5=int((self.__msubi).shape[0])
    _6=_5
    _7=(_5 < (self.__mdimi * self.__mdimj))
    _0._alloc_1expr_IIIZ(2,_5,_6,_7)
    _8=(_0.ptr_base)
    (_0.i32)[(_0.shape_base)] = self.__mdimi
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdimj
    _9=(_0.nidxs_base)
    _10=(_0.sp_base)
    _11=(_0.cof_base)
    _12=(_0.i32)
    _13=(_0.i64)
    _14=(_0.f64)
    fragments._c_closure_504(_11,_14,_7,_12,_13,self.__mcof,self.__mdimj,self.__msubi,self.__msubj,_5,_9,_6,_8,_10,_4) # src/fusion/ExprMulVar.monty:157:10-164:11
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulScalarVar(M(")._a_I(self.__mdimi)._a_S(",")._a_I(self.__mdimj)._a_S("), ")._a_S(self.__x._toString_())._a_S(")")._toString_())
 return ExprMulScalarVar
mosek_fusion_ExprMulScalarVar=__mk_mosek_fusion_ExprMulScalarVar()
del __mk_mosek_fusion_ExprMulScalarVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulVarScalarConst():
 class ExprMulVarScalarConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulVarScalarConst__c','_ExprMulVarScalarConst__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      self._ctor_init_Lmosek_4fusion_4Variable_2D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2D(*args):# mosek.fusion.Variable,double
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulVarScalarConst.ctor(mosek.fusion.Variable,double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVarScalarConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVarScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVarScalarConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVarScalarConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulVarScalarConst'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2D(x,c):
    o = ExprMulVarScalarConst.__new__(ExprMulVarScalarConst)
    o._ctor_init_Lmosek_4fusion_4Variable_2D(x,c)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    x,c, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_D__(c))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    x,c, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_D__(c))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2D(self,x,c):
    self._ctor_init_Lmosek_4fusion_4Variable_2D(x,numpy.float64(c))
  def _ctor_init_Lmosek_4fusion_4Variable_2D(self,x,c):
   mosek_fusion_BaseExpression._ctor_init__3I(self,x._getShape_())
   (self.__x) = x
   (self.__c) = c
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.__x._numInst_()
   _4=_3
   _5=self.__x._getShape_()
   _6=int((_5).shape[0])
   _7=(mosek.fusion.Set._size__3I(_5) > _4)
   _0._alloc_1expr_IIIZ(_6,_4,_3,_7)
   _8=(_0.ptr_base)
   _9=(_0.nidxs_base)
   _10=(_0.sp_base)
   _11=(_0.cof_base)
   _12=(_0.shape_base)
   if _7: # src/fusion/ExprMulVar.monty:31:12-17
    self.__x._inst_I_3JI_3J(_10,(_0.i64),_9,(_0.i64))
   else:
    self.__x._inst_I_3J(_9,(_0.i64))
   _13=(_0.i32)
   _14=(_0.i64)
   _15=(_0.f64)
   fragments._c_closure_505(_11,_15,_13,_6,_4,_3,_8,_12,_5) # src/fusion/ExprMulVar.monty:42:8-46:9
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulVarScalarConst()")
 return ExprMulVarScalarConst
mosek_fusion_ExprMulVarScalarConst=__mk_mosek_fusion_ExprMulVarScalarConst()
del __mk_mosek_fusion_ExprMulVarScalarConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprAdd():
 class ExprAdd(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprAdd__m2','_ExprAdd__m1','_ExprAdd__e2','_ExprAdd__e1']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double,double
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):# mosek.fusion.Expression,mosek.fusion.Expression,double,double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprAdd.ctor(mosek.fusion.Expression,mosek.fusion.Expression,double,double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprAdd._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprAdd._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprAdd.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprAdd._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprAdd._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprAdd.toString()')
  def __repr__(self): return 'mosek.fusion.ExprAdd'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,m1,m2):
    o = ExprAdd.__new__(ExprAdd)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,m1,m2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    e1,e2,m1,m2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e1) and __arg_match_Lmosek_4fusion_4Expression_2__(e2) and __arg_match_D__(m1) and __arg_match_D__(m2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    e1,e2,m1,m2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e2) and __arg_alt_match_D__(m1) and __arg_alt_match_D__(m2))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(self,e1,e2,m1,m2):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,numpy.float64(m1),numpy.float64(m2))
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(self,e1,e2,m1,m2):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e1._getShape_())
   (self.__e1) = e1
   (self.__e2) = e2
   (self.__m1) = m1
   (self.__m2) = m2
   if (e1._getND_()!=e2._getND_()): # src/fusion/ExprAdd.monty:615:12-36
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   for _0 in range(0,e1._getND_()):
    if (e1._getDim_I(_0)!=e2._getDim_I(_0)): # src/fusion/ExprAdd.monty:618:14-42
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e1._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   self.__e2._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _1._pop_1expr_()
   _16=(_1.nd)
   _17=(_1.shape_base)
   _18=(_1.nelem)
   _19=(_1.nnz)
   _20=(_1.ncodeatom)
   _21=(_1.hassp)
   _22=(_1.ptr_base)
   _23=(_1.sp_base)
   _24=(_1.nidxs_base)
   _25=(_1.cof_base)
   _26=(_1.code_base)
   _27=(_1.codeptr_base)
   _28=(_1.cconst_base)
   _29=(_1.i32)
   _30=(_1.i64)
   _31=(_1.f64)
   _32=((_20 > 0) or (_7 > 0))
   if (_16!=_3): # src/fusion/ExprAdd.monty:681:12-22
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   for _33 in range(0,_16):
    if (_29[(_17 + _33)]!=_29[(_4 + _33)]): # src/fusion/ExprAdd.monty:684:14-46
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   if ((not _21) and (not _8)): # src/fusion/ExprAdd.monty:687:12-37
    _34=_18
    _35=(_19 + _6)
    _36=0
    if _32: # src/fusion/ExprAdd.monty:691:14-27
     _36 += ((_20 + (_19 * 2)) if ((_20 > 0) ) else _19)
     _36 += ((_7 + (_6 * 2)) if ((_7 > 0) ) else _6)
    _37=_16
    _0._alloc_1expr_IIIZI(_37,_34,_35,False,_36)
    _38=(_0.shape_base)
    _39=(_0.ptr_base)
    _40=(_0.sp_base)
    _41=(_0.nidxs_base)
    _42=(_0.cof_base)
    _43=(_0.code_base)
    _44=(_0.codeptr_base)
    _45=(_0.cconst_base)
    _46=(_0.i32)
    _47=(_0.i64)
    _48=(_0.f64)
    fragments._c_closure_506(_46,_37,_38,_17,_29) # src/fusion/ExprAdd.monty:712:10-713:44
    _49=0
    _50=0
    if (_36 > 0): # src/fusion/ExprAdd.monty:716:14-28
     _46[_44] = 0
    _46[_39] = 0
    _49,_50 = fragments._c_closure_507(_28,_15,_26,_13,_49,_27,_14,_25,_12,_50,self.__m1,self.__m2,_20,_7,_24,_11,_22,_9,_45,_43,_44,_42,_48,_46,_47,_36,_34,_41,_39,_31,_29,_30) # src/fusion/ExprAdd.monty:721:10-788:11
    _49 = numpy.int32(_49) # postprocess
    _50 = numpy.int32(_50) # postprocess
   elif ((not _21) or (not _8)): # src/fusion/ExprAdd.monty:793:16-794:26
    if (not _8): # src/fusion/ExprAdd.monty:795:14-24
     _51=_5
     _52=_6
     _53=_9
     _54=_10
     _55=_11
     _56=_7
     _57=_14
     _58=_13
     _59=_15
     _60=_12
     _5 = _18
     _6 = _19
     _9 = _22
     _10 = _23
     _11 = _24
     _7 = _20
     _14 = _27
     _13 = _26
     _15 = _28
     _12 = _25
     _18 = _51
     _19 = _52
     _22 = _53
     _23 = _54
     _24 = _55
     _20 = _56
     _27 = _57
     _26 = _58
     _28 = _59
     _25 = _60
    _61=((self.__m1) if ((not _21) ) else (self.__m2))
    _62=((self.__m2) if ((not _21) ) else (self.__m1))
    _63=_18
    _64=(_19 + _6)
    _65=_16
    _66=(_20 + _7)
    if _32: # src/fusion/ExprAdd.monty:839:14-27
     _66 += ((2 * _19) if ((_20 > 0) ) else _19)
     _66 += ((2 * _6) if ((_7 > 0) ) else _6)
    _0._alloc_1expr_IIIZI(_65,_63,_64,False,_66)
    _67=(_0.shape_base)
    _68=(_0.ptr_base)
    _69=(_0.sp_base)
    _70=(_0.nidxs_base)
    _71=(_0.cof_base)
    _72=(_0.code_base)
    _73=(_0.codeptr_base)
    _74=(_0.cconst_base)
    _75=(_0.i32)
    _76=(_0.i64)
    _77=(_0.f64)
    _78=0
    _79=0
    _80=0
    fragments._c_closure_508(_75,_65,_67,_17,_29) # src/fusion/ExprAdd.monty:868:12-65
    _75[_68] = 0
    if (_66 > 0): # src/fusion/ExprAdd.monty:871:16-30
     _75[_73] = 0
    _81=0
    _82=0
    _78,_79,_82,_81,_80 = fragments._c_closure_509(_28,_15,_26,_13,_78,_27,_14,_25,_12,_79,_82,_81,_61,_62,_20,_7,_18,_5,_24,_11,_80,_22,_9,_74,_72,_73,_71,_77,_75,_76,_66,_70,_68,_10,_31,_29,_30) # src/fusion/ExprAdd.monty:873:12-1005:13
    _78 = numpy.int32(_78) # postprocess
    _79 = numpy.int32(_79) # postprocess
    _82 = numpy.int32(_82) # postprocess
    _81 = numpy.int32(_81) # postprocess
    _80 = numpy.int32(_80) # postprocess
    if (_80!=_64): # src/fusion/ExprAdd.monty:1008:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
    if (_78!=_66): # src/fusion/ExprAdd.monty:1009:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid codei")
   else:
    _83=(_19 + _6)
    _84=0
    _85=_16
    _86=(_20 + _7)
    if _32: # src/fusion/ExprAdd.monty:1017:14-27
     _86 += ((2 * _19) if ((_20 > 0) ) else _19)
     _86 += ((2 * _6) if ((_7 > 0) ) else _6)
    _87=1
    _87 = fragments._c_closure_510(_85,_17,_87,_29) # src/fusion/ExprAdd.monty:1021:25-69
    _87 = numpy.int64(_87) # postprocess
    _84 = fragments._c_closure_511(_18,_5,_84,_23,_10,_30) # src/fusion/ExprAdd.monty:1023:10-1031:11
    _84 = numpy.int32(_84) # postprocess
    _88=(_84 < _87)
    _0._alloc_1expr_IIIZI(_85,_84,_83,_88,_86)
    _89=(_0.shape_base)
    _90=(_0.ptr_base)
    _91=((_0.sp_base) if (_88 ) else _0._alloci64_I(_84))
    _92=(_0.nidxs_base)
    _93=(_0.cof_base)
    _94=(_0.code_base)
    _95=(_0.codeptr_base)
    _96=(_0.cconst_base)
    _97=(_0.i32)
    _98=(_0.i64)
    _99=(_0.f64)
    fragments._c_closure_512(_97,_85,_89,_17,_29) # src/fusion/ExprAdd.monty:1049:10-1050:44
    fragments._c_closure_513(_28,_15,_26,_13,_27,_14,_25,_12,self.__m1,self.__m2,_20,_7,_18,_5,_24,_11,_22,_9,_96,_94,_95,_93,_99,_97,_98,_86,_92,_90,_91,_23,_10,_31,_29,_30) # src/fusion/ExprAdd.monty:1053:10-1258:11
    if (not _88): # src/fusion/ExprAdd.monty:1260:14-24
     _0._popi64_I(_84)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprAdd(")._a_S(self.__e1._toString_())._a_S(",")._a_S(self.__e2._toString_())._a_S("; ")._a_D(self.__m1)._a_S(",")._a_D(self.__m2)._a_S(")")._toString_())
 return ExprAdd
mosek_fusion_ExprAdd=__mk_mosek_fusion_ExprAdd()
del __mk_mosek_fusion_ExprAdd
#BEFORE CLASS
def __mk_mosek_fusion_ExprWSum():
 class ExprWSum(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprWSum__w','_ExprWSum__es']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Expression_2_3D(*args): # []mosek.fusion.Expression,[]double
      self._ctor_init__3Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):# []mosek.fusion.Expression,[]double
      self._ctor_alt_init__3Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprWSum.ctor(array(mosek.fusion.Expression,ndim=1),array(double,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprWSum._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprWSum._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprWSum.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprWSum._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprWSum._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprWSum.toString()')
  def __repr__(self): return 'mosek.fusion.ExprWSum'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2_3D(es,w):
    o = ExprWSum.__new__(ExprWSum)
    o._ctor_init__3Lmosek_4fusion_4Expression_2_3D(es,w)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    es,w, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(es) and __arg_match__3D__(w))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    es,w, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(es) and __arg_alt_match__3D__(w))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2_3D(self,es,w):
    self._ctor_init__3Lmosek_4fusion_4Expression_2_3D(numpy.array(es,dtype=numpy.dtype(object)),numpy.array(w,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3Lmosek_4fusion_4Expression_2_3D(self,es,w):
   assert es is None or isinstance(es,numpy.ndarray)
   assert w is None or isinstance(w,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,es[0]._getShape_())
   if (int((w).shape[0])!=int((es).shape[0])): # src/fusion/ExprAdd.monty:257:12-29
    raise mosek_fusion_LengthError._ctor_S("Mismatching weights and expressions array lengths")
   (self.__w) = mosek.fusion.Utils.Tools._arraycopy__3D(w)
   _0=es[0]._getShape_()
   _1=int((_0).shape[0])
   for _2 in range(1,int((es).shape[0])):
    _3=es[_2]._getShape_()
    if (_1!=int((_3).shape[0])): # src/fusion/ExprAdd.monty:266:14-31
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression shapes")
    else:
     for _4 in range(0,_1):
      if (_0[_4]!=_3[_4]): # src/fusion/ExprAdd.monty:270:18-39
       raise mosek_fusion_DimensionError._ctor_S("Mismatching expression shapes")
   (self.__es) = numpy.array([es[_5] for _5 in range(0,int((es).shape[0]))], dtype=numpy.dtype(object))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__es).shape[0])
   for _4 in range(0,_3):
    self.__es[_4]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _14=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _17=numpy.zeros((_3,), dtype=numpy.dtype(numpy.bool))
   for _18 in range(0,_3):
    _1._pop_1expr_()
    _5[((_3 - 1) - _18)] = (_1.nd)
    _6[((_3 - 1) - _18)] = (_1.nelem)
    _7[((_3 - 1) - _18)] = (_1.nnz)
    _8[((_3 - 1) - _18)] = (_1.ncodeatom)
    _9[((_3 - 1) - _18)] = (_1.ptr_base)
    _11[((_3 - 1) - _18)] = (_1.sp_base)
    _10[((_3 - 1) - _18)] = (_1.nidxs_base)
    _12[((_3 - 1) - _18)] = (_1.cof_base)
    _13[((_3 - 1) - _18)] = (_1.shape_base)
    _14[((_3 - 1) - _18)] = (_1.code_base)
    _15[((_3 - 1) - _18)] = (_1.codeptr_base)
    _16[((_3 - 1) - _18)] = (_1.cconst_base)
    _17[((_3 - 1) - _18)] = (_1.hassp)
   _19=(_1.i32)
   _20=(_1.i64)
   _21=(_1.f64)
   _22=True
   _22 = fragments._c_closure_514(_3,_5,_22,_13,_19) # src/fusion/ExprAdd.monty:326:10-330:11
   if (not _22): # src/fusion/ExprAdd.monty:331:14-20
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   _23=numpy.array([_19[(_13[0] + _24)] for _24 in range(0,_5[0])], dtype=numpy.dtype(numpy.int32))
   _25=False
   for _26 in range(0,_3):
    if (not _17[_26]): # src/fusion/ExprAdd.monty:337:53-65
     _25 = True
   _27=False
   _27 = fragments._c_closure_515(_27,_3,_8) # src/fusion/ExprAdd.monty:338:33-93
   _28=0
   _29=0
   _30=0
   if _25: # src/fusion/ExprAdd.monty:342:12-20
    _29 = numpy.int32(mosek.fusion.Set._size__3I(_23))
    _28,_30 = fragments._c_closure_516(_27,_3,_8,_7,_28,_30) # src/fusion/ExprAdd.monty:344:10-348:11
    _28 = numpy.int32(_28) # postprocess
    _30 = numpy.int32(_30) # postprocess
   else:
    _28,_29,_30 = fragments._c_closure_517(_27,_3,_8,_6,_7,_28,_29,_30,_11,_20) # src/fusion/ExprAdd.monty:350:13-373:9
    _28 = numpy.int32(_28) # postprocess
    _29 = numpy.int32(_29) # postprocess
    _30 = numpy.int32(_30) # postprocess
   _0._alloc_1expr_IIIZI(_5[0],_29,_30,(not _25),_28)
   _31=(_0.ptr_base)
   _32=(_0.nidxs_base)
   _33=(_0.sp_base)
   _34=(_0.shape_base)
   _35=(_0.cof_base)
   _36=(_0.code_base)
   _37=(_0.codeptr_base)
   _38=(_0.cconst_base)
   _39=(_0.i32)
   _40=(_0.i64)
   _41=(_0.f64)
   fragments._c_closure_518(_5,_39,_34,_13,_19) # src/fusion/ExprAdd.monty:394:8-70
   if (_28 > 0): # src/fusion/ExprAdd.monty:396:12-26
    _39[_37] = 0
   fragments._c_closure_519(_39,_29,_31) # src/fusion/ExprAdd.monty:398:8-399:32
   if _25: # src/fusion/ExprAdd.monty:402:12-20
    _42=(- 9999)
    if (_28 > 0): # src/fusion/ExprAdd.monty:404:14-28
     _42 = _2._alloci32_I((_29 + 1))
    _43=(_2.i32)
    fragments._c_closure_520(_28,_29,_42,_43) # src/fusion/ExprAdd.monty:407:10-408:59
    for _44 in range(0,_3):
     if _17[_44]: # src/fusion/ExprAdd.monty:411:16-24
      fragments._c_closure_521(_27,_15,_44,_8,_6,_9,_39,_31,_11,_19,_20,_42,_43) # src/fusion/ExprAdd.monty:411:26-420:13
     else:
      fragments._c_closure_522(_27,_15,_44,_8,_6,_9,_39,_31,_19,_42,_43) # src/fusion/ExprAdd.monty:421:17-430:13
    fragments._c_closure_523(_39,_29,_31) # src/fusion/ExprAdd.monty:433:10-434:53
    fragments._c_closure_524(_28,_29,_42,_43) # src/fusion/ExprAdd.monty:435:10-440:11
    for _45 in range(0,_3):
     if _17[_45]: # src/fusion/ExprAdd.monty:443:16-24
      fragments._c_closure_525(_27,_16,_14,_15,_12,_45,_8,_6,_10,_9,_38,_36,_37,_35,_41,_39,_40,_32,_31,_11,self.__w,_21,_19,_20,_42,_43) # src/fusion/ExprAdd.monty:443:26-483:13
     else:
      fragments._c_closure_526(_27,_16,_14,_15,_12,_45,_8,_6,_10,_9,_38,_36,_37,_35,_41,_39,_40,_32,_31,self.__w,_21,_19,_20,_42,_43) # src/fusion/ExprAdd.monty:484:17-524:13
    fragments._c_closure_527(_39,_29,_31) # src/fusion/ExprAdd.monty:527:10-528:66
    _39[_31] = 0
   else:
    fragments._c_closure_528(_27,_16,_14,_15,_12,_3,_8,_6,_10,_9,_38,_36,_37,_35,_41,_39,_40,_32,_31,_33,_11,self.__w,_21,_19,_20) # src/fusion/ExprAdd.monty:531:13-580:9
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprWSum([")
   _0._a_S(self.__es[0]._toString_())
   for _1 in range(1,int((self.__es).shape[0])):
    _0._a_S(",")._a_S(self.__es[_1]._toString_())
   _0._a_S("])")
   return (_0._toString_())
 return ExprWSum
mosek_fusion_ExprWSum=__mk_mosek_fusion_ExprWSum()
del __mk_mosek_fusion_ExprWSum
#BEFORE CLASS
def __mk_mosek_fusion_ExprSumReduce():
 class ExprSumReduce(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSumReduce__dim','_ExprSumReduce__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ILmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression
      self._ctor_init_ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):# int32,mosek.fusion.Expression
      self._ctor_alt_init_ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSumReduce.ctor(int32,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSumReduce._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduce.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprSumReduce._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduce.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSumReduce'
  @staticmethod
  def _ctor_ILmosek_4fusion_4Expression_2(dim,expr):
    o = ExprSumReduce.__new__(ExprSumReduce)
    o._ctor_init_ILmosek_4fusion_4Expression_2(dim,expr)
    return o
  @staticmethod
  def __match_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    dim,expr, = args
    return (__arg_match_I__(dim) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    dim,expr, = args
    return (__arg_alt_match_I__(dim) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_ILmosek_4fusion_4Expression_2(self,dim,expr):
    self._ctor_init_ILmosek_4fusion_4Expression_2(numpy.int32(dim),expr)
  def _ctor_init_ILmosek_4fusion_4Expression_2(self,dim,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprSumReduce.__computeShape_I_3I(dim,expr._getShape_()))
   (self.__expr) = expr
   (self.__dim) = dim
   _0=expr._getShape_()
   if (int((_0).shape[0]) <= dim): # src/fusion/ExprAdd.monty:23:12-29
    raise mosek_fusion_DimensionError._ctor_S("Invalid summing dimension")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=99999
   _20=99999
   _21=99999
   if _8: # src/fusion/ExprAdd.monty:53:12-17
    _22=0
    _22 = fragments._c_closure_529(_22,_3,_4,_16) # src/fusion/ExprAdd.monty:55:10-91
    _22 = numpy.int32(_22) # postprocess
    _19 = _2._alloci32_I((_22 + 1))
    _20 = _2._alloci32_I(_5)
    _21 = _2._alloci32_I(_5)
   _23=(_2.i32)
   if _8: # src/fusion/ExprAdd.monty:64:12-17
    _24=_20
    _25=_21
    fragments._c_closure_530(_24,_5,_23) # src/fusion/ExprAdd.monty:69:10-53
    _24,_25 = fragments._c_closure_531(_24,self.__dim,_3,_5,_19,_4,_10,_25,_16,_17,_23) # src/fusion/ExprAdd.monty:70:10-90:11
    _24 = numpy.int32(_24) # postprocess
    _25 = numpy.int32(_25) # postprocess
    _26=1
    _26 = fragments._c_closure_532(_26,self.__dim,_4,_16) # src/fusion/ExprAdd.monty:92:22-68
    _26 = numpy.int32(_26) # postprocess
    _27=_16[(_4 + self.__dim)]
    _28=1
    _28 = fragments._c_closure_533(_28,self.__dim,_3,_4,_16) # src/fusion/ExprAdd.monty:94:22-71
    _28 = numpy.int32(_28) # postprocess
    _29=(_28 * _27)
    _30=_28
    _31=1
    _32=0
    _33=(- 1)
    _34=(- 1)
    _34,_33,_32 = fragments._c_closure_534(_24,_26,_28,_5,_34,_33,_32,_29,_10,_17,_23) # src/fusion/ExprAdd.monty:99:10-107:11
    _34 = numpy.int64(_34) # postprocess
    _33 = numpy.int64(_33) # postprocess
    _32 = numpy.int32(_32) # postprocess
    _35=(_3 - 1)
    _36=(_32 < (_26 * _28))
    _37=_6
    _38=_7
    _0._alloc_1expr_IIIZI(_35,_32,_37,_36,_38)
    _39=(_0.ptr_base)
    _40=(_0.nidxs_base)
    _41=((_0.sp_base) if (_36 ) else _0._alloci64_I(_32))
    _42=(_0.cof_base)
    _43=(_0.shape_base)
    _44=(_0.code_base)
    _45=(_0.codeptr_base)
    _46=(_0.cconst_base)
    _47=(_0.i32)
    _48=(_0.i64)
    _49=(_0.f64)
    fragments._c_closure_535(self.__dim,_47,_43,_4,_16) # src/fusion/ExprAdd.monty:130:10-72
    fragments._c_closure_536(self.__dim,_3,_47,_43,_4,_16) # src/fusion/ExprAdd.monty:131:10-77
    _47[_39] = 0
    if (_38 > 0): # src/fusion/ExprAdd.monty:133:14-28
     _47[_45] = 0
    _50=0
    _51=0
    _52=0
    _53=0
    _50,_53,_51,_52 = fragments._c_closure_537(_15,_13,_50,_14,_12,_24,_26,_28,_53,_51,_52,_5,_11,_9,_46,_44,_45,_42,_49,_47,_48,_38,_40,_39,_41,_29,_10,_18,_16,_17,_23) # src/fusion/ExprAdd.monty:137:22-168:11
    _50 = numpy.int32(_50) # postprocess
    _53 = numpy.int32(_53) # postprocess
    _51 = numpy.int32(_51) # postprocess
    _52 = numpy.int32(_52) # postprocess
    if (not _36): # src/fusion/ExprAdd.monty:170:14-24
     _0._popi64_I(_32)
   else:
    _54=1
    _54 = fragments._c_closure_538(_54,self.__dim,_4,_16) # src/fusion/ExprAdd.monty:175:22-68
    _54 = numpy.int32(_54) # postprocess
    _55=_16[(_4 + self.__dim)]
    _56=1
    _56 = fragments._c_closure_539(_56,self.__dim,_3,_4,_16) # src/fusion/ExprAdd.monty:177:22-71
    _56 = numpy.int32(_56) # postprocess
    _57=(_56 * _55)
    _58=_56
    _59=1
    _60=(_54 * _56)
    _61=_6
    _62=_7
    _0._alloc_1expr_IIIZI((_3 - 1),_60,_61,False,_62)
    _63=(_0.ptr_base)
    _64=(_0.nidxs_base)
    _65=(_0.cof_base)
    _66=(_0.shape_base)
    _67=(_0.code_base)
    _68=(_0.codeptr_base)
    _69=(_0.cconst_base)
    _70=(_0.i32)
    _71=(_0.i64)
    _72=(_0.f64)
    fragments._c_closure_540(self.__dim,_70,_66,_4,_16) # src/fusion/ExprAdd.monty:196:10-67
    fragments._c_closure_541(self.__dim,_3,_70,_66,_4,_16) # src/fusion/ExprAdd.monty:197:10-72
    _73=0
    _74=0
    _70[_63] = 0
    if (_62 > 0): # src/fusion/ExprAdd.monty:201:14-28
     _70[_68] = 0
    _75=0
    _75,_73,_74 = fragments._c_closure_542(_15,_13,_75,_14,_12,_54,_55,_56,_73,_74,_11,_9,_69,_67,_68,_65,_72,_70,_71,_62,_64,_63,_57,_58,_18,_16,_17) # src/fusion/ExprAdd.monty:204:10-227:13
    _75 = numpy.int32(_75) # postprocess
    _73 = numpy.int32(_73) # postprocess
    _74 = numpy.int32(_74) # postprocess
   _2._clear_()
  @staticmethod
  def __computeShape_alt_I_3I(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprSumReduce.__computeShape_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeShape_I_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=numpy.zeros(((int((_1).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_543(_0,_2,_1) # src/fusion/ExprAdd.monty:12:8-45
   fragments._c_closure_544(_0,_2,_1) # src/fusion/ExprAdd.monty:13:8-58
   return (_2)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprSumReduce(")._a_I(self.__dim)._a_S(",")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprSumReduce
mosek_fusion_ExprSumReduce=__mk_mosek_fusion_ExprSumReduce()
del __mk_mosek_fusion_ExprSumReduce
#BEFORE CLASS
def __mk_mosek_fusion_ExprDenseTril():
 class ExprDenseTril(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDenseTril__dim1','_ExprDenseTril__dim0','_ExprDenseTril__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args): # int32,int32,mosek.fusion.Expression
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):# int32,int32,mosek.fusion.Expression
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2I(*args): # int32,int32,mosek.fusion.Expression,int32
      self._ctor_init_IILmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):# int32,int32,mosek.fusion.Expression,int32
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDenseTril.ctor(int32,int32,mosek.fusion.Expression)\n\tmosek.fusion.ExprDenseTril.ctor(int32,int32,mosek.fusion.Expression,int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprDenseTril._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDenseTril._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDenseTril.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprDenseTril._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprDenseTril._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDenseTril.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDenseTril'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_):
    o = ExprDenseTril.__new__(ExprDenseTril)
    o._ctor_init_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
    self._ctor_init_IILmosek_4fusion_4Expression_2I(numpy.int32(dim0),numpy.int32(dim1),expr,numpy.int32(unchecked_))
  def _ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
   (self.__dim0) = dim0
   (self.__dim1) = dim1
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr):
    o = ExprDenseTril.__new__(ExprDenseTril)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_match_I__(dim0_) and __arg_match_I__(dim1_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_alt_match_I__(dim0_) and __arg_alt_match_I__(dim1_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0_),numpy.int32(dim1_),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
   mosek_fusion_ExprDenseTril._ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0_,dim1_,expr,1)
   _0=expr._getShape_()
   if ((self.__dim0==self.__dim1) or ((self.__dim0 < 0) or ((self.__dim0 >= int((_0).shape[0])) or ((self.__dim1 < 0) or ((self.__dim1 >= int((_0).shape[0])) or (_0[self.__dim0]!=_0[self.__dim1])))))): # src/fusion/ExprShape.monty:794:12-799:38
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension definitions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.code_base)
   _11=(_1.codeptr_base)
   _12=(_1.cconst_base)
   _13=(_1.nidxs_base)
   _14=(_1.sp_base)
   _15=(_1.cof_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=(self.__dim0 if ((self.__dim0 < self.__dim1) ) else self.__dim1)
   _20=(self.__dim0 if ((self.__dim0 > self.__dim1) ) else self.__dim1)
   _21=(self.__dim0 < self.__dim1)
   if ((self.__dim0==self.__dim1) or ((self.__dim0 < 0) or ((self.__dim0 >= _3) or ((self.__dim1 < 0) or (self.__dim1 >= _3))))): # src/fusion/ExprShape.monty:842:12-844:34
    raise mosek_fusion_DimensionError._ctor_S("Invalid symmetry dimensions")
   elif (_16[(_8 + self.__dim0)]!=_16[(_8 + self.__dim1)]): # src/fusion/ExprShape.monty:846:16-52
    raise mosek_fusion_DimensionError._ctor_S("Not symmetric in given dimensions")
   _22=numpy.array([1 for _23 in range(0,5)], dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_545(_22,_8,_16,_19) # src/fusion/ExprShape.monty:850:8-55
   _22[1] = _16[(_8 + self.__dim0)]
   fragments._c_closure_546(_22,_8,_16,_19,_20) # src/fusion/ExprShape.monty:852:8-61
   _22[3] = _16[(_8 + self.__dim1)]
   fragments._c_closure_547(_22,_3,_8,_16,_20) # src/fusion/ExprShape.monty:854:8-58
   _24=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _24[4] = 1
   fragments._c_closure_548(_22,_24) # src/fusion/ExprShape.monty:861:8-66
   _25=0
   _26=(((_22[0] * _22[2]) * _22[4]) * ((_22[1] * (_22[1] + 1)) // 2))
   _27=0
   _27,_25 = fragments._c_closure_549(_11,_22,_7,_6,_5,_9,_27,_25,_14,_24,_21,_16,_17) # src/fusion/ExprShape.monty:868:8-921:9
   _27 = numpy.int32(_27) # postprocess
   _25 = numpy.int32(_25) # postprocess
   _28=(((((_22[0] * _22[2]) * _22[4]) * _22[1]) * (_22[1] + 1)) // 2)
   _0._alloc_1expr_IIIZI(_3,_26,_25,True,_27)
   _29=(_0.ptr_base)
   _30=(_0.shape_base)
   _31=(_0.nidxs_base)
   _32=(_0.sp_base)
   _33=(_0.cof_base)
   _34=(_0.code_base)
   _35=(_0.codeptr_base)
   _36=(_0.cconst_base)
   _37=(_0.i32)
   _38=(_0.i64)
   _39=(_0.f64)
   _37[_29] = 0
   if (_27 > 0): # src/fusion/ExprShape.monty:948:12-26
    _37[_35] = 0
   fragments._c_closure_550(_3,_37,_30,_8,_16) # src/fusion/ExprShape.monty:950:8-59
   if _21: # src/fusion/ExprShape.monty:952:12-16
    _40=0
    _40 = fragments._c_closure_551(_22,_40,_38,_32,_24) # src/fusion/ExprShape.monty:954:10-961:19
    _40 = numpy.int32(_40) # postprocess
    if (_40!=_26): # src/fusion/ExprShape.monty:962:14-25
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   else:
    _41=0
    _41 = fragments._c_closure_552(_22,_41,_38,_32,_24) # src/fusion/ExprShape.monty:966:10-973:19
    _41 = numpy.int32(_41) # postprocess
    if (_41!=_26): # src/fusion/ExprShape.monty:974:14-25
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   _42=0
   _43=0
   _43,_42 = fragments._c_closure_553(_12,_10,_43,_11,_15,_28,_7,_5,_13,_42,_9,_36,_34,_35,_33,_39,_37,_38,_27,_31,_29,_32,_14,_18,_16,_17) # src/fusion/ExprShape.monty:981:10-1036:11
   _43 = numpy.int32(_43) # postprocess
   _42 = numpy.int32(_42) # postprocess
   if (_42!=_25): # src/fusion/ExprShape.monty:1039:14-25
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDenseTril(symdim=(")._a_I(self.__dim0)._a_S(",")._a_I(self.__dim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprDenseTril
mosek_fusion_ExprDenseTril=__mk_mosek_fusion_ExprDenseTril()
del __mk_mosek_fusion_ExprDenseTril
#BEFORE CLASS
def __mk_mosek_fusion_ExprDense():
 class ExprDense(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDense__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDense.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprDense._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDense._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprDense._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprDense._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDense.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDense'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprDense.__new__(ExprDense)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.nidxs_base)
   _11=(_1.cof_base)
   _12=(_1.sp_base)
   _13=(_1.codeptr_base)
   _14=(_1.code_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=1
   if _7: # src/fusion/ExprShape.monty:727:12-17
    _20=True
    _20,_19 = fragments._c_closure_554(_3,_20,_19,_8,_16) # src/fusion/ExprShape.monty:729:10-733:11
    _19 = numpy.int32(_19) # postprocess
    if (not _20): # src/fusion/ExprShape.monty:734:14-20
     raise mosek_fusion_LengthError._ctor_S("The domain is too large")
   else:
    _19 = _5
   _0._alloc_1expr_IIIZI(_3,_19,_4,False,_6)
   _21=(_0.shape_base)
   _22=(_0.ptr_base)
   _23=(_0.nidxs_base)
   _24=(_0.cof_base)
   _25=(_0.codeptr_base)
   _26=(_0.code_base)
   _27=(_0.cconst_base)
   _28=(_0.i32)
   _29=(_0.i64)
   _30=(_0.f64)
   fragments._c_closure_555(_15,_14,_13,_11,_7,_6,_3,_5,_10,_4,_9,_27,_26,_25,_24,_30,_28,_29,_19,_23,_22,_21,_8,_12,_18,_16,_17) # src/fusion/ExprShape.monty:753:8-769:9
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDense(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprDense
mosek_fusion_ExprDense=__mk_mosek_fusion_ExprDense()
del __mk_mosek_fusion_ExprDense
#BEFORE CLASS
def __mk_mosek_fusion_ExprSymmetrize():
 class ExprSymmetrize(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSymmetrize__dim1','_ExprSymmetrize__dim0','_ExprSymmetrize__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args): # int32,int32,mosek.fusion.Expression
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):# int32,int32,mosek.fusion.Expression
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2I(*args): # int32,int32,mosek.fusion.Expression,int32
      self._ctor_init_IILmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):# int32,int32,mosek.fusion.Expression,int32
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSymmetrize.ctor(int32,int32,mosek.fusion.Expression)\n\tmosek.fusion.ExprSymmetrize.ctor(int32,int32,mosek.fusion.Expression,int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSymmetrize._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSymmetrize._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSymmetrize.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprSymmetrize._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprSymmetrize._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSymmetrize.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSymmetrize'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_):
    o = ExprSymmetrize.__new__(ExprSymmetrize)
    o._ctor_init_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
    self._ctor_init_IILmosek_4fusion_4Expression_2I(numpy.int32(dim0),numpy.int32(dim1),expr,numpy.int32(unchecked_))
  def _ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
   if (dim0 < dim1): # src/fusion/ExprShape.monty:172:12-23
    (self.__dim0) = dim0
    (self.__dim1) = dim1
   else:
    (self.__dim0) = dim1
    (self.__dim1) = dim0
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr):
    o = ExprSymmetrize.__new__(ExprSymmetrize)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_match_I__(dim0_) and __arg_match_I__(dim1_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_alt_match_I__(dim0_) and __arg_alt_match_I__(dim1_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0_),numpy.int32(dim1_),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
   mosek_fusion_ExprSymmetrize._ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0_,dim1_,expr,1)
   _0=expr._getShape_()
   if ((self.__dim0 < 0) or ((self.__dim0==self.__dim1) or ((self.__dim1 >= int((_0).shape[0])) or (_0[self.__dim0]!=_0[self.__dim1])))): # src/fusion/ExprShape.monty:163:12-88
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension definitions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=0
   _4=(_1.nd)
   _5=(_1.nnz)
   _6=(_1.nelem)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.shape_base)
   _10=(_1.ptr_base)
   _11=(_1.code_base)
   _12=(_1.codeptr_base)
   _13=(_1.cconst_base)
   _14=(_1.nidxs_base)
   _15=(_1.sp_base)
   _16=(_1.cof_base)
   _17=(_1.i32)
   _18=(_1.i64)
   _19=(_1.f64)
   fragments._c_closure_556(_3,_4,_9,_17) # src/fusion/ExprShape.monty:211:8-214:9
   _20=_2._alloci32_I(_6)
   _21=_2._alloci32_I(_6)
   _22=_2._alloci32_I((_3 + 1))
   _23=_2._alloci64_I(_6)
   _24=(_2.i32)
   _25=(_2.i64)
   _26=0
   _27=0
   _28=0
   _29=numpy.array([1 for _30 in range(0,5)], dtype=numpy.dtype(numpy.int32))
   _31=numpy.zeros((5,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_557(_29,self.__dim0,_9,_17) # src/fusion/ExprShape.monty:234:8-54
   _29[1] = _17[(_9 + self.__dim0)]
   fragments._c_closure_558(_29,self.__dim0,self.__dim1,_9,_17) # src/fusion/ExprShape.monty:236:8-59
   _29[3] = _17[(_9 + self.__dim1)]
   fragments._c_closure_559(_29,self.__dim1,_4,_9,_17) # src/fusion/ExprShape.monty:238:8-57
   _31[4] = 1
   fragments._c_closure_560(_29,_31) # src/fusion/ExprShape.monty:239:23-81
   if _8: # src/fusion/ExprShape.monty:244:12-17
    _32=_20
    fragments._c_closure_561(_32,_6,_24) # src/fusion/ExprShape.monty:246:32-75
    _33=_21
    _34=numpy.array([1,2,3,0], dtype=numpy.dtype(numpy.int32))
    _32,_33 = fragments._c_closure_562(_32,_29,_6,_34,_15,_31,_33,_18,_24,_22) # src/fusion/ExprShape.monty:254:10-272:11
    _32 = numpy.int32(_32) # postprocess
    _33 = numpy.int32(_33) # postprocess
    fragments._c_closure_563(_29,_6,_15,_31,_18,_25,_23) # src/fusion/ExprShape.monty:280:10-285:74
    _28,_26,_27 = fragments._c_closure_564(_12,_32,_7,_6,_10,_28,_26,_27,_15,_17,_18,_24,_25,_23) # src/fusion/ExprShape.monty:289:10-331:11
    _28 = numpy.int32(_28) # postprocess
    _26 = numpy.int32(_26) # postprocess
    _27 = numpy.int32(_27) # postprocess
    _0._alloc_1expr_IIIZI(_4,_26,_27,True,_28)
    _35=_4
    _36=(_0.ptr_base)
    _37=(_0.nidxs_base)
    _38=(_0.shape_base)
    _39=(_0.sp_base)
    _40=(_0.cof_base)
    _41=(_0.code_base)
    _42=(_0.codeptr_base)
    _43=(_0.cconst_base)
    _44=(_0.i32)
    _45=(_0.i64)
    _46=(_0.f64)
    fragments._c_closure_565(_4,_44,_38,_9,_17) # src/fusion/ExprShape.monty:351:10-61
    _44[_36] = 0
    if (_28 > 0): # src/fusion/ExprShape.monty:354:14-28
     _44[_42] = 0
    _47=0
    _48=0
    _49=0
    _50=0
    _51=0
    _44[_36] = 0
    _48,_49,_51,_50,_47 = fragments._c_closure_566(_13,_11,_48,_12,_16,_32,_49,_51,_50,_6,_14,_47,_10,_43,_41,_42,_40,_46,_44,_45,_28,_37,_36,_39,_15,_19,_17,_18,_24,_25,_23) # src/fusion/ExprShape.monty:359:12-532:13
    _48 = numpy.int32(_48) # postprocess
    _49 = numpy.int32(_49) # postprocess
    _51 = numpy.int32(_51) # postprocess
    _50 = numpy.int32(_50) # postprocess
    _47 = numpy.int32(_47) # postprocess
    if (_47!=_27): # src/fusion/ExprShape.monty:535:16-27
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nzi")
   else:
    _26 = _6
    _27 = (_5 * 2)
    _28 = (((2 * _7) + ((2 * 2) * _5)) if ((_7 > 0) ) else 0)
    _28,_27 = fragments._c_closure_567(_12,_29,_7,_10,_28,_27,_31,_17) # src/fusion/ExprShape.monty:545:10-553:17
    _28 = numpy.int32(_28) # postprocess
    _27 = numpy.int32(_27) # postprocess
    _0._alloc_1expr_IIIZI(_4,_26,_27,False,_28)
    _52=(_0.ptr_base)
    _53=(_0.shape_base)
    _54=(_0.code_base)
    _55=(_0.codeptr_base)
    _56=(_0.nidxs_base)
    _57=(_0.sp_base)
    _58=(_0.cof_base)
    _59=(_0.cconst_base)
    _60=(_0.i32)
    _61=(_0.i64)
    _62=(_0.f64)
    _63=0
    _64=0
    _65=0
    fragments._c_closure_568(_4,_60,_53,_9,_17) # src/fusion/ExprShape.monty:577:10-61
    _60[_52] = 0
    if (_28 > 0): # src/fusion/ExprShape.monty:580:14-28
     _60[_55] = 0
    _66=0
    _65,_66,_63,_64 = fragments._c_closure_569(_13,_11,_65,_12,_16,_29,_66,_14,_63,_10,_59,_54,_55,_58,_64,_62,_60,_61,_28,_56,_52,_31,_19,_17,_18) # src/fusion/ExprShape.monty:583:10-674:19
    _65 = numpy.int32(_65) # postprocess
    _66 = numpy.int32(_66) # postprocess
    _63 = numpy.int32(_63) # postprocess
    _64 = numpy.int32(_64) # postprocess
    if (_63!=_27): # src/fusion/ExprShape.monty:675:14-25
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
    if (_64!=_26): # src/fusion/ExprShape.monty:676:14-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   _2._clear_()
   _0._peek_1expr_()
   if ((_0.nnz)!=(_0.i32)[((_0.ptr_base) + (_0.nelem))]): # src/fusion/ExprShape.monty:682:12-50
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
   if ((_0.i32)[(_0.ptr_base)]!=0): # src/fusion/ExprShape.monty:683:12-36
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprSymmetrize(symdim=(")._a_I(self.__dim0)._a_S(",")._a_I(self.__dim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprSymmetrize
mosek_fusion_ExprSymmetrize=__mk_mosek_fusion_ExprSymmetrize()
del __mk_mosek_fusion_ExprSymmetrize
#BEFORE CLASS
def __mk_mosek_fusion_ExprCondense():
 class ExprCondense(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCondense__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCondense.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprCondense._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCondense._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCondense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprCondense._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprCondense._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCondense.toString()')
  def __repr__(self): return 'mosek.fusion.ExprCondense'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprCondense.__new__(ExprCondense)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
   _0._peek_1expr_()
   if (_0.hassp): # src/fusion/ExprShape.monty:119:12-20
    _3=_0._popi32_()
    _0._popi32_I(_3)
    _4=_0._popi32_()
    _5=_0._popi32_()
    _0._popi32_()
    _0._popi64_I(_4)
    _0._pushi32_I(0)
    _0._pushi32_I(_5)
    _0._pushi32_I(_4)
    _0._pushi32_I(_4)
    _0._pushi32_I(1)
    _0._peek_1expr_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprCondense(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprCondense
mosek_fusion_ExprCondense=__mk_mosek_fusion_ExprCondense()
del __mk_mosek_fusion_ExprCondense
#BEFORE CLASS
def __mk_mosek_fusion_ExprFromVar():
 class ExprFromVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprFromVar__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      self._ctor_init_Lmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2(*args):# mosek.fusion.Variable
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprFromVar.ctor(mosek.fusion.Variable)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprFromVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprFromVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprFromVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprFromVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprFromVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprFromVar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprFromVar'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2(x):
    o = ExprFromVar.__new__(ExprFromVar)
    o._ctor_init_Lmosek_4fusion_4Variable_2(x)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    x, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    x, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2(self,x):
    self._ctor_init_Lmosek_4fusion_4Variable_2(x)
  def _ctor_init_Lmosek_4fusion_4Variable_2(self,x):
   mosek_fusion_BaseExpression._ctor_init__3I(self,x._getShape_())
   (self.__x) = x
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self._getShape_()
   _4=mosek.fusion.Set._size__3I(_3)
   _5=self.__x._numInst_()
   _6=_5
   _7=(_4 > _5)
   _0._alloc_1expr_IIIZ(int((_3).shape[0]),_5,_6,_7)
   _8=(_0.ptr_base)
   _9=(_0.nidxs_base)
   _10=(_0.sp_base)
   _11=(_0.cof_base)
   _12=(_0.shape_base)
   _13=(_0.i32)
   _14=(_0.i64)
   _15=(_0.f64)
   fragments._c_closure_570(_13,_3,_12) # src/fusion/ExprShape.monty:82:8-66
   fragments._c_closure_571(_11,_5,_6,_8,_15,_13) # src/fusion/ExprShape.monty:84:8-87:9
   if _7: # src/fusion/ExprShape.monty:88:12-17
    self.__x._inst_I_3JI_3J(_10,_14,_9,_14)
   else:
    self.__x._inst_I_3J(_9,_14)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("Expr(")._a_S(self.__x._toString_())._a_S(")")._toString_())
 return ExprFromVar
mosek_fusion_ExprFromVar=__mk_mosek_fusion_ExprFromVar()
del __mk_mosek_fusion_ExprFromVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprReshape():
 class ExprReshape(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprReshape__e']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3ILmosek_4fusion_4Expression_2(*args): # []int32,mosek.fusion.Expression
      self._ctor_init__3ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):# []int32,mosek.fusion.Expression
      self._ctor_alt_init__3ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprReshape.ctor(array(int32,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprReshape._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprReshape._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprReshape.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprReshape._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprReshape._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprReshape.toString()')
  def __repr__(self): return 'mosek.fusion.ExprReshape'
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2(shape,e):
    o = ExprReshape.__new__(ExprReshape)
    o._ctor_init__3ILmosek_4fusion_4Expression_2(shape,e)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    shape,e, = args
    return (__arg_match__3I__(shape) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    shape,e, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2(self,shape,e):
    self._ctor_init__3ILmosek_4fusion_4Expression_2(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),e)
  def _ctor_init__3ILmosek_4fusion_4Expression_2(self,shape,e):
   assert shape is None or isinstance(shape,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.Utils.Tools._arraycopy__3I(shape))
   _0=e._getSize_()
   if (mosek.fusion.Set._size__3I(shape)!=e._getSize_()): # src/fusion/ExprShape.monty:10:12-42
    raise mosek_fusion_LengthError._ctor_S("Cannot reshape to mismatching shape")
   (self.__e) = e
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self._getShape_()
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
   _0._peek_1expr_()
   _4=_0._popi32_()
   _5=1
   for _6 in range(0,_4):
    _5 *= _0._popi32_()
   if (_5!=self._getSize_()): # src/fusion/ExprShape.monty:37:12-27
    raise mosek_fusion_DimensionError._ctor_S("The two shapes have different sizes")
   for _7 in range(0,int((_3).shape[0])):
    _0._pushi32_I(_3[_7])
   _0._pushi32_I(int((_3).shape[0]))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprReshape((")
   if (self._getND_() > 0): # src/fusion/ExprShape.monty:18:12-23
    _0._a_I(self._getDim_I(0))
    for _1 in range(1,self._getND_()):
     _0._a_S(",")._a_I(self._getDim_I(_1))
   _0._a_S("),")._a_S(self.__e._toString_())._a_S(")")
   return (_0._toString_())
 return ExprReshape
mosek_fusion_ExprReshape=__mk_mosek_fusion_ExprReshape()
del __mk_mosek_fusion_ExprReshape
#BEFORE CLASS
def __mk_mosek_fusion_Expr():
 class Expr(mosek_fusion_BaseExpression):
  __slots__ = ['_Expr__inst','_Expr__cof_v','_Expr__subj','_Expr__ptrb','_Expr__bfix','_Expr__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3J_3D_3D_3I_3J(*args): # []int64,[]int64,[]double,[]double,[]int32,[]int64
      self._ctor_init__3J_3J_3D_3D_3I_3J(*args)
    elif self.__match_alt_ctor__3J_3J_3D_3D_3I_3J(*args):# []int64,[]int64,[]double,[]double,[]int32,[]int64
      self._ctor_alt_init__3J_3J_3D_3D_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Expr.ctor(array(int64,ndim=1),array(int64,ndim=1),array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int64,ndim=1))')
  @staticmethod
  def neg(*args):
    if False: pass
    elif mosek_fusion_Expr._match_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list neg('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.neg(mosek.fusion.Expression)')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Expr._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.getND()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_Expr._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Expr._match_ones_(*args): # 
      return mosek_fusion_Expr._ones_(*args)
    elif mosek_fusion_Expr._match_alt_ones_(*args): # 
      return mosek_fusion_Expr._ones_alt_(*args)
    elif mosek_fusion_Expr._match_ones__3I(*args): # []int32
      return mosek_fusion_Expr._ones__3I(*args)
    elif mosek_fusion_Expr._match_alt_ones__3I(*args): # []int32
      return mosek_fusion_Expr._ones_alt__3I(*args)
    elif mosek_fusion_Expr._match_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_I(*args)
    elif mosek_fusion_Expr._match_alt_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_alt_I(*args)
    elif mosek_fusion_Expr._match_ones__3I_3_5I(*args): # []int32,[,]int32
      return mosek_fusion_Expr._ones__3I_3_5I(*args)
    elif mosek_fusion_Expr._match_alt_ones__3I_3_5I(*args): # []int32,[,]int32
      return mosek_fusion_Expr._ones_alt__3I_3_5I(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.ones()\n\tmosek.fusion.Expr.ones(array(int32,ndim=1))\n\tmosek.fusion.Expr.ones(int32)\n\tmosek.fusion.Expr.ones(array(int32,ndim=1),array(int32,ndim=2))')
  @staticmethod
  def zeros(*args):
    if False: pass
    elif mosek_fusion_Expr._match_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_I(*args)
    elif mosek_fusion_Expr._match_alt_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_alt_I(*args)
    elif mosek_fusion_Expr._match_zeros__3I(*args): # []int32
      return mosek_fusion_Expr._zeros__3I(*args)
    elif mosek_fusion_Expr._match_alt_zeros__3I(*args): # []int32
      return mosek_fusion_Expr._zeros_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list zeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.zeros(int32)\n\tmosek.fusion.Expr.zeros(array(int32,ndim=1))')
  @staticmethod
  def sum(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list sum('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,int32)')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.hstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.hstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,double)')
  @staticmethod
  def condense(*args):
    if False: pass
    elif mosek_fusion_Expr._match_condense_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._condense_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_condense_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._condense_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list condense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.condense(mosek.fusion.Expression)')
  @staticmethod
  def add(*args):
    if False: pass
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.add(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.add(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,double)')
  @staticmethod
  def transpose(*args):
    if False: pass
    elif mosek_fusion_Expr._match_transpose_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._transpose_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_transpose_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._transpose_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.transpose(mosek.fusion.Expression)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_DDD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_alt_DDD(*args)
    elif mosek_fusion_Expr._match_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.vstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.vstack(double,double,double)\n\tmosek.fusion.Expr.vstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,double)')
  @staticmethod
  def mulElm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    else:
      raise ValueError('Invalid argument list mulElm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=2))')
  @staticmethod
  def dot(*args):
    if False: pass
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    else:
      raise ValueError('Invalid argument list dot('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.dot(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=2))')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2_3I(*args): # mosek.fusion.Expression,[]int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2_3I(*args): # mosek.fusion.Expression,[]int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,array(int32,ndim=1))\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def outer(*args):
    if False: pass
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Variable_2_3D(*args): # mosek.fusion.Variable,[]double
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Variable_2_3D(*args)
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Variable_2(*args): # []double,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list outer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.outer(mosek.fusion.Variable,array(double,ndim=1))\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Variable)\n\tmosek.fusion.Expr.outer(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.outer(mosek.fusion.Matrix,mosek.fusion.Variable)')
  @staticmethod
  def constTerm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm__3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm_alt__3D(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm__3_5D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm_alt__3_5D(*args)
    elif mosek_fusion_Expr._match_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_alt_D(*args)
    elif mosek_fusion_Expr._match_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_alt_ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3ID(*args): # []int32,double
      return mosek_fusion_Expr._constTerm__3ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3ID(*args): # []int32,double
      return mosek_fusion_Expr._constTerm_alt__3ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_Expr._constTerm__3I_3_5I_3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_Expr._constTerm_alt__3I_3_5I_3D(*args)
    elif mosek_fusion_Expr._match_constTerm__3I_3_5ID(*args): # []int32,[,]int32,double
      return mosek_fusion_Expr._constTerm__3I_3_5ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3I_3_5ID(*args): # []int32,[,]int32,double
      return mosek_fusion_Expr._constTerm_alt__3I_3_5ID(*args)
    else:
      raise ValueError('Invalid argument list constTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.constTerm(array(double,ndim=1))\n\tmosek.fusion.Expr.constTerm(mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.constTerm(mosek.fusion.Matrix)\n\tmosek.fusion.Expr.constTerm(array(double,ndim=2))\n\tmosek.fusion.Expr.constTerm(double)\n\tmosek.fusion.Expr.constTerm(int32,double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),double)')
  @staticmethod
  def mul(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,double)')
  @staticmethod
  def mulDiag(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Parameter,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Parameter,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Variable,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Variable,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list mulDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Parameter,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Parameter)')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Expr._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.numNonzeros()')
  @staticmethod
  def sub(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,double)')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Expr._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.size()')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.repeat(mosek.fusion.Variable,int32,int32)\n\tmosek.fusion.Expr.repeat(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Expr._match_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.flatten(mosek.fusion.Expression)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expr._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.getShape()')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.stack(array(array(mosek.fusion.Expression,ndim=1),ndim=1))\n\tmosek.fusion.Expr.stack(int32,array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)')
  def __repr__(self): return 'mosek.fusion.Expr'
  @staticmethod
  def _ctor__3J_3J_3D_3D_3I_3J(ptrb,subj,cof,bfix,shape,inst):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3J_3D_3D_3I_3J(ptrb,subj,cof,bfix,shape,inst)
    return o
  @staticmethod
  def __match_ctor__3J_3J_3D_3D_3I_3J(*args):
    if len(args) != 6: return False
    ptrb,subj,cof,bfix,shape,inst, = args
    return (__arg_match__3J__(ptrb) and __arg_match__3J__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(shape) and __arg_match__3J__(inst))
  @staticmethod
  def __match_alt_ctor__3J_3J_3D_3D_3I_3J(*args):
    if len(args) != 6: return False
    ptrb,subj,cof,bfix,shape,inst, = args
    return (__arg_alt_match__3J__(ptrb) and __arg_alt_match__3J__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(inst))
  def _ctor_alt_init__3J_3J_3D_3D_3I_3J(self,ptrb,subj,cof,bfix,shape,inst):
    self._ctor_init__3J_3J_3D_3D_3I_3J(numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int64)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3J_3J_3D_3D_3I_3J(self,ptrb,subj,cof,bfix,shape,inst):
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert shape is None or isinstance(shape,numpy.ndarray)
   assert inst is None or isinstance(inst,numpy.ndarray)
   mosek_fusion_Expr._ctor_init__3J_3J_3D_3D_3I_3JI(self,mosek.fusion.Utils.Tools._arraycopy__3J(ptrb),mosek.fusion.Utils.Tools._arraycopy__3J(subj),mosek.fusion.Utils.Tools._arraycopy__3D(cof),mosek.fusion.Utils.Tools._arraycopy__3D(bfix),(mosek.fusion.Utils.Tools._arraycopy__3I(shape) if ((shape is not None) ) else numpy.array([(int((ptrb).shape[0]) - 1)], dtype=numpy.dtype(numpy.int32))),(mosek.fusion.Utils.Tools._arraycopy__3J(inst) if ((inst is not None) ) else None),1)
   _0=(int((ptrb).shape[0]) - 1)
   if (_0 < 0): # src/fusion/Expr.mbi:583:12-21
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb")
   _1=ptrb[_0]
   if ((_1 < 0) or ((_1!=int((cof).shape[0])) or (_1!=int((subj).shape[0])))): # src/fusion/Expr.mbi:586:12-58
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb construction")
   _2=True
   _3=True
   _4=True
   _5=(self.__shape)
   _6=mosek.fusion.Set._size__3I(_5)
   _4,_2,_3 = fragments._c_closure_572(inst,_4,_0,ptrb,_2,_3,_6,_5) # src/fusion/Expr.mbi:594:8-601:9
   if (not _3): # src/fusion/Expr.mbi:602:12-24
    raise mosek_fusion_ExpressionError._ctor_S("Invalid shape")
   if (not _2): # src/fusion/Expr.mbi:604:12-23
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb")
   if (not _4): # src/fusion/Expr.mbi:606:12-23
    raise mosek_fusion_ExpressionError._ctor_S("Invalid sparsity pattern")
  @staticmethod
  def _ctor__3J_3J_3D_3D_3I_3JI(ptrb,subj,cof,bfix,shp,inst,unchecked_):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3J_3D_3D_3I_3JI(ptrb,subj,cof,bfix,shp,inst,unchecked_)
    return o
  @staticmethod
  def __match_ctor__3J_3J_3D_3D_3I_3JI(*args):
    if len(args) != 7: return False
    ptrb,subj,cof,bfix,shp,inst,unchecked_, = args
    return (__arg_match__3J__(ptrb) and __arg_match__3J__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(shp) and __arg_match__3J__(inst) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor__3J_3J_3D_3D_3I_3JI(*args):
    if len(args) != 7: return False
    ptrb,subj,cof,bfix,shp,inst,unchecked_, = args
    return (__arg_alt_match__3J__(ptrb) and __arg_alt_match__3J__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(shp) and __arg_alt_match__3J__(inst) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init__3J_3J_3D_3D_3I_3JI(self,ptrb,subj,cof,bfix,shp,inst,unchecked_):
    self._ctor_init__3J_3J_3D_3D_3I_3JI(numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int64)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)),numpy.int32(unchecked_))
  def _ctor_init__3J_3J_3D_3D_3I_3JI(self,ptrb,subj,cof,bfix,shp,inst,unchecked_):
   assert ptrb is None or isinstance(ptrb,numpy.ndarray)
   assert subj is None or isinstance(subj,numpy.ndarray)
   assert cof is None or isinstance(cof,numpy.ndarray)
   assert bfix is None or isinstance(bfix,numpy.ndarray)
   assert shp is None or isinstance(shp,numpy.ndarray)
   assert inst is None or isinstance(inst,numpy.ndarray)
   mosek_fusion_BaseExpression._ctor_init__3I(self,shp)
   (self.__shape) = shp
   (self.__ptrb) = ptrb
   (self.__subj) = subj
   (self.__cof_v) = cof
   (self.__bfix) = bfix
   (self.__inst) = inst
   if ((self.__shape) is None): # src/fusion/Expr.mbi:521:12-30
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: NULL shape")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(e):
    o = Expr.__new__(Expr)
    o._ctor_init_Lmosek_4fusion_4Expression_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,e):
    self._ctor_init_Lmosek_4fusion_4Expression_2(e)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e._getShape_())
   _1=e
   if   isinstance(_1,mosek_fusion_Expr):
    ee=_1
    self.__shape = (ee.__shape)
    self.__ptrb = (ee.__ptrb)
    self.__subj = (ee.__subj)
    self.__cof_v = (ee.__cof_v)
    self.__bfix = (ee.__bfix)
    self.__inst = (ee.__inst)
   else:
    ee=_1
    _1=mosek_fusion_WorkStack._ctor_()
    _2=mosek_fusion_WorkStack._ctor_()
    _3=mosek_fusion_WorkStack._ctor_()
    ee._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_3,_2,_1)
    _4=_3._popi32_()
    _5=_3._popi32_I(_4)
    _6=_3._popi32_()
    _7=_3._popi32_()
    _8=(_3._popi32_()!=0)
    _9=_3._popi32_I((_6 + 1))
    _10=(_3._popi64_I(_6) if (_8 ) else 0)
    _11=_3._popi64_I(_7)
    _12=_3._popf64_I(_6)
    _13=_3._popf64_I(_7)
    _14=(_3.i32)
    _15=(_3.i64)
    _16=(_3.f64)
    self.__shape = numpy.array([_14[(_5 + _17)] for _17 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
    self.__ptrb = numpy.array([_14[(_9 + _18)] for _18 in range(0,(_6 + 1))], dtype=numpy.dtype(numpy.int64))
    self.__subj = numpy.array([_15[(_11 + _19)] for _19 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    self.__cof_v = numpy.array([_16[(_13 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.float64))
    self.__bfix = numpy.array([_16[(_12 + _21)] for _21 in range(0,_7)], dtype=numpy.dtype(numpy.float64))
    self.__inst = (numpy.array([_15[(_10 + _22)] for _22 in range(0,_7)], dtype=numpy.dtype(numpy.int64)) if (_8 ) else None)
   if (self.__shape is None): # src/fusion/Expr.mbi:423:12-25
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: NULL shape")
  def __prod_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__prod__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __prod__3I(self,_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=1
   _1 = fragments._c_closure_573(_1,_0) # src/fusion/Expr.mbi:1702:58-98
   _1 = numpy.int32(_1) # postprocess
   return numpy.int32(_1)
  @staticmethod
  def __varstack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3_3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (numpy.array([_0[_1][_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0[_1]).shape[0]))], dtype=numpy.dtype(object)))
  @staticmethod
  def __varstack_alt__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:1686:12-22
    return (_1)
   elif (_1 is None): # src/fusion/Expr.mbi:1687:16-26
    return (_0)
   else:
    _2=numpy.ndarray(((int((_0).shape[0]) + int((_1).shape[0])),), dtype=numpy.dtype(object))
    for _3 in range(0,int((_0).shape[0])):
     _2[_3] = _0[_3]
    for _4 in range(0,int((_1).shape[0])):
     _2[(_4 + int((_0).shape[0]))] = _1[_4]
    return (_2)
  @staticmethod
  def _match_condense_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_condense_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _condense_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._condense_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _condense_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprCondense._ctor_Lmosek_4fusion_4Expression_2(_0))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None): # src/fusion/Expr.mbi:1670:12-21
    raise ValueError("Arguments for flatten may not be null")
   _1=_0._getSize_()
   if (not (_1 <= 2147483647)): # src/fusion/Expr.mbi:1672:12-34
    raise mosek_fusion_LengthError._ctor_S("Maximum dimension size exceeded")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_0 is None): # src/fusion/Expr.mbi:1661:12-21
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,mosek.fusion.Set._make_II(_1,_2)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2I(_0,_1):
   if (_0 is None): # src/fusion/Expr.mbi:1651:12-21
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,mosek.fusion.Set._make_I(_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2_3I(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   return numpy.int64((int((self.__ptrb).shape[0]) - 1))
  @staticmethod
  def _match_zeros__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_zeros__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _zeros_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._zeros__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _zeros__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._constTerm__3ID(_0,0))
  @staticmethod
  def _match_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _zeros_alt_I(_t__0):
    return mosek_fusion_Expr._zeros_I(numpy.int32(__0))
  @staticmethod
  def _zeros_I(_0):
   return (mosek.fusion.Expr._constTerm_ID(_0,0))
  @staticmethod
  def _match_ones_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_ones_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _ones_alt_():
    return mosek_fusion_Expr._ones_()
  @staticmethod
  def _ones_():
   return (mosek.fusion.Expr._constTerm_D(1))
  @staticmethod
  def _match_ones__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_ones__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _ones_alt__3I_3_5I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._ones__3I_3_5I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ones__3I_3_5I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr._constTerm__3I_3_5ID(_0,_1,1))
  @staticmethod
  def _match_ones__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_ones__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _ones_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._ones__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ones__3I(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._constTerm__3ID(_0,1))
  @staticmethod
  def _match_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _ones_alt_I(_t__0):
    return mosek_fusion_Expr._ones_I(numpy.int32(__0))
  @staticmethod
  def _ones_I(_0):
   return (mosek.fusion.Expr._constTerm_ID(_0,1))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4NDSparseArray_2(_0):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D((_0._dims),(_0._inst),(_0._cof)))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4Matrix_2(_0):
   _1=_0._numRows_()
   _2=_0._numColumns_()
   _3=mosek.fusion.Set._make_II(_1,_2)
   if _0._isSparse_(): # src/fusion/Expr.mbi:1608:12-24
    _4=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _0._getDataAsTriplets__3I_3I_3D(_6,_5,_4)
    _7=numpy.array([((_6[_8] * _2) + _5[_8]) for _8 in range(0,int((_5).shape[0]))], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_3,_7,_4))
   else:
    return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_3,None,_0._getDataAsArray_()))
  @staticmethod
  def _match_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _constTerm_alt_D(_t__0):
    return mosek_fusion_Expr._constTerm_D(numpy.float64(__0))
  @staticmethod
  def _constTerm_D(_0):
   return (mosek_fusion_ExprConst._ctor__3I_3JD(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,_0))
  @staticmethod
  def _match_constTerm__3I_3_5ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_constTerm__3I_3_5ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _constTerm_alt__3I_3_5ID(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.float64(_t__2)
   _1 = mosek_fusion_Expr._constTerm__3I_3_5ID(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3I_3_5ID(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((_1).shape[0])
   _4=int((_0).shape[0])
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _6[(_4 - 1)] = 1
   fragments._c_closure_574(_4,_6,_0) # src/fusion/Expr.mbi:1589:43-93
   fragments._c_closure_575(_3,_4,_6,_5,_1) # src/fusion/Expr.mbi:1590:8-1592:42
   return (mosek_fusion_ExprConst._ctor__3I_3JD(_0,_5,_2))
  @staticmethod
  def _match_constTerm__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_constTerm__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _constTerm_alt__3I_3_5I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3I_3_5I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3I_3_5I_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=int((_1).shape[0])
   _4=int((_0).shape[0])
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _6[(_4 - 1)] = 1
   fragments._c_closure_576(_4,_6,_0) # src/fusion/Expr.mbi:1578:43-93
   fragments._c_closure_577(_3,_4,_6,_5,_1) # src/fusion/Expr.mbi:1579:8-1581:42
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_0,_5,_2))
  @staticmethod
  def _match_constTerm__3ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm__3ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt__3ID(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.float64(_t__1)
   _1 = mosek_fusion_Expr._constTerm__3ID(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3ID(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprConst._ctor__3I_3JD(_0,None,_1))
  @staticmethod
  def _match_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt_ID(_t__0,_t__1):
    return mosek_fusion_Expr._constTerm_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _constTerm_ID(_0,_1):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([_0], dtype=numpy.dtype(numpy.int32)),None,numpy.array([_1 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _constTerm_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3_5D(_0)
   return _1
  @staticmethod
  def _constTerm__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32)),None,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _constTerm_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)),None,_0))
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(int((self.__cof_v).shape[0]))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2I(_0,_1):
   return (mosek_fusion_ExprSumReduce._ctor_ILmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprSumReduce._ctor_ILmosek_4fusion_4Expression_2(0,mosek.fusion.Expr._flatten_Lmosek_4fusion_4Expression_2(_0)))
  @staticmethod
  def _match_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _neg_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _neg_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2((- 1),_0))
  @staticmethod
  def __mulDiag_alt_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def __mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   _3=_1._numNonzeros_()
   _4=_1._numRows_()
   _5=_1._numColumns_()
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _1._getDataAsTriplets__3I_3I_3D(_8,_7,_6)
   if _0: # src/fusion/Expr.mbi:1528:12-16
    return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_4,_5,_8,_7,_6,_2))
   else:
    return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_4,_5,_8,_7,_6,_2))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek_fusion_ExprMulParamDiagRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0._asExpr_(),_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek_fusion_ExprMulParamDiagLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek_fusion_ExprMulParamDiagRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprMulParamDiagLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_1).shape[0]),int((_1).shape[1]),numpy.array([_2 for _2 in range(0,int((_1).shape[0])) for _3 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_1).shape[0])) for _5 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_1[_6,_7] for _6 in range(0,int((_1).shape[0])) for _7 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),_0._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_1).shape[0]),int((_1).shape[1]),numpy.array([_2 for _2 in range(0,int((_1).shape[0])) for _3 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_1).shape[0])) for _5 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_1[_6,_7] for _6 in range(0,int((_1).shape[0])) for _7 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),_0))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_0).shape[0]),int((_0).shape[1]),numpy.array([_2 for _2 in range(0,int((_0).shape[0])) for _3 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_0).shape[0])) for _5 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_6,_7] for _6 in range(0,int((_0).shape[0])) for _7 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),_1._asExpr_()))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_0).shape[0]),int((_0).shape[1]),numpy.array([_2 for _2 in range(0,int((_0).shape[0])) for _3 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_0).shape[0])) for _5 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_6,_7] for _6 in range(0,int((_0).shape[0])) for _7 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   _2=_1._getShape_()
   _3=_1
   if (int((_2).shape[0])==1): # src/fusion/Expr.mbi:1484:12-28
    _2 = numpy.array([_2[0],1], dtype=numpy.dtype(numpy.int32))
    _3 = mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_2,_1)
   if ((int((_2).shape[0])!=2) or ((_0._numRows_()!=_2[0]) or (_0._numColumns_()!=_2[1]))): # src/fusion/Expr.mbi:1488:12-1490:39
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _4=_0._numColumns_()
   _5=_0._numNonzeros_()
   _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_6,_7,_8)
   return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2I(_8,numpy.array([((_6[_9] * _4) + _7[_9]) for _9 in range(0,_5)], dtype=numpy.dtype(numpy.int64)),_3,1))
  @staticmethod
  def __mulElm_1_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if ((_0 is None) or (_1 is None)): # src/fusion/Expr.mbi:1469:12-37
    raise ValueError("Arguments for mulElm may not be null")
   if ((_1._getND_()==0) and (int((_0).shape[0])==1)): # src/fusion/Expr.mbi:1471:12-45
    return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_0[0],_1))
   elif ((_1._getND_()!=1) or (_1._getDim_I(0)!=int((_0).shape[0]))): # src/fusion/Expr.mbi:1473:16-1474:40
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   else:
    return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2(_0,numpy.array([_2 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)): # src/fusion/Expr.mbi:1456:12-39
    raise ValueError("Arguments for mulElm may not be null")
   _2=_1._getShape_()
   if (int((_2).shape[0])!=int(((_0._dims)).shape[0])): # src/fusion/Expr.mbi:1458:12-40
    raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   for _3 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_3]!=_2[_3]): # src/fusion/Expr.mbi:1461:14-38
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2((_0._cof),(_0._inst),_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _mul_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mul__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def __mul_alt_Z_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = mosek_fusion_Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_Z_3DLmosek_4fusion_4Expression_2(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((_1).shape[0])
   _4=_3
   _5=mosek.fusion.Utils.Tools._arraycopy__3D(_1)
   _6=_2._getND_()
   if (_6==0): # src/fusion/Expr.mbi:1430:12-19
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_3], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,1,numpy.array([_7 for _7 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _8 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1)))
   elif (_6!=2): # src/fusion/Expr.mbi:1432:16-23
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   elif (_0 and (_2._getDim_I(0)==int((_1).shape[0]))): # src/fusion/Expr.mbi:1434:21-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_2._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(1,_3,numpy.array([0 for _9 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([_10 for _10 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2)))
   elif (_0 and (_2._getDim_I(0)==1)): # src/fusion/Expr.mbi:1436:17-42
    return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,1,numpy.array([_11 for _11 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _12 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1))
   elif ((not _0) and (_2._getDim_I(1)==_3)): # src/fusion/Expr.mbi:1438:17-50
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_2._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,1,numpy.array([_13 for _13 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _14 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2)))
   elif ((not _0) and (_2._getDim_I(1)==1)): # src/fusion/Expr.mbi:1440:17-46
    return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(1,_3,numpy.array([0 for _15 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([_16 for _16 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def __mul_alt_Z_3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = mosek_fusion_Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(_0,_1,_2)
   return _1
  @staticmethod
  def __mul_Z_3_5DLmosek_4fusion_4Expression_2(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=int((_1).shape[0])
   _4=int((_1).shape[1])
   _5=(_3 * _4)
   _6=numpy.array([_7 for _7 in range(0,_3) for _8 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
   _9=numpy.array([_11 for _10 in range(0,_3) for _11 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
   _12=numpy.array([_1[_13,_14] for _13 in range(0,_3) for _14 in range(0,_4)], dtype=numpy.dtype(numpy.float64))
   _15=_2._getSize_()
   _16=_2._getShape_()
   if (int((_16).shape[0])==0): # src/fusion/Expr.mbi:1404:12-28
    return (mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,_4,_6,_9,_12,_2,1))
   elif _0: # src/fusion/Expr.mbi:1406:16-20
    if (int((_16).shape[0])==1): # src/fusion/Expr.mbi:1407:14-30
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_16[0],1], dtype=numpy.dtype(numpy.int32)),_2))))
    elif (int((_16).shape[0])==2): # src/fusion/Expr.mbi:1409:18-34
     return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,_2))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   else:
    if (int((_16).shape[0])==1): # src/fusion/Expr.mbi:1415:14-30
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([int((_1).shape[1])], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_16[0]], dtype=numpy.dtype(numpy.int32)),_2))))
    elif (int((_16).shape[0])==2): # src/fusion/Expr.mbi:1417:18-34
     return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,_2))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def __mul_alt_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def __mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   _3=_1._numNonzeros_()
   _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _7=_1._numRows_()
   _8=_1._numColumns_()
   _1._getDataAsTriplets__3I_3I_3D(_4,_5,_6)
   _9=_2._getND_()
   if (_9==0): # src/fusion/Expr.mbi:1374:12-19
    return (mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
   elif (_9==1): # src/fusion/Expr.mbi:1376:16-23
    _10=_2._getShape_()
    if _0: # src/fusion/Expr.mbi:1378:14-18
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_7], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_10[0],1], dtype=numpy.dtype(numpy.int32)),_2))))
    else:
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_8], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_10[0]], dtype=numpy.dtype(numpy.int32)),_2))))
   elif (_9==2): # src/fusion/Expr.mbi:1383:16-23
    if _0: # src/fusion/Expr.mbi:1384:14-18
     return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
    else:
     return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions for multiplication")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_1._numRows_()
   _3=_1._numColumns_()
   _4=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _1._getDataAsTriplets__3I_3I_3D(_6,_5,_4)
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(False,_2,_3,_6,_5,_4,_0))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   _2=_0._numRows_()
   _3=_0._numColumns_()
   _4=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _0._getDataAsTriplets__3I_3I_3D(_6,_5,_4)
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(True,_2,_3,_6,_5,_4,_1))
  @staticmethod
  def __mul_alt_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=_t__6
   _1 = mosek_fusion_Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6):
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   if (_6._getND_()==0): # src/fusion/Expr.mbi:1329:12-26
    return (mosek_fusion_ExprMulScalarVar._ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(_1,_2,_3,_4,_5,_6))
   elif (_6._getND_()==1): # src/fusion/Expr.mbi:1331:16-30
    _7=_6._getShape_()
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([(_1 if (_0 ) else _2)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulVar._ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_6,(numpy.array([_7[0],1], dtype=numpy.dtype(numpy.int32)) if (_0 ) else numpy.array([1,_7[0]], dtype=numpy.dtype(numpy.int32)))))))
   else:
    return (mosek_fusion_ExprMulVar._ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   if ((_1._getND_()==2) and (_0._getND_()==2)): # src/fusion/Expr.mbi:1314:16-52
    return (mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1))
   elif ((_1._getND_()==1) and (_0._getND_()==2)): # src/fusion/Expr.mbi:1316:16-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1._reshape__3I(numpy.array([_1._getDim_I(0),1], dtype=numpy.dtype(numpy.int32))))))
   elif ((_1._getND_()==2) and (_0._getND_()==1)): # src/fusion/Expr.mbi:1318:16-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_1._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),_0),_1)))
   elif (_1._getND_()==0): # src/fusion/Expr.mbi:1320:16-30
    return (mosek_fusion_ExprMulParamScalar._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_1,_0))
   elif (_0._getND_()==0): # src/fusion/Expr.mbi:1322:16-33
    return (mosek_fusion_ExprMulParamScalarExpr._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_1,_0))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0._getND_()==2) and (_1._getND_()==2)): # src/fusion/Expr.mbi:1300:16-52
    return (mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
   elif ((_0._getND_()==1) and (_1._getND_()==2)): # src/fusion/Expr.mbi:1302:16-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_1._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0._reshape__3I(numpy.array([1,_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32))),_1)))
   elif ((_0._getND_()==2) and (_1._getND_()==1)): # src/fusion/Expr.mbi:1304:16-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_1._getDim_I(0),1], dtype=numpy.dtype(numpy.int32)),_1))))
   elif (_0._getND_()==0): # src/fusion/Expr.mbi:1306:16-30
    return (mosek_fusion_ExprMulParamScalar._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
   elif (_1._getND_()==0): # src/fusion/Expr.mbi:1308:16-33
    return (mosek_fusion_ExprMulParamScalarExpr._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_1._numNonzeros_()
   if (not _1._isSparse_()): # src/fusion/Expr.mbi:1286:12-28
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([_3 for _3 in range(0,_2)], dtype=numpy.dtype(numpy.int64)),_1._getDataAsArray_()))
   else:
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
    _7=_1._numColumns_()
    _1._getDataAsTriplets__3I_3I_3D(_4,_5,_6)
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([((_4[_8] * _7) + _5[_8]) for _8 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int64)),_6))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([_2 for _2 in range(0,(int((_1).shape[0]) * int((_1).shape[1])))], dtype=numpy.dtype(numpy.int64)),numpy.array([_1[_3,_4] for _3 in range(0,int((_1).shape[0])) for _4 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,(_1._inst),(_1._cof)))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=_0._getShape_()
   if ((_0._getSize_()==int((_1).shape[0])) and (int((_2).shape[0]) > 1)): # src/fusion/Expr.mbi:1268:12-54
    _3=0
    _3 = fragments._c_closure_578(_2,_3) # src/fusion/Expr.mbi:1269:29-89
    _3 = numpy.int32(_3) # postprocess
    if (_3 > 1): # src/fusion/Expr.mbi:1270:14-27
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
    else:
     _4=numpy.array([numpy.int32(_0._getSize_())], dtype=numpy.dtype(numpy.int32))
     return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3D(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_4,_0),_1))
   else:
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3D(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_1,_0))
  @staticmethod
  def _match_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _dot__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_1,_0))
  @staticmethod
  def _match_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2_3D(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek_fusion_ExprDotParam._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprDotParam._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   _2=_1._getShape_()
   if (not ((int((_2).shape[0])==1) or ((int((_2).shape[0])==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1237:13-1238:59
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   if ((_0._dimj)!=1): # src/fusion/Expr.mbi:1240:12-23
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   _4=_0
   if   isinstance(_4,mosek_fusion_DenseMatrix):
    m=_4
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_2[0],(m._data),None,int(((m._data)).shape[0]),True))
   else:
    mx=_4
    _4=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    mx._getDataAsTriplets__3I_3I_3D(_6,_5,_4)
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_2[0],_4,_6,(mx._dimi),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_0._getShape_()
   if (not ((_0._getND_()==1) or ((_0._getND_()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1213:13-1214:56
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   if ((_1._dimj)!=1): # src/fusion/Expr.mbi:1216:12-23
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   _4=_1
   if   isinstance(_4,mosek_fusion_DenseMatrix):
    m=_4
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_2[0],(m._data),None,int(((m._data)).shape[0]),False))
   else:
    mx=_4
    _4=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((mx._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    mx._getDataAsTriplets__3I_3I_3D(_6,_5,_4)
    return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_0._getShape_()[0],_4,_6,(mx._dimi),False))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer__3DLmosek_4fusion_4Variable_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=_1._getShape_()
   if (not ((_1._getND_()==1) or ((_1._getND_()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1203:13-1204:57
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_1,_2[0],_0,None,int((_0).shape[0]),True))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Variable_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Variable_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._outer_Lmosek_4fusion_4Variable_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer_Lmosek_4fusion_4Variable_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _2=_0._getShape_()
   if (not ((_0._getND_()==1) or ((_0._getND_()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1193:13-1194:56
    raise mosek_fusion_DimensionError._ctor_S("Variable argument must be one-dimensional")
   return (mosek.fusion.Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_2[0],_1,None,int((_1).shape[0]),False))
  @staticmethod
  def __outer_1_alt_I_3J_3J_3D_3D_3J_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _8=numpy.int32(_t__8)
   _9=_t__9
   _1 = mosek_fusion_Expr.__outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   assert _6 is None or isinstance(_6,numpy.ndarray)
   assert _7 is None or isinstance(_7,numpy.ndarray)
   _10=(mosek.fusion.Set._make_II(_0,_8) if ((not _9) ) else mosek.fusion.Set._make_II(_8,_0))
   _11=(int((_6).shape[0]) * int((_5).shape[0]))
   _12=(int((_6).shape[0]) * int((_2).shape[0]))
   _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
   _14=(numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64)) if ((_4 is not None) ) else None)
   _15=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
   _16=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros(((_11 + 1),), dtype=numpy.dtype(numpy.int64))
   _18=numpy.int32(_17[(int((_17).shape[0]) - 1)])
   if (not _9): # src/fusion/Expr.mbi:1118:12-25
    fragments._c_closure_579(_6,_14,_15,_8,_4,_3,_5,_1,_2,_17,_7,_16) # src/fusion/Expr.mbi:1119:8-1151:9
   else:
    _19=0
    _20=0
    for _21 in range(0,int((_6).shape[0])):
     _22=_6[_21]
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_2,0,_16,_20,_18)
     fragments._c_closure_580(_6,_15,_3,_18,_21,_20) # src/fusion/Expr.mbi:1160:12-62
     _19 = fragments._c_closure_581(_8,_5,_1,_21,_19,_17,_7) # src/fusion/Expr.mbi:1162:12-1169:13
     _19 = numpy.int64(_19) # postprocess
     _20 += _18
    fragments._c_closure_582(_6,_14,_4,_5) # src/fusion/Expr.mbi:1173:10-1184:11
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3J(_17,_16,_15,_14,_10,_13))
  @staticmethod
  def __outer_1_alt_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.int32(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _6=(mosek.fusion.Set._make_II(_1,_4) if ((not _5) ) else mosek.fusion.Set._make_II(_4,_1))
   _7=(None if ((_4==int((_2).shape[0])) ) else numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64)))
   _8=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.float64))
   _9=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.float64))
   _10=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64))
   _11=numpy.zeros((((int((_2).shape[0]) * _1) + 1),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_583(_2,_9,_4,_7,_11,_3,_10,_5,_1) # src/fusion/Expr.mbi:1024:8-1077:9
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3J(_11,_10,_9,_8,_6,_7))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Expression_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:996:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    _2=_0[_1]
    if (_2 is None): # src/fusion/Expr.mbi:1000:14-24
     raise ValueError("Arguments for stack may not be null")
    for _3 in range(0,int((_2).shape[0])):
     if (_2[_3] is None): # src/fusion/Expr.mbi:1002:16-29
      raise ValueError("Arguments for stack may not be null")
   _4=numpy.array([mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0[_5],1) for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_4,0))
  @staticmethod
  def _match_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DDD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDD(numpy.float64(__0),numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_DDD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _vstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:961:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None): # src/fusion/Expr.mbi:963:14-30
     raise ValueError("Arguments for vstack may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   if ((_0 is None) or ((_1 is None) or (_2 is None))): # src/fusion/Expr.mbi:950:99-137
    raise ValueError("Arguments e1, e2 and e3 may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _hstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:902:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None): # src/fusion/Expr.mbi:904:14-30
     raise ValueError("Arguments for hstack may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,1))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(numpy.int32(__0),_1,numpy.float64(__2),numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DD(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(numpy.int32(__0),numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),numpy.float64(__2),_3)
  @staticmethod
  def _stack_IDDLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,numpy.float64(__2))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Expression_2(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_1,_0))
  @staticmethod
  def __stack_1_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (int((_0).shape[0])==1): # src/fusion/Expr.mbi:878:12-27
    return (_0[0])
   else:
    return (mosek_fusion_ExprStack._ctor__3Lmosek_4fusion_4Expression_2I(mosek.fusion.Expr.__promote__3Lmosek_4fusion_4Expression_2I(_0,_1),_1))
  @staticmethod
  def __promote_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Expr.__promote__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __promote__3Lmosek_4fusion_4Expression_2I(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=int((_0).shape[0])
   _3=numpy.array([_0[_4]._getND_() for _4 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _5=_3[0]
   _6=_3[0]
   _5,_6 = fragments._c_closure_584(_5,_6,_2,_3) # src/fusion/Expr.mbi:849:8-852:9
   _5 = numpy.int32(_5) # postprocess
   _6 = numpy.int32(_6) # postprocess
   if (_5 < _1): # src/fusion/Expr.mbi:854:12-23
    _5 = _1
   if (_6 < _5): # src/fusion/Expr.mbi:855:12-25
    _7=numpy.ndarray((_2,), dtype=numpy.dtype(object))
    _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
    for _9 in range(0,_2):
     if (_0[_9]._getND_()==_5): # src/fusion/Expr.mbi:860:16-41
      _7[_9] = _0[_9]
     else:
      _10=_0[_9]._getShape_()
      fragments._c_closure_585(_10,_8) # src/fusion/Expr.mbi:864:14-54
      fragments._c_closure_586(_5,_10,_8) # src/fusion/Expr.mbi:865:14-55
      _7[_9] = mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_8,_0[_9])
    return (_7)
   else:
    return (_0)
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Expr._repeat_Lmosek_4fusion_4Expression_2II(_0._asExpr_(),_1,_2))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_1 <= 0): # src/fusion/Expr.mbi:823:12-18
    raise mosek_fusion_DimensionError._ctor_S("Cannot repeat Expression 0 or less times")
   if ((_2 < 0) or (_2 > _0._getND_())): # src/fusion/Expr.mbi:826:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
   else:
    if (_2==_0._getND_()): # src/fusion/Expr.mbi:828:17-31
     _3=numpy.zeros(((_2 + 1),), dtype=numpy.dtype(numpy.int32))
     for _4 in range(0,_2):
      _3[_4] = _0._getDim_I(_4)
     _3[_2] = 1
     return (mosek_fusion_ExprRepeat._ctor_Lmosek_4fusion_4Expression_2II(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,_3),_2,_1))
    else:
     return (mosek_fusion_ExprRepeat._ctor_Lmosek_4fusion_4Expression_2II(_0,_2,_1))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Expression_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_ExprWSum._ctor__3Lmosek_4fusion_4Expression_2_3D(_0,numpy.array([1.0 for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   if (_0 is None): # src/fusion/Expr.mbi:748:12-22
    raise ValueError("Argument vs may not be null")
   if (int((_0).shape[0])==0): # src/fusion/Expr.mbi:749:12-24
    return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   if ((int((_0).shape[0]) > 0) and (_0[0] is None)): # src/fusion/Expr.mbi:752:12-41
    raise ValueError("Argument vs may contain null")
   _1=_0[0]._getND_()
   for _2 in range(1,int((_0).shape[0])):
    if (_1 < _0[_2]._getND_()): # src/fusion/Expr.mbi:753:61-79
     _1 = _0[_2]._getND_()
   _3=numpy.zeros((int((_0).shape[0]),_1,), dtype=numpy.dtype(numpy.int32))
   for _4 in range(0,int((_0).shape[0])):
    _5=_0[_4]._getShape_()
    fragments._c_closure_587(_4,_3,_5) # src/fusion/Expr.mbi:757:10-57
    fragments._c_closure_588(_4,_1,_3,_5) # src/fusion/Expr.mbi:758:10-53
   for _6 in range(1,int((_0).shape[0])):
    for _7 in range(0,_1):
     if (_3[0,_7]!=_3[_6,_7]): # src/fusion/Expr.mbi:763:16-42
      raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _8=numpy.array([_3[0,_9] for _9 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _10=1
   _10 = fragments._c_closure_589(_1,_8,_10) # src/fusion/Expr.mbi:766:20-55
   _10 = numpy.int32(_10) # postprocess
   _11=0
   _12=0
   for _13 in range(0,int((_0).shape[0])):
    _14=_0[_13]._numInst_()
    _11 += _14
    _12 = (_12 if ((_12 > _14) ) else _14)
   _15=numpy.zeros(((_10 + 1),), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
   _17=numpy.array([1.0 for _18 in range(0,_11)], dtype=numpy.dtype(numpy.float64))
   _19=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _20=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   for _21 in range(0,int((_0).shape[0])):
    _22=_0[_21]._inst_I_3JI_3J(0,_19,0,_20)
    fragments._c_closure_590(_19,_22,_15) # src/fusion/Expr.mbi:784:12-785:33
   fragments._c_closure_591(_15,_10) # src/fusion/Expr.mbi:787:10-51
   for _23 in range(0,int((_0).shape[0])):
    _24=_0[_23]._inst_I_3JI_3J(0,_19,0,_20)
    fragments._c_closure_592(_20,_19,_24,_15,_16) # src/fusion/Expr.mbi:790:12-793:13
   fragments._c_closure_593(_15,_10) # src/fusion/Expr.mbi:795:10-56
   _15[0] = 0
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3JI(_15,_16,_17,numpy.array([0.0 for _25 in range(0,_10)], dtype=numpy.dtype(numpy.float64)),_8,None,1))
  @staticmethod
  def __add_1_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def __add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   _4=_0._getND_()
   _5=_2._getND_()
   if (_4==_5): # src/fusion/Expr.mbi:708:12-22
    return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(_0,_2,_1,_3))
   else:
    _6=(_4 if ((_4 > _5) ) else _5)
    _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
    if (_4 < _5): # src/fusion/Expr.mbi:713:14-23
     _8=_0._getShape_()
     fragments._c_closure_594(_4,_8,_7) # src/fusion/Expr.mbi:715:12-50
     fragments._c_closure_595(_6,_4,_7) # src/fusion/Expr.mbi:716:12-47
     return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_7,_0),_2,_1,_3))
    else:
     _9=_2._getShape_()
     fragments._c_closure_596(_5,_9,_7) # src/fusion/Expr.mbi:722:12-50
     fragments._c_closure_597(_6,_5,_7) # src/fusion/Expr.mbi:723:12-47
     return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(_0,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_7,_2),_1,_3))
  @staticmethod
  def _match_transpose_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_transpose_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _transpose_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._transpose_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _transpose_Lmosek_4fusion_4Expression_2(_0):
   if (_0._getND_()==0): # src/fusion/Expr.mbi:691:16-30
    return (_0)
   elif (_0._getND_()==1): # src/fusion/Expr.mbi:693:16-30
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),_0))
   elif (_0._getND_()==2): # src/fusion/Expr.mbi:695:16-30
    return (mosek_fusion_ExprTranspose._ctor_Lmosek_4fusion_4Expression_2(_0))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Incorrect number of dimensions for transpose")
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprMulParamElem._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek_fusion_ExprMulParamElem._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _sub_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3ID(_1._getShape_(),_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3ID(_0._getShape_(),_1),(- 1.0)))
  @staticmethod
  def _match_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _sub__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,(- 1.0)))
  @staticmethod
  def _match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),1.0))
  @staticmethod
  def _match_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _add_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3ID(_1._getShape_(),_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3ID(_0._getShape_(),_1),1.0))
  @staticmethod
  def _match_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _add__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3_5D(_0),1.0))
  @staticmethod
  def _match_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3DLmosek_4fusion_4Expression_2(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3D(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,1.0))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=(int((self.__ptrb).shape[0]) - 1)
   _4=(numpy.int32(self.__ptrb[_3]) + _3)
   _5=int((self.__shape).shape[0])
   _0._alloc_1expr_IIIZ(_5,_3,_4,(self.__inst is not None))
   _6=(_0.ptr_base)
   _7=(_0.nidxs_base)
   _8=(_0.sp_base)
   _9=(_0.cof_base)
   _10=(_0.shape_base)
   _11=(_0.i32)
   _12=(_0.i64)
   _13=(_0.f64)
   fragments._c_closure_598(self.__bfix,_9,self.__cof_v,_13,_11,_12,_5,_3,_7,_6,self.__ptrb,self.__shape,_10,self.__subj) # src/fusion/Expr.mbi:627:8-642:9
  @staticmethod
  def __validateData_alt__3J_3J_3D_3D_3I_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Expr.__validateData__3J_3J_3D_3D_3I_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validateData__3J_3J_3D_3D_3I_3J(_0,_1,_2,_3,_4,_5):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   assert _5 is None or isinstance(_5,numpy.ndarray)
   if (_4 is None): # src/fusion/Expr.mbi:442:16-29
    raise mosek_fusion_ExpressionError._ctor_S("Array 'shape' in expression is null")
   _6=(int((_0).shape[0]) - 1)
   _7=_0[(int((_0).shape[0]) - 1)]
   _8=int((_4).shape[0])
   _9=1
   _9 = fragments._c_closure_599(_8,_4,_9) # src/fusion/Expr.mbi:447:23-60
   _9 = numpy.int64(_9) # postprocess
   if (int((_0).shape[0]) < 1): # src/fusion/Expr.mbi:448:16-29
    raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong size")
   if (_7!=int((_1).shape[0])): # src/fusion/Expr.mbi:450:17-36
    raise mosek_fusion_ExpressionError._ctor_S("Array 'subj' in expression has wrong size")
   if (_7!=int((_2).shape[0])): # src/fusion/Expr.mbi:452:17-35
    raise mosek_fusion_ExpressionError._ctor_S("Array 'cof' in expression has wrong size")
   if ((_3 is None) or (_6!=int((_3).shape[0]))): # src/fusion/Expr.mbi:454:17-54
    raise mosek_fusion_ExpressionError._ctor_S("Array 'bfix' in expression has wrong length")
   if ((_5 is not None) and (int((_5).shape[0]) < _9)): # src/fusion/Expr.mbi:457:12-45
    if (int((_5).shape[0])!=(int((_0).shape[0]) - 1)): # src/fusion/Expr.mbi:459:14-38
     raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' in expression has wrong length")
    if (int((_5).shape[0]) > 0): # src/fusion/Expr.mbi:462:14-27
     if ((_5[0] < 0) or (_5[0] >= _9)): # src/fusion/Expr.mbi:464:16-46
      raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' contains an invalid index")
     _10=True
     _11=_9
     _10 = fragments._c_closure_600(_5,_10,_11) # src/fusion/Expr.mbi:470:12-476:13
     if (not _10): # src/fusion/Expr.mbi:477:16-35
      raise mosek_fusion_ExpressionError._ctor_S("Invalid array 'inst'")
   else:
    if (_9!=(int((_0).shape[0]) - 1)): # src/fusion/Expr.mbi:482:14-37
     raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong length")
   _12=False
   _13=False
   if (_0[0]!=0): # src/fusion/Expr.mbi:488:12-25
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
   _14=True
   _14 = fragments._c_closure_601(_6,_0,_14) # src/fusion/Expr.mbi:492:8-493:61
   if (not _14): # src/fusion/Expr.mbi:494:12-27
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
  @staticmethod
  def __extractModel_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__extractModel__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __extractModel__3Lmosek_4fusion_4Variable_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return ((None if (((_0 is None) or (int((_0).shape[0])==0)) ) else _0[0]._getModel_()))
 return Expr
mosek_fusion_Expr=__mk_mosek_fusion_Expr()
del __mk_mosek_fusion_Expr
#BEFORE CLASS
def __mk_mosek_fusion_WorkStack():
 class WorkStack(object):
  __slots__ = ['code_base','cconst_base','codeptr_base','cof_base','nidxs_base','sp_base','shape_base','ptr_base','hassp','ncodeatom','nelem','nnz','nd','pf64','pi64','pi32','f64','i64','i32']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.WorkStack.ctor()')
  def alloci64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloci64_I(*args): # int32
      return self._alloci64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_alloci64_I(*args): # int32
      return self._alloci64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloci64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloci64(int32)')
  def popi64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popi64_(*args): # 
      return self._popi64_(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_(*args): # 
      return self._popi64_alt_(*args)
    elif mosek_fusion_WorkStack._match_popi64_I(*args): # int32
      return self._popi64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_I(*args): # int32
      return self._popi64_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popi64_I_3JI(*args): # int32,[]int64,int32
      return self._popi64_I_3JI(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_I_3JI(*args): # int32,[]int64,int32
      return self._popi64_alt_I_3JI(*args)
    else:
      raise ValueError('Invalid argument list popi64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popi64()\n\tmosek.fusion.WorkStack.popi64(int32)\n\tmosek.fusion.WorkStack.popi64(int32,array(int64,ndim=1),int32)')
  def alloci32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloci32_I(*args): # int32
      return self._alloci32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_alloci32_I(*args): # int32
      return self._alloci32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloci32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloci32(int32)')
  def peek_hassp(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1hassp_(*args): # 
      return self._peek_1hassp_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1hassp_(*args): # 
      return self._peek_1hassp_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_hassp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_hassp()')
  def popf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popf64_(*args): # 
      return self._popf64_(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_(*args): # 
      return self._popf64_alt_(*args)
    elif mosek_fusion_WorkStack._match_popf64_I(*args): # int32
      return self._popf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_I(*args): # int32
      return self._popf64_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popf64_I_3DI(*args): # int32,[]double,int32
      return self._popf64_I_3DI(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_I_3DI(*args): # int32,[]double,int32
      return self._popf64_alt_I_3DI(*args)
    else:
      raise ValueError('Invalid argument list popf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popf64()\n\tmosek.fusion.WorkStack.popf64(int32)\n\tmosek.fusion.WorkStack.popf64(int32,array(double,ndim=1),int32)')
  def ensurei32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensurei32_I(*args): # int32
      return self._ensurei32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensurei32_I(*args): # int32
      return self._ensurei32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensurei32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensurei32(int32)')
  def allocf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_allocf64_I(*args): # int32
      return self._allocf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_allocf64_I(*args): # int32
      return self._allocf64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list allocf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.allocf64(int32)')
  def peek_nelem(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nelem_(*args): # 
      return self._peek_1nelem_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nelem_(*args): # 
      return self._peek_1nelem_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nelem('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nelem()')
  def formatCurrent(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_formatCurrent_(*args): # 
      return self._formatCurrent_(*args)
    elif mosek_fusion_WorkStack._match_alt_formatCurrent_(*args): # 
      return self._formatCurrent_alt_(*args)
    else:
      raise ValueError('Invalid argument list formatCurrent('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.formatCurrent()')
  def peeki32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peeki32_(*args): # 
      return self._peeki32_(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki32_(*args): # 
      return self._peeki32_alt_(*args)
    elif mosek_fusion_WorkStack._match_peeki32_I(*args): # int32
      return self._peeki32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki32_I(*args): # int32
      return self._peeki32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peeki32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peeki32()\n\tmosek.fusion.WorkStack.peeki32(int32)')
  def ensure_sparsity(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensure_1sparsity_(*args): # 
      return self._ensure_1sparsity_(*args)
    elif mosek_fusion_WorkStack._match_alt_ensure_1sparsity_(*args): # 
      return self._ensure_1sparsity_alt_(*args)
    else:
      raise ValueError('Invalid argument list ensure_sparsity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensure_sparsity()')
  def peek_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1expr_(*args): # 
      return self._peek_1expr_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1expr_(*args): # 
      return self._peek_1expr_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_expr()')
  def peeki64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peeki64_(*args): # 
      return self._peeki64_(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki64_(*args): # 
      return self._peeki64_alt_(*args)
    elif mosek_fusion_WorkStack._match_peeki64_I(*args): # int32
      return self._peeki64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki64_I(*args): # int32
      return self._peeki64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peeki64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peeki64()\n\tmosek.fusion.WorkStack.peeki64(int32)')
  def pushi64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushi64_J(*args): # int64
      return self._pushi64_J(*args)
    elif mosek_fusion_WorkStack._match_alt_pushi64_J(*args): # int64
      return self._pushi64_alt_J(*args)
    else:
      raise ValueError('Invalid argument list pushi64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushi64(int64)')
  def peekf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peekf64_(*args): # 
      return self._peekf64_(*args)
    elif mosek_fusion_WorkStack._match_alt_peekf64_(*args): # 
      return self._peekf64_alt_(*args)
    elif mosek_fusion_WorkStack._match_peekf64_I(*args): # int32
      return self._peekf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peekf64_I(*args): # int32
      return self._peekf64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peekf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peekf64()\n\tmosek.fusion.WorkStack.peekf64(int32)')
  def peek_nd(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nd_(*args): # 
      return self._peek_1nd_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nd_(*args): # 
      return self._peek_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nd()')
  def pop_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pop_1expr_(*args): # 
      return self._pop_1expr_(*args)
    elif mosek_fusion_WorkStack._match_alt_pop_1expr_(*args): # 
      return self._pop_1expr_alt_(*args)
    else:
      raise ValueError('Invalid argument list pop_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pop_expr()')
  def peek_dim(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1dim_I(*args): # int32
      return self._peek_1dim_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1dim_I(*args): # int32
      return self._peek_1dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peek_dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_dim(int32)')
  def ensuref64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensuref64_I(*args): # int32
      return self._ensuref64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensuref64_I(*args): # int32
      return self._ensuref64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensuref64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensuref64(int32)')
  def alloc_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloc_1expr_IIIZ(*args): # int32,int32,int32,bool
      return self._alloc_1expr_IIIZ(*args)
    elif mosek_fusion_WorkStack._match_alt_alloc_1expr_IIIZ(*args): # int32,int32,int32,bool
      return self._alloc_1expr_alt_IIIZ(*args)
    elif mosek_fusion_WorkStack._match_alloc_1expr_IIIZI(*args): # int32,int32,int32,bool,int32
      return self._alloc_1expr_IIIZI(*args)
    elif mosek_fusion_WorkStack._match_alt_alloc_1expr_IIIZI(*args): # int32,int32,int32,bool,int32
      return self._alloc_1expr_alt_IIIZI(*args)
    else:
      raise ValueError('Invalid argument list alloc_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool)\n\tmosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool,int32)')
  def clear(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_clear_(*args): # 
      return self._clear_(*args)
    elif mosek_fusion_WorkStack._match_alt_clear_(*args): # 
      return self._clear_alt_(*args)
    else:
      raise ValueError('Invalid argument list clear('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.clear()')
  def peek_nnz(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nnz_(*args): # 
      return self._peek_1nnz_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nnz_(*args): # 
      return self._peek_1nnz_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nnz('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nnz()')
  def move_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_move_1expr_Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack
      return self._move_1expr_Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_WorkStack._match_alt_move_1expr_Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack
      return self._move_1expr_alt_Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list move_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.move_expr(mosek.fusion.WorkStack)')
  def pushf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushf64_D(*args): # double
      return self._pushf64_D(*args)
    elif mosek_fusion_WorkStack._match_alt_pushf64_D(*args): # double
      return self._pushf64_alt_D(*args)
    else:
      raise ValueError('Invalid argument list pushf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushf64(double)')
  def popi32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popi32_(*args): # 
      return self._popi32_(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_(*args): # 
      return self._popi32_alt_(*args)
    elif mosek_fusion_WorkStack._match_popi32_I(*args): # int32
      return self._popi32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_I(*args): # int32
      return self._popi32_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popi32_I_3II(*args): # int32,[]int32,int32
      return self._popi32_I_3II(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_I_3II(*args): # int32,[]int32,int32
      return self._popi32_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list popi32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popi32()\n\tmosek.fusion.WorkStack.popi32(int32)\n\tmosek.fusion.WorkStack.popi32(int32,array(int32,ndim=1),int32)')
  def pushi32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushi32_I(*args): # int32
      return self._pushi32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_pushi32_I(*args): # int32
      return self._pushi32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list pushi32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushi32(int32)')
  def ensurei64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensurei64_I(*args): # int32
      return self._ensurei64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensurei64_I(*args): # int32
      return self._ensurei64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensurei64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensurei64(int32)')
  def __repr__(self): return 'mosek.fusion.WorkStack'
  @staticmethod
  def _ctor_():
    o = WorkStack.__new__(WorkStack)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   self.i32 = numpy.zeros((256,), dtype=numpy.dtype(numpy.int32))
   self.i64 = numpy.zeros((256,), dtype=numpy.dtype(numpy.int64))
   self.f64 = numpy.zeros((256,), dtype=numpy.dtype(numpy.float64))
   self.pi32 = 0
   self.pi64 = 0
   self.pf64 = 0
   self.nd = 0
   self.nnz = 0
   self.nelem = 0
   self.hassp = False
   self.ncodeatom = 0
   self.ptr_base = 0
   self.shape_base = 0
   self.sp_base = 0
   self.nidxs_base = 0
   self.cof_base = 0
   self.cconst_base = 0
   self.code_base = 0
   self.codeptr_base = 0
  @staticmethod
  def _match_formatCurrent_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_formatCurrent_(*args):
    if len(args) != 0: return False
    return True
  def _formatCurrent_alt_(self,):
    return self._formatCurrent_()
  def _formatCurrent_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("  nelem     = ")._a_I(self.nelem)._a_S("\n")._a_S("  nnz       = ")._a_I(self.nnz)._a_S("\n")._a_S("  hassp     = ")._a_Z(self.hassp)._a_S(" / ")._a_Z(self.hassp)._a_S("\n")._a_S("  shape     = ")._a__3I(numpy.array([self.i32[(self.shape_base + _1)] for _1 in range(0,self.nd)], dtype=numpy.dtype(numpy.int32)))._a_S("\n")._a_S("  ptr       = ")._a__3I(numpy.array([self.i32[(self.ptr_base + _2)] for _2 in range(0,(self.nelem + 1))], dtype=numpy.dtype(numpy.int32)))._a_S("\n")
   if (self.ncodeatom > 0): # src/fusion/BaseExpression.monty:374:12-25
    _0._a_S("  codeptr   = ")._a__3I(numpy.array([self.i32[(self.codeptr_base + _3)] for _3 in range(0,(self.nnz + 1))], dtype=numpy.dtype(numpy.int32)))._a_S("\n")
   if self.hassp: # src/fusion/BaseExpression.monty:376:12-17
    _0._a_S("  sp        = ")._a__3J(numpy.array([self.i64[(self.sp_base + _4)] for _4 in range(0,self.nelem)], dtype=numpy.dtype(numpy.int64)))._a_S("\n")
   for _5 in range(0,self.nelem):
    _0._a_S("  row[")._a_I(_5)._a_S("]")._a_S("\n")._a_S("    nidx : ")._a__3J(numpy.array([self.i64[(self.nidxs_base + _6)] for _6 in range(self.i32[(self.ptr_base + _5)],self.i32[((self.ptr_base + _5) + 1)])], dtype=numpy.dtype(numpy.int64)))._a_S("\n")._a_S("    cof  : ")._a__3D(numpy.array([self.f64[(self.cof_base + _7)] for _7 in range(self.i32[(self.ptr_base + _5)],self.i32[((self.ptr_base + _5) + 1)])], dtype=numpy.dtype(numpy.float64)))._a_S("\n")
    if (self.ncodeatom > 0): # src/fusion/BaseExpression.monty:383:14-27
     for _8 in range(self.i32[(self.ptr_base + _5)],self.i32[((self.ptr_base + _5) + 1)]):
      _0._a_S("      code[")._a_J(self.i64[(self.nidxs_base + _8)])._a_S("] ")._a__3I(numpy.array([self.i32[(self.code_base + _9)] for _9 in range(self.i32[(self.codeptr_base + _8)],self.i32[((self.codeptr_base + _8) + 1)])], dtype=numpy.dtype(numpy.int32)))._a__3D(numpy.array([self.f64[(self.cconst_base + _10)] for _10 in range(self.i32[(self.codeptr_base + _8)],self.i32[((self.codeptr_base + _8) + 1)])], dtype=numpy.dtype(numpy.float64)))._a_S("\n")
   return (_0._toString_())
  @staticmethod
  def _match_peek_1hassp_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1hassp_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1hassp_alt_(self,):
    return self._peek_1hassp_()
  def _peek_1hassp_(self,):
   return ((self._peeki32_I((3 + self._peek_1nd_()))!=0))
  @staticmethod
  def _match_peek_1nnz_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nnz_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nnz_alt_(self,):
    return self._peek_1nnz_()
  def _peek_1nnz_(self,):
   return numpy.int32(self._peeki32_I((2 + self._peek_1nd_())))
  @staticmethod
  def _match_peek_1nelem_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nelem_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nelem_alt_(self,):
    return self._peek_1nelem_()
  def _peek_1nelem_(self,):
   return numpy.int32(self._peeki32_I((1 + self._peek_1nd_())))
  @staticmethod
  def _match_peek_1dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peek_1dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peek_1dim_alt_I(self,_t__0):
    return self._peek_1dim_I(numpy.int32(__0))
  def _peek_1dim_I(self,_0):
   return numpy.int32(self._peeki32_I((_0 + 1)))
  @staticmethod
  def _match_peek_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nd_alt_(self,):
    return self._peek_1nd_()
  def _peek_1nd_(self,):
   return numpy.int32(self._peeki32_())
  @staticmethod
  def _match_alloc_1expr_IIIZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_alloc_1expr_IIIZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Z__(_3))
  def _alloc_1expr_alt_IIIZ(self,_t__0,_t__1,_t__2,_t__3):
    return self._alloc_1expr_IIIZ(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),_3)
  def _alloc_1expr_IIIZ(self,_0,_1,_2,_3):
   self._alloc_1expr_IIIZI(_0,_1,_2,_3,0)
  @staticmethod
  def _match_alloc_1expr_IIIZI(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Z__(_3) and __arg_match_I__(_4))
  @staticmethod
  def _match_alt_alloc_1expr_IIIZI(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Z__(_3) and __arg_alt_match_I__(_4))
  def _alloc_1expr_alt_IIIZI(self,_t__0,_t__1,_t__2,_t__3,_t__4):
    return self._alloc_1expr_IIIZI(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),_3,numpy.int32(__4))
  def _alloc_1expr_IIIZI(self,_0,_1,_2,_3,_4):
   self.cof_base = self._allocf64_I(_2)
   self.cconst_base = self._allocf64_I(_4)
   self.nidxs_base = self._alloci64_I(_2)
   self.sp_base = (self._alloci64_I(_1) if (_3 ) else (- 9999))
   self.code_base = self._alloci32_I(_4)
   self.codeptr_base = (self._alloci32_I((_2 + 1)) if ((_4 > 0) ) else (- 9999))
   self.ptr_base = self._alloci32_I((_1 + 1))
   self._pushi32_I(_4)
   self._pushi32_I((1 if (_3 ) else 0))
   self._pushi32_I(_2)
   self._pushi32_I(_1)
   self.shape_base = self._alloci32_I(_0)
   self._pushi32_I(_0)
   (self.ncodeatom) = _4
   (self.nd) = _0
   (self.nelem) = _1
   (self.nnz) = _2
   (self.hassp) = _3
  @staticmethod
  def _match_pop_1expr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_pop_1expr_(*args):
    if len(args) != 0: return False
    return True
  def _pop_1expr_alt_(self,):
    return self._pop_1expr_()
  def _pop_1expr_(self,):
   self.nd = self._popi32_()
   self.shape_base = self._popi32_I(self.nd)
   self.nelem = self._popi32_()
   self.nnz = self._popi32_()
   self.hassp = (self._popi32_()!=0)
   self.ncodeatom = self._popi32_()
   self.ptr_base = self._popi32_I((self.nelem + 1))
   self.codeptr_base = (self._popi32_I((self.nnz + 1)) if ((self.ncodeatom > 0) ) else (- 9999))
   self.code_base = self._popi32_I(self.ncodeatom)
   self.sp_base = (self._popi64_I(self.nelem) if (self.hassp ) else (- 9999))
   self.nidxs_base = self._popi64_I(self.nnz)
   self.cconst_base = self._popf64_I(self.ncodeatom)
   self.cof_base = self._popf64_I(self.nnz)
  @staticmethod
  def _match_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0))
  @staticmethod
  def _match_alt_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0))
  def _move_1expr_alt_Lmosek_4fusion_4WorkStack_2(self,_t__0):
    return self._move_1expr_Lmosek_4fusion_4WorkStack_2(_0)
  def _move_1expr_Lmosek_4fusion_4WorkStack_2(self,_0):
   _1=self.pi32
   _2=self.pi64
   _3=self.pf64
   self._pop_1expr_()
   _4=_0._alloci32_I((_1 - self.pi32))
   _5=_0._alloci64_I((_2 - self.pi64))
   _6=_0._allocf64_I((_3 - self.pf64))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,self.pi32,(_0.i32),_4,(_1 - self.pi32))
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,self.pi64,(_0.i64),_5,(_2 - self.pi64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,self.pf64,(_0.f64),_6,(_3 - self.pf64))
  @staticmethod
  def _match_peek_1expr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1expr_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1expr_alt_(self,):
    return self._peek_1expr_()
  def _peek_1expr_(self,):
   _0=self.pi32
   _1=self.pi64
   _2=self.pf64
   self._pop_1expr_()
   self.pi32 = _0
   self.pi64 = _1
   self.pf64 = _2
  @staticmethod
  def _match_ensure_1sparsity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_ensure_1sparsity_(*args):
    if len(args) != 0: return False
    return True
  def _ensure_1sparsity_alt_(self,):
    return self._ensure_1sparsity_()
  def _ensure_1sparsity_(self,):
   _0=self.i32[(self.pi32 - 1)]
   _1=(self.i32[((self.pi32 - _0) - 3)]!=0)
   _2=self.i32[((self.pi32 - _0) - 1)]
   if (not _1): # src/fusion/BaseExpression.monty:262:12-21
    self.i32[((self.pi32 - _0) - 3)] = 1
    _3=self._alloci64_I(_2)
    fragments._c_closure_602(self.i64,_2,_3) # src/fusion/BaseExpression.monty:265:10-266:24
  @staticmethod
  def _match_clear_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clear_(*args):
    if len(args) != 0: return False
    return True
  def _clear_alt_(self,):
    return self._clear_()
  def _clear_(self,):
   self.pi32 = 0
   self.pi64 = 0
   self.pf64 = 0
  @staticmethod
  def _match_allocf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_allocf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _allocf64_alt_I(self,_t__0):
    return self._allocf64_I(numpy.int32(__0))
  def _allocf64_I(self,_0):
   self._ensuref64_I(_0)
   _1=self.pf64
   self.pf64 += _0
   return numpy.int32(_1)
  @staticmethod
  def _match_alloci64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloci64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloci64_alt_I(self,_t__0):
    return self._alloci64_I(numpy.int32(__0))
  def _alloci64_I(self,_0):
   self._ensurei64_I(_0)
   _1=self.pi64
   self.pi64 += _0
   return numpy.int32(_1)
  @staticmethod
  def _match_alloci32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloci32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloci32_alt_I(self,_t__0):
    return self._alloci32_I(numpy.int32(__0))
  def _alloci32_I(self,_0):
   if (_0 > 0): # src/fusion/BaseExpression.monty:178:12-17
    self._ensurei32_I(_0)
    _1=self.pi32
    self.pi32 += _0
    return numpy.int32(_1)
   else:
    return numpy.int32(0)
  @staticmethod
  def _match_pushf64_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_pushf64_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _pushf64_alt_D(self,_t__0):
    return self._pushf64_D(numpy.float64(__0))
  def _pushf64_D(self,_0):
   self._ensuref64_I(1)
   self.f64[self.pf64] = _0
   self.pf64 += 1
  @staticmethod
  def _match_pushi64_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_pushi64_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _pushi64_alt_J(self,_t__0):
    return self._pushi64_J(numpy.int64(__0))
  def _pushi64_J(self,_0):
   self._ensurei64_I(1)
   self.i64[self.pi64] = _0
   self.pi64 += 1
  @staticmethod
  def _match_pushi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_pushi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _pushi32_alt_I(self,_t__0):
    return self._pushi32_I(numpy.int32(__0))
  def _pushi32_I(self,_0):
   self._ensurei32_I(1)
   self.i32[self.pi32] = _0
   self.pi32 += 1
  @staticmethod
  def _match_ensuref64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensuref64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensuref64_alt_I(self,_t__0):
    return self._ensuref64_I(numpy.int32(__0))
  def _ensuref64_I(self,_0):
   if ((self.pf64 + _0) > int((self.f64).shape[0])): # src/fusion/BaseExpression.monty:142:12-29
    _1=((int((self.f64).shape[0]) * 2) if (((_0 < int((self.f64).shape[0])) and (int((self.f64).shape[0]) < 1073741823)) ) else (int((self.f64).shape[0]) + _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,0,_2,0,self.pf64)
    self.f64 = _2
  @staticmethod
  def _match_ensurei64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensurei64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensurei64_alt_I(self,_t__0):
    return self._ensurei64_I(numpy.int32(__0))
  def _ensurei64_I(self,_0):
   if ((self.pi64 + _0) > int((self.i64).shape[0])): # src/fusion/BaseExpression.monty:132:12-29
    _1=(int((self.i64).shape[0]) + (int((self.i64).shape[0]) if (((_0 < int((self.i64).shape[0])) and (int((self.i64).shape[0]) < 1073741823)) ) else _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,0,_2,0,self.pi64)
    self.i64 = _2
  @staticmethod
  def _match_ensurei32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensurei32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensurei32_alt_I(self,_t__0):
    return self._ensurei32_I(numpy.int32(__0))
  def _ensurei32_I(self,_0):
   if ((self.pi32 + _0) > int((self.i32).shape[0])): # src/fusion/BaseExpression.monty:122:12-29
    _1=((int((self.i32).shape[0]) * 2) if (((_0 < int((self.i32).shape[0])) and (int((self.i32).shape[0]) < 1073741823)) ) else (int((self.i32).shape[0]) + _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,0,_2,0,self.pi32)
    self.i32 = _2
  @staticmethod
  def _match_popf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popf64_alt_I(self,_t__0):
    return self._popf64_I(numpy.int32(__0))
  def _popf64_I(self,_0):
   self.pf64 -= _0
   if (self.pf64 < 0): # src/fusion/BaseExpression.monty:114:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pf64)
  @staticmethod
  def _match_popi64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popi64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popi64_alt_I(self,_t__0):
    return self._popi64_I(numpy.int32(__0))
  def _popi64_I(self,_0):
   self.pi64 -= _0
   if (self.pi64 < 0): # src/fusion/BaseExpression.monty:109:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pi64)
  @staticmethod
  def _match_popi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popi32_alt_I(self,_t__0):
    return self._popi32_I(numpy.int32(__0))
  def _popi32_I(self,_0):
   self.pi32 -= _0
   if (self.pi32 < 0): # src/fusion/BaseExpression.monty:104:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pi32)
  @staticmethod
  def _match_popf64_I_3DI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popf64_I_3DI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_I__(_2))
  def _popf64_alt_I_3DI(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int32(_t__2)
   _1 = self._popf64_I_3DI(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popf64_I_3DI(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.pf64 -= _0
   if (self.pf64 < 0): # src/fusion/BaseExpression.monty:99:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,self.pf64,_1,_2,_0)
  @staticmethod
  def _match_popi64_I_3JI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popi64_I_3JI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2))
  def _popi64_alt_I_3JI(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _1 = self._popi64_I_3JI(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popi64_I_3JI(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.pi64 -= _0
   if (self.pi64 < 0): # src/fusion/BaseExpression.monty:94:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,self.pi64,_1,_2,_0)
  @staticmethod
  def _match_popi32_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popi32_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _popi32_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._popi32_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popi32_I_3II(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.pi32 -= _0
   if (self.pi32 < 0): # src/fusion/BaseExpression.monty:89:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,self.pi32,_1,_2,_0)
  @staticmethod
  def _match_popf64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popf64_(*args):
    if len(args) != 0: return False
    return True
  def _popf64_alt_(self,):
    return self._popf64_()
  def _popf64_(self,):
   self.pf64 -= 1
   if (self.pf64 < 0): # src/fusion/BaseExpression.monty:84:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.float64(self.f64[self.pf64])
  @staticmethod
  def _match_popi64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popi64_(*args):
    if len(args) != 0: return False
    return True
  def _popi64_alt_(self,):
    return self._popi64_()
  def _popi64_(self,):
   if (self.pi64 < 0): # src/fusion/BaseExpression.monty:78:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   self.pi64 -= 1
   return numpy.int64(self.i64[self.pi64])
  @staticmethod
  def _match_popi32_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popi32_(*args):
    if len(args) != 0: return False
    return True
  def _popi32_alt_(self,):
    return self._popi32_()
  def _popi32_(self,):
   self.pi32 -= 1
   if (self.pi32 < 0): # src/fusion/BaseExpression.monty:74:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.i32[self.pi32])
  @staticmethod
  def _match_peekf64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peekf64_(*args):
    if len(args) != 0: return False
    return True
  def _peekf64_alt_(self,):
    return self._peekf64_()
  def _peekf64_(self,):
   return numpy.float64(self.f64[(self.pf64 - 1)])
  @staticmethod
  def _match_peeki64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peeki64_(*args):
    if len(args) != 0: return False
    return True
  def _peeki64_alt_(self,):
    return self._peeki64_()
  def _peeki64_(self,):
   return numpy.int64(self.i64[(self.pi64 - 1)])
  @staticmethod
  def _match_peeki32_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peeki32_(*args):
    if len(args) != 0: return False
    return True
  def _peeki32_alt_(self,):
    return self._peeki32_()
  def _peeki32_(self,):
   return numpy.int32(self.i32[(self.pi32 - 1)])
  @staticmethod
  def _match_peekf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peekf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peekf64_alt_I(self,_t__0):
    return self._peekf64_I(numpy.int32(__0))
  def _peekf64_I(self,_0):
   return numpy.float64(self.f64[((self.pf64 - _0) - 1)])
  @staticmethod
  def _match_peeki64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peeki64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peeki64_alt_I(self,_t__0):
    return self._peeki64_I(numpy.int32(__0))
  def _peeki64_I(self,_0):
   return numpy.int64(self.i64[((self.pi64 - _0) - 1)])
  @staticmethod
  def _match_peeki32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peeki32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peeki32_alt_I(self,_t__0):
    return self._peeki32_I(numpy.int32(__0))
  def _peeki32_I(self,_0):
   return numpy.int32(self.i32[((self.pi32 - _0) - 1)])
 return WorkStack
mosek_fusion_WorkStack=__mk_mosek_fusion_WorkStack()
del __mk_mosek_fusion_WorkStack
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricExpr():
 class SymmetricExpr(object):
  __slots__ = ['_SymmetricExpr__xs','_SymmetricExpr__b','_SymmetricExpr__Ms','_SymmetricExpr__n']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SymmetricExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricExpr.toString()')
  def __repr__(self): return 'mosek.fusion.SymmetricExpr'
  @staticmethod
  def _ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(n,Ms,xs,b):
    o = SymmetricExpr.__new__(SymmetricExpr)
    o._ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(n,Ms,xs,b)
    return o
  @staticmethod
  def __match_ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 4: return False
    n,Ms,xs,b, = args
    return (__arg_match_I__(n) and __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(Ms) and __arg_match__3Lmosek_4fusion_4Variable_2__(xs) and __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(b))
  @staticmethod
  def __match_alt_ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 4: return False
    n,Ms,xs,b, = args
    return (__arg_alt_match_I__(n) and __arg_alt_match__3Lmosek_4fusion_4SymmetricMatrix_2__(Ms) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(xs) and __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(b))
  def _ctor_alt_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(self,n,Ms,xs,b):
    self._ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(numpy.int32(n),numpy.array(Ms,dtype=numpy.dtype(object)),numpy.array(xs,dtype=numpy.dtype(object)),b)
  def _ctor_init_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2(self,n,Ms,xs,b):
   assert Ms is None or isinstance(Ms,numpy.ndarray)
   assert xs is None or isinstance(xs,numpy.ndarray)
   (self.__n) = n
   (self.__Ms) = Ms
   (self.__xs) = xs
   (self.__b) = b
  @staticmethod
  def _add_alt_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricMatrix_2(_0,_1):
   if ((_0.__n)!=_1._getdim_()): # src/fusion/SymExpr.monty:132:12-29
    raise mosek_fusion_DimensionError._ctor_S("Dimension does not match")
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),(_0.__Ms),(_0.__xs),((_0.__b)._add_Lmosek_4fusion_4SymmetricMatrix_2(_1) if (((_0.__b) is not None) ) else _1)))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4SymmetricExpr_2D(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._mul_Lmosek_4fusion_4SymmetricExpr_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4SymmetricExpr_2D(_0,_1):
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),numpy.array([(_0.__Ms)[_2]._mul_D(_1) for _2 in range(0,int(((_0.__Ms)).shape[0]))], dtype=numpy.dtype(object)),(_0.__xs),((_0.__b)._mul_D(_1) if (((_0.__b) is not None) ) else None)))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_t__0,_t__1):
    return mosek_fusion_SymmetricExpr._add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4SymmetricExpr_2Lmosek_4fusion_4SymmetricExpr_2(_0,_1):
   if ((_0.__n)!=(_1.__n)): # src/fusion/SymExpr.monty:101:12-26
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
   _2=numpy.ndarray(((int(((_0.__Ms)).shape[0]) + int(((_1.__Ms)).shape[0])),), dtype=numpy.dtype(object))
   _3=numpy.ndarray(((int(((_0.__xs)).shape[0]) + int(((_1.__xs)).shape[0])),), dtype=numpy.dtype(object))
   _4=int(((_0.__Ms)).shape[0])
   for _5 in range(0,int(((_0.__Ms)).shape[0])):
    _2[_5] = (_0.__Ms)[_5]
   for _6 in range(0,int(((_1.__Ms)).shape[0])):
    _2[(_6 + _4)] = (_1.__Ms)[_6]
   _7=int(((_0.__xs)).shape[0])
   for _8 in range(0,int(((_0.__xs)).shape[0])):
    _3[_8] = (_0.__xs)[_8]
   for _9 in range(0,int(((_1.__xs)).shape[0])):
    _3[(_9 + _7)] = (_1.__xs)[_9]
   _10=(None if ((((_0.__b) is None) and ((_1.__b) is None)) ) else ((_0.__b)._add_Lmosek_4fusion_4SymmetricMatrix_2((_1.__b)) if ((((_0.__b) is not None) and ((_1.__b) is not None)) ) else ((_0.__b) if (((_0.__b) is not None) ) else (_1.__b))))
   return (mosek_fusion_SymmetricExpr._ctor_I_3Lmosek_4fusion_4SymmetricMatrix_2_3Lmosek_4fusion_4Variable_2Lmosek_4fusion_4SymmetricMatrix_2((_0.__n),_2,_3,_10))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SymmetricExpr( (")._a_I(self.__n)._a_S(",")._a_I(self.__n)._a_S(") )")
   return (_0._toString_())
 return SymmetricExpr
mosek_fusion_SymmetricExpr=__mk_mosek_fusion_SymmetricExpr()
del __mk_mosek_fusion_SymmetricExpr
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricMatrix():
 class SymmetricMatrix(object):
  __slots__ = ['_SymmetricMatrix__nnz','_SymmetricMatrix__scale','_SymmetricMatrix__vval','_SymmetricMatrix__vsubj','_SymmetricMatrix__vsubi','_SymmetricMatrix__uval','_SymmetricMatrix__usubj','_SymmetricMatrix__usubi','_SymmetricMatrix__d1','_SymmetricMatrix__d0']
  @staticmethod
  def antiDiag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list antiDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.antiDiag(array(double,ndim=1))')
  def sub(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.sub(mosek.fusion.SymmetricMatrix)')
  def mul(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_mul_D(*args): # double
      return self._mul_D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_mul_D(*args): # double
      return self._mul_alt_D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.mul(double)')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.diag(array(double,ndim=1))')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.add(mosek.fusion.SymmetricMatrix)')
  def getdim(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_getdim_(*args): # 
      return self._getdim_(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_getdim_(*args): # 
      return self._getdim_alt_(*args)
    else:
      raise ValueError('Invalid argument list getdim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.getdim()')
  @staticmethod
  def rankOne(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne_alt__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_alt_I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list rankOne('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.rankOne(array(double,ndim=1))\n\tmosek.fusion.SymmetricMatrix.rankOne(int32,array(int32,ndim=1),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.SymmetricMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    o = SymmetricMatrix.__new__(SymmetricMatrix)
    o._ctor_init_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match__3I__(usubi) and __arg_match__3I__(usubj) and __arg_match__3D__(uval) and __arg_match__3I__(vsubi) and __arg_match__3I__(vsubj) and __arg_match__3D__(vval) and __arg_match_D__(scale))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match__3I__(usubi) and __arg_alt_match__3I__(usubj) and __arg_alt_match__3D__(uval) and __arg_alt_match__3I__(vsubi) and __arg_alt_match__3I__(vsubj) and __arg_alt_match__3D__(vval) and __arg_alt_match_D__(scale))
  def _ctor_alt_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    self._ctor_init_II_3I_3I_3D_3I_3I_3DD(numpy.int32(dim0),numpy.int32(dim1),numpy.array(usubi,dtype=numpy.dtype(numpy.int32)),numpy.array(usubj,dtype=numpy.dtype(numpy.int32)),numpy.array(uval,dtype=numpy.dtype(numpy.float64)),numpy.array(vsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(vsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(vval,dtype=numpy.dtype(numpy.float64)),numpy.float64(scale))
  def _ctor_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
   assert usubi is None or isinstance(usubi,numpy.ndarray)
   assert usubj is None or isinstance(usubj,numpy.ndarray)
   assert uval is None or isinstance(uval,numpy.ndarray)
   assert vsubi is None or isinstance(vsubi,numpy.ndarray)
   assert vsubj is None or isinstance(vsubj,numpy.ndarray)
   assert vval is None or isinstance(vval,numpy.ndarray)
   (self.__d0) = dim0
   (self.__d1) = dim1
   (self.__usubi) = usubi
   (self.__usubj) = usubj
   (self.__uval) = uval
   (self.__vsubi) = vsubi
   (self.__vsubj) = vsubj
   (self.__vval) = vval
   (self.__scale) = scale
   self.__nnz = (- 1)
  @staticmethod
  def _match_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _rankOne_alt_I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne_I_3I_3D(_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if (int((_1).shape[0])!=int((_2).shape[0])): # src/fusion/SymmetricMatrix.monty:168:12-30
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   for _3 in range(0,int((_1).shape[0])):
    if ((_1[_3] < 0) or (_1[_3] >= _0)): # src/fusion/SymmetricMatrix.monty:172:14-39
     raise mosek_fusion_LengthError._ctor_S("Invalid index in argument 'sub'")
   _4=numpy.array([_1[_5] for _5 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([1 for _7 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _8=numpy.array([_2[_9] for _9 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_0,1,_4,_6,_8,_4,_6,_8,1.0))
  @staticmethod
  def _match_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _rankOne_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _4=numpy.array([1 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([_0[_7] for _7 in range(0,_1)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,1,_2,_4,_6,_2,_4,_6,1.0))
  @staticmethod
  def _match_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antiDiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._antiDiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antiDiag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,numpy.array([(_1 - _4) for _4 in range(0,_1)], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_5] for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _6 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,_2,numpy.array([_0[_4] for _4 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _add_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _add_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   _1=self._getdim_()
   if (_0._getdim_()!=_1): # src/fusion/SymmetricMatrix.monty:78:12-27
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   _2=int((self.__usubi).shape[0])
   _3=int(((_0.__usubi)).shape[0])
   _4=(_2 + _3)
   _5=int((self.__vsubi).shape[0])
   _6=int(((_0.__vsubi)).shape[0])
   _7=(_5 + _6)
   _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
   _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _12=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_13,0,_2)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__usubi),0,_13,_2,_3)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubj,0,_12,0,_2)
   for _14 in range(0,_3):
    _12[(_14 + _2)] = ((_0.__usubj)[_14] + self.__d1)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)): # src/fusion/SymmetricMatrix.monty:101:12-38
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__uval,0,_11,0,_2)
   else:
    fragments._c_closure_603(_11,self.__scale,_2,self.__uval) # src/fusion/SymmetricMatrix.monty:104:10-60
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)): # src/fusion/SymmetricMatrix.monty:106:12-42
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__uval),0,_11,_2,_3)
   else:
    for _15 in range(0,_3):
     _11[(_15 + _2)] = ((_0.__scale) * (_0.__uval)[_15])
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_13,0,_2)
   for _16 in range(0,_6):
    _10[(_16 + _5)] = ((_0.__vsubi)[_16] + (_0.__d1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__vsubj,0,_9,0,_5)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__vsubj),_5,_9,_5,_6)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)): # src/fusion/SymmetricMatrix.monty:119:12-38
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__vval,0,_8,0,_5)
   else:
    fragments._c_closure_604(_8,self.__scale,_5,self.__vval) # src/fusion/SymmetricMatrix.monty:122:10-60
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)): # src/fusion/SymmetricMatrix.monty:124:12-42
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__vval),0,_8,_5,_6)
   else:
    for _17 in range(0,_6):
     _8[(_17 + _5)] = ((_0.__scale) * (_0.__vval)[_17])
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,(self.__d1 + (_0.__d1)),_13,_12,_11,_10,_9,_8,1.0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _sub_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   return (self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0._mul_D((- 1.0))))
  @staticmethod
  def _match_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _mul_alt_D(self,_t__0):
    return self._mul_D(numpy.float64(__0))
  def _mul_D(self,_0):
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,self.__d1,self.__usubi,self.__usubj,self.__uval,self.__vsubi,self.__vsubj,self.__vval,(self.__scale * _0)))
  @staticmethod
  def _match_getdim_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getdim_(*args):
    if len(args) != 0: return False
    return True
  def _getdim_alt_(self,):
    return self._getdim_()
  def _getdim_(self,):
   return numpy.int32(self.__d0)
 return SymmetricMatrix
mosek_fusion_SymmetricMatrix=__mk_mosek_fusion_SymmetricMatrix()
del __mk_mosek_fusion_SymmetricMatrix
#BEFORE CLASS
def __mk_mosek_fusion_NDSparseArray():
 class NDSparseArray(object):
  __slots__ = ['_cof','_inst','_dims','_size']
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_NDSparseArray._match_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make__3I_3_5I_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSparseArray.make(mosek.fusion.Matrix)\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NDSparseArray'
  @staticmethod
  def _ctor__3I_3_5I_3D(dims_,sub,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3_5I_3D(dims_,sub,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3_5I__(sub) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3_5I__(sub) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3_5I_3D(self,dims_,sub,cof_):
    self._ctor_init__3I_3_5I_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(sub,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3_5I_3D(self,dims_,sub,cof_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert sub is None or isinstance(sub,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   _0=numpy.zeros((int((sub).shape[0]),), dtype=numpy.dtype(numpy.int64))
   self._size = 1
   self._size = fragments._c_closure_605(dims_,self._size) # src/fusion/Matrix.mbi:1076:19-70
   self._size = numpy.int64(self._size) # postprocess
   _1=int((dims_).shape[0])
   if (int((sub).shape[0])!=int((cof_).shape[0])): # src/fusion/Matrix.mbi:1078:12-35
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   if (int((sub).shape[1])!=_1): # src/fusion/Matrix.mbi:1080:12-28
    raise mosek_fusion_IndexError._ctor_S("An index key in sub has wrong length")
   _2=False
   _2 = fragments._c_closure_606(dims_,_2,sub) # src/fusion/Matrix.mbi:1084:8-1089:9
   if _2: # src/fusion/Matrix.mbi:1090:12-23
    raise mosek_fusion_IndexError._ctor_S("An index in sub is out of bounds")
   fragments._c_closure_607(dims_,_0,sub) # src/fusion/Matrix.mbi:1093:8-1099:9
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _3=True
   _3 = fragments._c_closure_608(_0,_3) # src/fusion/Matrix.mbi:1103:8-83
   if _3: # src/fusion/Matrix.mbi:1105:12-20
    _4=1
    _4 = fragments._c_closure_609(_0,_4) # src/fusion/Matrix.mbi:1108:10-1110:24
    _4 = numpy.int32(_4) # postprocess
    if (_4==int((_0).shape[0])): # src/fusion/Matrix.mbi:1111:14-35
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(_0)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = _0[0]
     self._cof = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _5=0
     _5 = fragments._c_closure_610(self._cof,cof_,self._inst,_0,_5) # src/fusion/Matrix.mbi:1121:12-1127:42
     _5 = numpy.int32(_5) # postprocess
   else:
    _6=mosek.fusion.Utils.Tools._range_J(int((_0).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_6,_0,None,0,int((_0).shape[0]))
    _7=1
    _7 = fragments._c_closure_611(_0,_7,_6) # src/fusion/Matrix.mbi:1135:10-1137:24
    _7 = numpy.int32(_7) # postprocess
    self._inst = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = _0[_6[0]]
    self._cof = numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_6[0]]
    _8=0
    _8 = fragments._c_closure_612(self._cof,cof_,self._inst,_0,_8,_6) # src/fusion/Matrix.mbi:1142:10-1148:46
    _8 = numpy.int32(_8) # postprocess
  @staticmethod
  def _ctor__3I_3J_3D(dims_,inst_,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3J_3D(dims_,inst_,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3J__(inst_) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(inst_) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3J_3D(self,dims_,inst_,cof_):
    self._ctor_init__3I_3J_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(inst_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,dims_,inst_,cof_):
   assert dims_ is None or isinstance(dims_,numpy.ndarray)
   assert inst_ is None or isinstance(inst_,numpy.ndarray)
   assert cof_ is None or isinstance(cof_,numpy.ndarray)
   self._size = 1
   self._size = fragments._c_closure_613(dims_,self._size) # src/fusion/Matrix.mbi:1006:19-70
   self._size = numpy.int64(self._size) # postprocess
   _0=int((inst_).shape[0])
   if (_0!=int((cof_).shape[0])): # src/fusion/Matrix.mbi:1008:12-26
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   _1=False
   _1 = fragments._c_closure_614(_1,inst_,_0,self._size) # src/fusion/Matrix.mbi:1012:10-1016:11
   if _1: # src/fusion/Matrix.mbi:1017:14-17
    raise mosek_fusion_IndexError._ctor_S("An index in inst is out of bounds")
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _2=True
   _2 = fragments._c_closure_615(inst_,_2) # src/fusion/Matrix.mbi:1023:8-83
   if _2: # src/fusion/Matrix.mbi:1025:12-20
    _3=1
    _3 = fragments._c_closure_616(inst_,_3) # src/fusion/Matrix.mbi:1028:10-1030:24
    _3 = numpy.int32(_3) # postprocess
    if (_3==int((inst_).shape[0])): # src/fusion/Matrix.mbi:1031:14-35
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(inst_)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = inst_[0]
     self._cof = numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _4=0
     _4 = fragments._c_closure_617(self._cof,cof_,self._inst,inst_,_4) # src/fusion/Matrix.mbi:1041:12-1047:42
     _4 = numpy.int32(_4) # postprocess
   else:
    _5=mosek.fusion.Utils.Tools._range_J(int((inst_).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_5,inst_,None,0,int((inst_).shape[0]))
    _6=1
    _6 = fragments._c_closure_618(inst_,_6,_5) # src/fusion/Matrix.mbi:1055:10-1057:24
    _6 = numpy.int32(_6) # postprocess
    self._inst = numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = inst_[_5[0]]
    self._cof = numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_5[0]]
    _7=0
    _7 = fragments._c_closure_619(self._cof,cof_,self._inst,inst_,_7,_5) # src/fusion/Matrix.mbi:1062:10-1068:46
    _7 = numpy.int32(_7) # postprocess
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m):
   _0=m._numNonzeros_()
   _1=m._numColumns_()
   _2=m._numRows_()
   _3=numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
   _4=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   m._getDataAsTriplets__3I_3I_3D(_5,_4,_3)
   self._size = (numpy.int64(m._numRows_()) * numpy.int64(m._numColumns_()))
   self._dims = numpy.array([_2,_1], dtype=numpy.dtype(numpy.int32))
   self._inst = numpy.array([((numpy.int64(_5[_6]) * _1) + numpy.int64(_4[_6])) for _6 in range(0,_0)], dtype=numpy.dtype(numpy.int64))
   self._cof = _3
  @staticmethod
  def _match_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _make_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _make_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_NDSparseArray._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3J_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3J_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3J_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_NDSparseArray._ctor__3I_3J_3D(_0,_1,_2))
  @staticmethod
  def _match_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3_5I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3_5I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3_5I_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_NDSparseArray._ctor__3I_3_5I_3D(_0,_1,_2))
 return NDSparseArray
mosek_fusion_NDSparseArray=__mk_mosek_fusion_NDSparseArray()
del __mk_mosek_fusion_NDSparseArray
#BEFORE CLASS
def __mk_mosek_fusion_Matrix():
 class Matrix(object):
  __slots__ = ['_dimj','_dimi']
  @staticmethod
  def eye(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_I(*args)
    elif mosek_fusion_Matrix._match_alt_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_alt_I(*args)
    else:
      raise ValueError('Invalid argument list eye('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.eye(int32)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Matrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.toString()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsArray()')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_II(*args)
    elif mosek_fusion_Matrix._match_alt_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_alt_II(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.ones(int32,int32)')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_II(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_alt_II(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_II_3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.sparse(array(double,ndim=2))\n\tmosek.fusion.Matrix.sparse(array(array(mosek.fusion.Matrix,ndim=1),ndim=1))\n\tmosek.fusion.Matrix.sparse(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.sparse(int32,int32)\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  @staticmethod
  def antidiag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1))\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.antidiag(int32,double)\n\tmosek.fusion.Matrix.antidiag(int32,double,int32)')
  @staticmethod
  def dense(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_IID(*args)
    elif mosek_fusion_Matrix._match_alt_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_alt_IID(*args)
    elif mosek_fusion_Matrix._match_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_II_3D(*args)
    elif mosek_fusion_Matrix._match_alt_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_alt_II_3D(*args)
    else:
      raise ValueError('Invalid argument list dense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.dense(array(double,ndim=2))\n\tmosek.fusion.Matrix.dense(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.dense(int32,int32,double)\n\tmosek.fusion.Matrix.dense(int32,int32,array(double,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Matrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.transpose()')
  def numRows(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numRows_(*args): # 
      return self._numRows_(*args)
    elif mosek_fusion_Matrix._match_alt_numRows_(*args): # 
      return self._numRows_alt_(*args)
    else:
      raise ValueError('Invalid argument list numRows('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numRows()')
  def numColumns(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numColumns_(*args): # 
      return self._numColumns_(*args)
    elif mosek_fusion_Matrix._match_alt_numColumns_(*args): # 
      return self._numColumns_alt_(*args)
    else:
      raise ValueError('Invalid argument list numColumns('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numColumns()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_Matrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.get(int32,int32)')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.diag(array(double,ndim=1))\n\tmosek.fusion.Matrix.diag(array(mosek.fusion.Matrix,ndim=1))\n\tmosek.fusion.Matrix.diag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.diag(int32,mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.diag(int32,double)\n\tmosek.fusion.Matrix.diag(int32,double,int32)')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Matrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numNonzeros()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_Matrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.isSparse()')
  def __repr__(self): return 'mosek.fusion.Matrix'
  @staticmethod
  def _ctor_II(di,dj):
    o = Matrix.__new__(Matrix)
    o._ctor_init_II(di,dj)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_match_I__(di) and __arg_match_I__(dj))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_alt_match_I__(di) and __arg_alt_match_I__(dj))
  def _ctor_alt_init_II(self,di,dj):
    self._ctor_init_II(numpy.int32(di),numpy.int32(dj))
  def _ctor_init_II(self,di,dj):
   if ((di < 0) or (dj < 0)): # src/fusion/Matrix.mbi:67:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimensions")
   self._dimi = di
   self._dimj = dj
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("")
  def _switchDims_alt_(self,):
    return self._switchDims_()
  def _switchDims_(self,):
   _0=self._dimi
   self._dimi = self._dimj
   self._dimj = _0
  @staticmethod
  def _match_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _diag_alt_ILmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(numpy.int32(__0),_1)
  @staticmethod
  def _diag_ILmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Matrix._diag__3Lmosek_4fusion_4Matrix_2(numpy.array([_1 for _2 in range(0,_0)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _diag_alt__3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3Lmosek_4fusion_4Matrix_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=_0
   _2=0
   _3=0
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    _4 = (_4 + (_0[_5]._dimi))
    _3 = (_3 + (_0[_5]._dimj))
    _2 = (_2 + _0[_5]._numNonzeros_())
   _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _9=0
   _10=0
   _11=0
   for _12 in range(0,int((_0).shape[0])):
    _13=_0[_12]._numNonzeros_()
    _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _0[_12]._getDataAsTriplets__3I_3I_3D(_16,_15,_14)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_14,0,_8,_11,_13)
    fragments._c_closure_620(_13,_11,_16,_10,_9,_6,_7) # src/fusion/Matrix.mbi:535:12-539:13
    _11 = (_11 + _13)
    _10 = (_10 + (_0[_12]._dimi))
    _9 = (_9 + (_0[_12]._dimj))
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_4,_3,_6,_7,_8))
  @staticmethod
  def _match_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _antidiag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._antidiag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _antidiag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)): # src/fusion/Matrix.mbi:487:16-32
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)): # src/fusion/Matrix.mbi:489:16-32
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _antidiag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._antidiag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _antidiag_ID(_0,_1):
   return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _diag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._diag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _diag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)): # src/fusion/Matrix.mbi:471:16-32
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)): # src/fusion/Matrix.mbi:473:16-32
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _diag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _diag_ID(_0,_1):
   return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _antidiag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._antidiag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3DI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0): # src/fusion/Matrix.mbi:447:12-18
    _5=mosek.fusion.Utils.Tools._range_II(_1,(_4 + _1))
    _6=numpy.array([((_4 + _1) - _7) for _7 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    _9=numpy.array([(_4 - _10) for _10 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_8,_9,_0))
  @staticmethod
  def _match_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antidiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._antidiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Matrix._antidiag__3DI(_0,0))
  @staticmethod
  def _match_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _diag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._diag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3DI(_0,_1):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0): # src/fusion/Matrix.mbi:421:12-18
    _5=mosek.fusion.Utils.Tools._range_II(0,_4)
    _6=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _7=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_7,_8,_0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek.fusion.Matrix._diag__3DI(_0,0))
  @staticmethod
  def _match_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _ones_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._ones_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _ones_II(_0,_1):
   return (mosek.fusion.Matrix._dense_IID(_0,_1,1.0))
  @staticmethod
  def _match_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _eye_alt_I(_t__0):
    return mosek_fusion_Matrix._eye_I(numpy.int32(__0))
  @staticmethod
  def _eye_I(_0):
   return (mosek.fusion.Matrix._diag__3D(numpy.array([1.0 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _dense_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _dense_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_DenseMatrix._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _dense_alt_IID(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._dense_IID(numpy.int32(__0),numpy.int32(__1),numpy.float64(__2))
  @staticmethod
  def _dense_IID(_0,_1,_2):
   return (mosek_fusion_DenseMatrix._ctor_IID(_0,_1,_2))
  @staticmethod
  def _match_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _dense_alt_II_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense_II_3D(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dense_II_3D(_0,_1,_2):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   return (mosek_fusion_DenseMatrix._ctor_II_3D(_0,_1,_2))
  @staticmethod
  def _match_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _dense_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense__3_5D(_0)
   return _1
  @staticmethod
  def _dense__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   return (mosek_fusion_DenseMatrix._ctor__3_5D(_0))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4Matrix_2(_0):
   _1=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _2=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_1,_2,_3)
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_0._numRows_(),_0._numColumns_(),_1,_2,_3))
  @staticmethod
  def _match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt__3_3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3_3Lmosek_4fusion_4Matrix_2(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=int((_0[0]).shape[0])
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=0
   _6=0
   _7=0
   while (_7 < _1):
    _8=0
    while (_8 < _2):
     _9=_0[_7][_8]
     if (_9 is not None): # src/fusion/Matrix.mbi:247:21-30
      if (_4[_8]==0): # src/fusion/Matrix.mbi:249:23-36
       _4[_8] = (_9._dimj)
      elif (_4[_8]!=(_9._dimj)): # src/fusion/Matrix.mbi:253:23-41
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      if (_3[_7]==0): # src/fusion/Matrix.mbi:258:23-36
       _3[_7] = (_9._dimi)
      elif (_3[_7]!=(_9._dimi)): # src/fusion/Matrix.mbi:262:23-41
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      _5 = (_5 + _9._numNonzeros_())
     _6 += 1
     _8 += 1
    _7 += 1
   _10=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _11=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _13=0
   _14=0
   _15=0
   while (_15 < _1):
    _16=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _17=0
    while (_17 < _3[_15]):
     _18=0
     _19=0
     while (_19 < _2):
      _20=_0[_15][_19]
      if (_20 is not None): # src/fusion/Matrix.mbi:315:23-33
       _22=_20
       if   isinstance(_22,mosek_fusion_DenseMatrix):
        m=_22
        _22=_16[_19]
        _23=0
        while (_23 < (m._dimj)):
         _10[_13] = (m._data)[_22]
         _11[_13] = (_14 + _17)
         _12[_13] = (_18 + _23)
         _22 += 1
         _13 += 1
         _23 += 1
        _16[_19] = _22
       elif isinstance(_22,mosek_fusion_SparseMatrix):
        _24=_22
        _25 = _16[_19]
        while ((_25 < (_24._nnz)) and ((_24._subi)[_25]==_17)):
         _10[_13] = (_24._val)[_25]
         _12[_13] = ((_24._subj)[_25] + _18)
         _11[_13] = (_14 + _17)
         _13 += 1
         _25 += 1
        _16[_19] = _25
       else:
        m=_22
        raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
      _18 = (_18 + _4[_19])
      _19 += 1
     _17 += 1
    _14 = (_14 + _3[_15])
    _15 += 1
   _26=0
   _27=0
   _26 = fragments._c_closure_621(_26,_3,_1) # src/fusion/Matrix.mbi:361:8-364:9
   _26 = numpy.int32(_26) # postprocess
   _27 = fragments._c_closure_622(_27,_4,_2) # src/fusion/Matrix.mbi:365:8-368:9
   _27 = numpy.int32(_27) # postprocess
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_26,_27,_11,_12,_10))
  @staticmethod
  def _match_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _sparse_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3_5D(_0)
   return _1
  @staticmethod
  def _sparse__3_5D(_0):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   _1=int((_0).shape[0])
   _2=int((_0).shape[1])
   _3=numpy.int64((_1 * _2))
   _4=0
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _4 = fragments._c_closure_623(_0,_1,_2,_4,_5,_6,_7) # src/fusion/Matrix.mbi:218:8-225:13
   _4 = numpy.int32(_4) # postprocess
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_1,_2,_5,_6,_7))
  @staticmethod
  def _match_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sparse_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._sparse_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _sparse_II(_0,_1):
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),0))
  @staticmethod
  def _match_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match_D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match_D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3ID(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.float64(_t__4)
   _1 = mosek_fusion_Matrix._sparse_II_3I_3ID(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3ID(_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   _5=0
   if (_2 is not None): # src/fusion/Matrix.mbi:196:16-28
    _5 = int((_2).shape[0])
   elif (_3 is not None): # src/fusion/Matrix.mbi:197:16-28
    _5 = int((_3).shape[0])
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,mosek.fusion.Utils.Tools._makevector_DI(_4,_5)))
  @staticmethod
  def _match_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _sparse_alt__3I_3ID(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.float64(_t__2)
   _1 = mosek_fusion_Matrix._sparse__3I_3ID(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3ID(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])): # src/fusion/Matrix.mbi:177:12-27
    _5 = int((_1).shape[0])
   _4,_3 = fragments._c_closure_624(_4,_3,_5,_0,_1) # src/fusion/Matrix.mbi:179:8-183:9
   _4 = numpy.int32(_4) # postprocess
   _3 = numpy.int32(_3) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3ID((_4 + 1),(_3 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _sparse_alt__3I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3I_3D(_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])): # src/fusion/Matrix.mbi:158:12-27
    _5 = int((_1).shape[0])
   if (_5 > int((_2).shape[0])): # src/fusion/Matrix.mbi:159:12-26
    _5 = int((_2).shape[0])
   _4,_3 = fragments._c_closure_625(_4,_3,_5,_0,_1) # src/fusion/Matrix.mbi:161:8-165:9
   _4 = numpy.int32(_4) # postprocess
   _3 = numpy.int32(_3) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D((_4 + 1),(_3 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3I_3D(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3I_3D(_0,_1,_2,_3,_4):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   assert _3 is None or isinstance(_3,numpy.ndarray)
   assert _4 is None or isinstance(_4,numpy.ndarray)
   _5=(_4 if ((_4 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
   _6=(_3 if ((_3 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _7=(_2 if ((_2 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _8=int((_7).shape[0])
   if ((int((_6).shape[0])!=_8) or (int((_5).shape[0])!=_8)): # src/fusion/Matrix.mbi:140:17-141:35
    raise mosek_fusion_SparseFormatError._ctor_S("Arrays defining sparse data have different lengths")
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,_7,_6,_5,_8))
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   pass
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   pass
  @staticmethod
  def _match_numColumns_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numColumns_(*args):
    if len(args) != 0: return False
    return True
  def _numColumns_alt_(self,):
    return self._numColumns_()
  def _numColumns_(self,):
   return numpy.int32(self._dimj)
  @staticmethod
  def _match_numRows_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numRows_(*args):
    if len(args) != 0: return False
    return True
  def _numRows_alt_(self,):
    return self._numRows_()
  def _numRows_(self,):
   return numpy.int32(self._dimi)
 return Matrix
mosek_fusion_Matrix=__mk_mosek_fusion_Matrix()
del __mk_mosek_fusion_Matrix
#BEFORE CLASS
def __mk_mosek_fusion_DenseMatrix():
 class DenseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_data']
  def get(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_DenseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.get(int32,int32)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.toString()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.isSparse()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.transpose()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsArray()')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.numNonzeros()')
  def __repr__(self): return 'mosek.fusion.DenseMatrix'
  @staticmethod
  def _ctor_II_3D(dimi_,dimj_,cof):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_II_3D(dimi_,dimj_,cof)
    return o
  @staticmethod
  def __match_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3D__(cof))
  @staticmethod
  def __match_alt_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3D__(cof))
  def _ctor_alt_init_II_3D(self,dimi_,dimj_,cof):
    self._ctor_init_II_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(cof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3D(self,dimi_,dimj_,cof):
   assert cof is None or isinstance(cof,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._nnz = numpy.int64((dimi_ * dimj_))
   self._data = numpy.zeros(((dimi_ * dimj_),), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(cof,0,self._data,0,(dimi_ * dimj_))
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m_))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m_):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m_):
   mosek_fusion_Matrix._ctor_init_II(self,(m_._dimi),(m_._dimj))
   _1=m_
   if   isinstance(_1,mosek_fusion_DenseMatrix):
    m=_1
    self._data = mosek.fusion.Utils.Tools._arraycopy__3D((m._data))
   elif isinstance(_1,mosek_fusion_SparseMatrix):
    _1=_1
    self._data = mosek.fusion.Utils.Tools._zeros_I(((_1._dimi) * (_1._dimj)))
    for _2 in range(0,(_1._nnz)):
     self._data[(((_1._subi)[_2] * self._dimj) + (_1._subj)[_2])] = (_1._val)[_2]
   else:
    m=_1
    raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor__3_5D(d):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init__3_5D(d)
    return o
  @staticmethod
  def __match_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_match__3_5D__(d))
  @staticmethod
  def __match_alt_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_alt_match__3_5D__(d))
  def _ctor_alt_init__3_5D(self,d):
    self._ctor_init__3_5D(numpy.array(d,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3_5D(self,d):
   assert d is None or isinstance(d,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,int((d).shape[0]),int((d).shape[1]))
   self._data = numpy.array([d[_0,_1] for _0 in range(0,self._dimi) for _1 in range(0,self._dimj)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor_IID(dimi_,dimj_,value_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_IID(dimi_,dimj_,value_)
    return o
  @staticmethod
  def __match_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match_D__(value_))
  @staticmethod
  def __match_alt_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match_D__(value_))
  def _ctor_alt_init_IID(self,dimi_,dimj_,value_):
    self._ctor_init_IID(numpy.int32(dimi_),numpy.int32(dimj_),numpy.float64(value_))
  def _ctor_init_IID(self,dimi_,dimj_,value_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._data = numpy.array([value_ for _0 in range(0,dimi_) for _1 in range(0,dimj_)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((dimi_ * dimj_))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("DenseMatrix(")
   _0._a_I(self._dimi)
   _0._a_S(",")
   _0._a_I(self._dimj)
   _0._a_S(": ")
   _1=0
   _2=0
   while (_2 < self._dimi):
    if (_2 > 0): # src/fusion/Matrix.mbi:947:19-24
     _0._a_S(",")
    _0._a_S("[ ")
    _0._a_D(self._data[_1])
    _1 += 1
    _3=1
    while (_3 < self._dimj):
     _0._a_S(",")
     _0._a_D(self._data[_1])
     _1 += 1
     _3 += 1
    _0._a_S(" ]")
    _2 += 1
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   _1=0
   _2=self._dimi
   _1 = fragments._c_closure_626(self._data,self._dimi,self._dimj,_0,_1,_2) # src/fusion/Matrix.mbi:926:8-936:9
   _1 = numpy.int32(_1) # postprocess
   return (mosek_fusion_DenseMatrix._ctor_II_3D(self._dimj,self._dimi,_0))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (False)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3D(self._data))
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))): # src/fusion/Matrix.mbi:817:12-819:27
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self._data,0,_2,0,int((self._data).shape[0]))
   _3=0
   _3 = fragments._c_closure_627(self._dimi,self._dimj,_3,_0,_1) # src/fusion/Matrix.mbi:826:8-834:9
   _3 = numpy.int32(_3) # postprocess
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   return numpy.float64(self._data[((_0 * self._dimj) + _1)])
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(numpy.int64((self._dimi * self._dimj)))
 return DenseMatrix
mosek_fusion_DenseMatrix=__mk_mosek_fusion_DenseMatrix()
del __mk_mosek_fusion_DenseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_SparseMatrix():
 class SparseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_val','_subj','_subi']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.toString()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_SparseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.get(int32,int32)')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsArray()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.transpose()')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.numNonzeros()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.isSparse()')
  def __repr__(self): return 'mosek.fusion.SparseMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_) and __arg_match_J__(nelm))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_) and __arg_alt_match_J__(nelm))
  def _ctor_alt_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
    self._ctor_init_II_3I_3I_3DJ(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)),numpy.int64(nelm))
  def _ctor_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
   assert subi_ is None or isinstance(subi_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert val_ is None or isinstance(val_,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   if (nelm > 0): # src/fusion/Matrix.mbi:680:17-25
    if ((int((subi_).shape[0]) < nelm) or ((int((subj_).shape[0]) < nelm) or (int((val_).shape[0]) < nelm))): # src/fusion/Matrix.mbi:682:19-684:36
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching arrays in sparse data.")
    _0=False
    _0 = fragments._c_closure_628(self._dimi,self._dimj,nelm,_0,subi_,subj_) # src/fusion/Matrix.mbi:689:10-692:33
    if _0: # src/fusion/Matrix.mbi:694:14-25
     raise mosek_fusion_SparseFormatError._ctor_S("Subscript out of bounds.")
    _1=numpy.ndarray((1,), dtype=numpy.dtype(object))
    _2=numpy.ndarray((1,), dtype=numpy.dtype(object))
    _3=numpy.ndarray((1,), dtype=numpy.dtype(object))
    mosek.fusion.CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(subi_,subj_,val_,_1,_2,_3,nelm,self._dimi,self._dimj)
    self._subi = _1[0]
    self._subj = _2[0]
    self._val = _3[0]
    self._nnz = int((self._val).shape[0])
   else:
    self._subi = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = 0
  @staticmethod
  def _ctor_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_))
  def _ctor_alt_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
    self._ctor_init_II_3I_3I_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
   assert subi_ is None or isinstance(subi_,numpy.ndarray)
   assert subj_ is None or isinstance(subj_,numpy.ndarray)
   assert val_ is None or isinstance(val_,numpy.ndarray)
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   _0=0
   _0 = fragments._c_closure_629(_0,val_) # src/fusion/Matrix.mbi:625:19-88
   _0 = numpy.int32(_0) # postprocess
   if ((_0 > 0) and (_0 < int((subi_).shape[0]))): # src/fusion/Matrix.mbi:627:12-36
    self._subi = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = _0
    _1=0
    _1 = fragments._c_closure_630(_1,self._subi,subi_,self._subj,subj_,self._val,val_) # src/fusion/Matrix.mbi:634:10-641:13
    _1 = numpy.int32(_1) # postprocess
   else:
    self._subi = subi_
    self._subj = subj_
    self._val = val_
    if (subi_ is None): # src/fusion/Matrix.mbi:648:19-32
     self._nnz = 0
    else:
     self._nnz = int((self._subi).shape[0])
  def _formPtrb_alt_(self,):
    return self._formPtrb_()
  def _formPtrb_(self,):
   _0=numpy.zeros(((self._dimi + 1),), dtype=numpy.dtype(numpy.int64))
   _1=0
   _1 = fragments._c_closure_631(self._dimi,self._nnz,_1,_0,self._subi) # src/fusion/Matrix.mbi:779:8-785:9
   _1 = numpy.int64(_1) # postprocess
   _0[self._dimi] = _1
   return (_0)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SparseMatrix(")._a_I(self._dimi)._a_S(",")._a_I(self._dimj)._a_S(", [")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)): # src/fusion/Matrix.mbi:764:12-42
    _0._a_S("(")._a_I(self._subi[0])._a_S(",")._a_I(self._subj[0])._a_S(",")._a_D(self._val[0])._a_S(")")
    for _1 in range(1,int((self._subi).shape[0])):
     _0._a_S(",(")._a_I(self._subi[_1])._a_S(",")._a_I(self._subj[_1])._a_S(",")._a_D(self._val[_1])._a_S(")")
   _0._a_S(" ])")
   return (_0._toString_())
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(self._nnz)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(self._dimj,self._dimi,self._subj,self._subi,self._val))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (True)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_632(self._dimj,_0,self._subi,self._subj,self._val) # src/fusion/Matrix.mbi:740:8-741:45
   return (_0)
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   assert _0 is None or isinstance(_0,numpy.ndarray)
   assert _1 is None or isinstance(_1,numpy.ndarray)
   assert _2 is None or isinstance(_2,numpy.ndarray)
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))): # src/fusion/Matrix.mbi:722:12-724:32
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)): # src/fusion/Matrix.mbi:729:12-42
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subi,0,_0,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subj,0,_1,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self._val,0,_2,0,self._nnz)
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   if ((_0 < 0) or ((_0 >= self._dimi) or ((_1 < 0) or (_1 >= self._dimj)))): # src/fusion/Matrix.mbi:590:13-591:31
    raise mosek_fusion_IndexError._ctor_S("Index out if bounds")
   _2=int((self._subi).shape[0])
   _3=0
   while ((_2 - _3) > 1):
    _4=((_3 + _2) // 2)
    if ((self._subi[_4] < _0) or ((self._subi[_4]==_0) and (self._subj[_4] < _1))): # src/fusion/Matrix.mbi:599:18-63
     _3 = _4
    elif ((self._subi[_4] > _0) or ((self._subi[_4]==_0) and (self._subj[_4] > _1))): # src/fusion/Matrix.mbi:600:18-63
     _2 = _4
    else:
     return numpy.float64(self._val[_4])
   if ((self._subi[_3]==_0) and (self._subj[_3]==_1)): # src/fusion/Matrix.mbi:604:12-41
    return numpy.float64(self._val[_3])
   else:
    return numpy.float64(0.0)
 return SparseMatrix
mosek_fusion_SparseMatrix=__mk_mosek_fusion_SparseMatrix()
del __mk_mosek_fusion_SparseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_LinkedBlocks():
 class LinkedBlocks(object):
  __slots__ = ['_LinkedBlocks__bfirst','_LinkedBlocks__bsize','_LinkedBlocks__blocks','_LinkedBlocks__ints']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args): # mosek.fusion.LinkedBlocks
      self._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):# mosek.fusion.LinkedBlocks
      self._ctor_alt_init_Lmosek_4fusion_4LinkedBlocks_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LinkedBlocks.ctor()\n\tmosek.fusion.LinkedBlocks.ctor(int32)\n\tmosek.fusion.LinkedBlocks.ctor(mosek.fusion.LinkedBlocks)')
  def numblocks(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_numblocks_(*args): # 
      return self._numblocks_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_numblocks_(*args): # 
      return self._numblocks_alt_(*args)
    else:
      raise ValueError('Invalid argument list numblocks('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.numblocks()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_get_I_3II(*args): # int32,[]int32,int32
      return self._get_I_3II(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_get_I_3II(*args): # int32,[]int32,int32
      return self._get_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.get(int32,array(int32,ndim=1),int32)')
  def blocksize(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_blocksize_I(*args): # int32
      return self._blocksize_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_blocksize_I(*args): # int32
      return self._blocksize_alt_I(*args)
    else:
      raise ValueError('Invalid argument list blocksize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.blocksize(int32)')
  def alloc(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_alloc_I(*args): # int32
      return self._alloc_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_alloc_I(*args): # int32
      return self._alloc_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.alloc(int32)')
  def free(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_free_I(*args): # int32
      return self._free_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_free_I(*args): # int32
      return self._free_alt_I(*args)
    else:
      raise ValueError('Invalid argument list free('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.free(int32)')
  def capacity(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_capacity_(*args): # 
      return self._capacity_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_capacity_(*args): # 
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.capacity()')
  def validate(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_validate_(*args): # 
      return self._validate_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_validate_(*args): # 
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.validate()')
  def maxidx(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_maxidx_I(*args): # int32
      return self._maxidx_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_maxidx_I(*args): # int32
      return self._maxidx_alt_I(*args)
    else:
      raise ValueError('Invalid argument list maxidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.maxidx(int32)')
  def __repr__(self): return 'mosek.fusion.LinkedBlocks'
  @staticmethod
  def _ctor_():
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_LinkedBlocks._ctor_init_I(self,0)
  @staticmethod
  def _ctor_I(n):
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_I(n)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    n, = args
    return (__arg_match_I__(n))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    n, = args
    return (__arg_alt_match_I__(n))
  def _ctor_alt_init_I(self,n):
    self._ctor_init_I(numpy.int32(n))
  def _ctor_init_I(self,n):
   self.__ints = mosek_fusion_LinkedInts._ctor_I(n)
   self.__blocks = mosek_fusion_LinkedInts._ctor_I(128)
   self.__bsize = numpy.zeros((128,), dtype=numpy.dtype(numpy.int32))
   self.__bfirst = numpy.zeros((128,), dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinkedBlocks_2(other):
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinkedBlocks_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinkedBlocks_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinkedBlocks_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(other)
  def _ctor_init_Lmosek_4fusion_4LinkedBlocks_2(self,other):
   self.__ints = mosek_fusion_LinkedInts._ctor_Lmosek_4fusion_4LinkedInts_2((other.__ints))
   self.__blocks = mosek_fusion_LinkedInts._ctor_Lmosek_4fusion_4LinkedInts_2((other.__blocks))
   self.__bsize = mosek.fusion.Utils.Tools._arraycopy__3I((other.__bsize))
   self.__bfirst = mosek.fusion.Utils.Tools._arraycopy__3I((other.__bfirst))
  @staticmethod
  def _match_free_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_free_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _free_alt_I(self,_t__0):
    return self._free_I(numpy.int32(__0))
  def _free_I(self,_0):
   _1=self.__bfirst[_0]
   self.__ints._free_II(_0,self.__bsize[_0])
   self.__bsize[_0] = (- 1)
   self.__bfirst[_0] = (- 1)
   self.__blocks._free_II(_1,1)
  @staticmethod
  def _match_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloc_alt_I(self,_t__0):
    return self._alloc_I(numpy.int32(__0))
  def _alloc_I(self,_0):
   _1=(self.__ints._alloc_I(_0) if ((_0 > 0) ) else (- 1))
   _2=self.__blocks._alloc_()
   if (self.__blocks._capacity_() > int((self.__bsize).shape[0])): # src/fusion/LinkedList.monty:238:12-42
    _3=numpy.zeros((self.__blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((self.__blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__bsize,0,_3,0,int((self.__bsize).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__bfirst,0,_4,0,int((self.__bfirst).shape[0]))
    self.__bsize = _3
    self.__bfirst = _4
   self.__bfirst[_2] = _1
   self.__bsize[_2] = _0
   return numpy.int32(_2)
  @staticmethod
  def _match_maxidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_maxidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _maxidx_alt_I(self,_t__0):
    return self._maxidx_I(numpy.int32(__0))
  def _maxidx_I(self,_0):
   return numpy.int32(self.__ints._maxidx_II(self.__bfirst[_0],self.__bsize[_0]))
  @staticmethod
  def _match_get_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_get_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _get_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._get_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _get_I_3II(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   self.__ints._get_II_3II(self.__bfirst[_0],self.__bsize[_0],_1,_2)
  @staticmethod
  def _match_numblocks_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numblocks_(*args):
    if len(args) != 0: return False
    return True
  def _numblocks_alt_(self,):
    return self._numblocks_()
  def _numblocks_(self,):
   return numpy.int32(int((self.__bsize).shape[0]))
  @staticmethod
  def _match_blocksize_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_blocksize_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _blocksize_alt_I(self,_t__0):
    return self._blocksize_I(numpy.int32(__0))
  def _blocksize_I(self,_0):
   return numpy.int32(self.__bsize[_0])
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(self.__ints._capacity_())
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   return ((self.__ints._validate_() and self.__blocks._validate_()))
 return LinkedBlocks
mosek_fusion_LinkedBlocks=__mk_mosek_fusion_LinkedBlocks()
del __mk_mosek_fusion_LinkedBlocks
#BEFORE CLASS
def __mk_mosek_fusion_LinkedInts():
 class LinkedInts(object):
  __slots__ = ['_LinkedInts__nfree','_LinkedInts__last_free','_LinkedInts__first_free','_LinkedInts__first_used','_LinkedInts__prev','_LinkedInts__next']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4LinkedInts_2(*args): # mosek.fusion.LinkedInts
      self._ctor_init_Lmosek_4fusion_4LinkedInts_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4LinkedInts_2(*args):# mosek.fusion.LinkedInts
      self._ctor_alt_init_Lmosek_4fusion_4LinkedInts_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LinkedInts.ctor()\n\tmosek.fusion.LinkedInts.ctor(int32)\n\tmosek.fusion.LinkedInts.ctor(mosek.fusion.LinkedInts)')
  def maxidx(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_maxidx_II(*args): # int32,int32
      return self._maxidx_II(*args)
    elif mosek_fusion_LinkedInts._match_alt_maxidx_II(*args): # int32,int32
      return self._maxidx_alt_II(*args)
    else:
      raise ValueError('Invalid argument list maxidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.maxidx(int32,int32)')
  def free(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_free_II(*args): # int32,int32
      return self._free_II(*args)
    elif mosek_fusion_LinkedInts._match_alt_free_II(*args): # int32,int32
      return self._free_alt_II(*args)
    else:
      raise ValueError('Invalid argument list free('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.free(int32,int32)')
  def alloc(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_alloc_(*args): # 
      return self._alloc_(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_(*args): # 
      return self._alloc_alt_(*args)
    elif mosek_fusion_LinkedInts._match_alloc_I(*args): # int32
      return self._alloc_I(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_I(*args): # int32
      return self._alloc_alt_I(*args)
    elif mosek_fusion_LinkedInts._match_alloc_I_3II(*args): # int32,[]int32,int32
      return self._alloc_I_3II(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_I_3II(*args): # int32,[]int32,int32
      return self._alloc_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list alloc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.alloc()\n\tmosek.fusion.LinkedInts.alloc(int32)\n\tmosek.fusion.LinkedInts.alloc(int32,array(int32,ndim=1),int32)')
  def validate(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_validate_(*args): # 
      return self._validate_(*args)
    elif mosek_fusion_LinkedInts._match_alt_validate_(*args): # 
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.validate()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_get_II_3II(*args): # int32,int32,[]int32,int32
      return self._get_II_3II(*args)
    elif mosek_fusion_LinkedInts._match_alt_get_II_3II(*args): # int32,int32,[]int32,int32
      return self._get_alt_II_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.get(int32,int32,array(int32,ndim=1),int32)')
  def capacity(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_capacity_(*args): # 
      return self._capacity_(*args)
    elif mosek_fusion_LinkedInts._match_alt_capacity_(*args): # 
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.capacity()')
  def __repr__(self): return 'mosek.fusion.LinkedInts'
  @staticmethod
  def _ctor_I(cap_):
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_I(cap_)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    cap_, = args
    return (__arg_match_I__(cap_))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    cap_, = args
    return (__arg_alt_match_I__(cap_))
  def _ctor_alt_init_I(self,cap_):
    self._ctor_init_I(numpy.int32(cap_))
  def _ctor_init_I(self,cap_):
   _0=(cap_ if ((cap_ > 0) ) else 128)
   self.__next = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   self.__prev = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   self.__first_used = (- 1)
   self.__first_free = 0
   self.__last_free = (_0 - 1)
   fragments._c_closure_633(_0,self.__next,self.__prev) # src/fusion/LinkedList.monty:80:8-62
   self.__prev[0] = (- 1)
   self.__next[(_0 - 1)] = (- 1)
   self.__nfree = _0
  @staticmethod
  def _ctor_():
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_LinkedInts._ctor_init_I(self,128)
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinkedInts_2(other):
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_Lmosek_4fusion_4LinkedInts_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinkedInts_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinkedInts_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinkedInts_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinkedInts_2(other)
  def _ctor_init_Lmosek_4fusion_4LinkedInts_2(self,other):
   self.__next = mosek.fusion.Utils.Tools._arraycopy__3I((other.__next))
   self.__prev = mosek.fusion.Utils.Tools._arraycopy__3I((other.__prev))
   self.__first_used = (other.__first_used)
   self.__first_free = (other.__first_free)
   self.__last_free = (other.__last_free)
   self.__nfree = (other.__nfree)
  @staticmethod
  def _match_free_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_free_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _free_alt_II(self,_t__0,_t__1):
    return self._free_II(numpy.int32(__0),numpy.int32(__1))
  def _free_II(self,_0,_1):
   self.__first_free,self.__nfree = fragments._c_closure_634(self.__first_free,_0,self.__next,self.__nfree,_1,self.__prev) # src/fusion/LinkedList.monty:177:45-193:7
   self.__first_free = numpy.int32(self.__first_free) # postprocess
   self.__nfree = numpy.int32(self.__nfree) # postprocess
  @staticmethod
  def _match_alloc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_alloc_(*args):
    if len(args) != 0: return False
    return True
  def _alloc_alt_(self,):
    return self._alloc_()
  def _alloc_(self,):
   return numpy.int32(self.__allocblock_I(1))
  @staticmethod
  def _match_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloc_alt_I(self,_t__0):
    return self._alloc_I(numpy.int32(__0))
  def _alloc_I(self,_0):
   return numpy.int32(self.__allocblock_I(_0))
  @staticmethod
  def _match_alloc_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_alloc_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _alloc_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._alloc_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _alloc_I_3II(self,_0,_1,_2):
   assert _1 is None or isinstance(_1,numpy.ndarray)
   _3=self.__allocblock_I(_0)
   _3 = fragments._c_closure_635(_3,self.__next,_0,_2,_1) # src/fusion/LinkedList.monty:163:8-166:9
   _3 = numpy.int32(_3) # postprocess
  @staticmethod
  def _match_get_II_3II(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_get_II_3II(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_I__(_3))
  def _get_alt_II_3II(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _1 = self._get_II_3II(_0,_1,_2,_3)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _get_II_3II(self,_0,_1,_2,_3):
   assert _2 is None or isinstance(_2,numpy.ndarray)
   fragments._c_closure_636(_0,self.__next,_1,_3,_2) # src/fusion/LinkedList.monty:153:74-159:7
  @staticmethod
  def _match_maxidx_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_maxidx_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _maxidx_alt_II(self,_t__0,_t__1):
    return self._maxidx_II(numpy.int32(__0),numpy.int32(__1))
  def _maxidx_II(self,_0,_1):
   _2=_0
   _3=_0
   _3,_2 = fragments._c_closure_637(_3,_2,self.__next,_1) # src/fusion/LinkedList.monty:146:8-149:9
   _3 = numpy.int32(_3) # postprocess
   _2 = numpy.int32(_2) # postprocess
   return numpy.int32(_2)
  def __allocblock_alt_I(self,_t__0):
    return self.__allocblock_I(numpy.int32(__0))
  def __allocblock_I(self,_0):
   _1=int((self.__next).shape[0])
   if (self.__nfree < _0): # src/fusion/LinkedList.monty:117:12-23
    _2=(_0 - self.__nfree)
    if (_2 < _1): # src/fusion/LinkedList.monty:119:14-26
     _2 = _1
    self.__recap_I((_2 + _1))
   _3=self.__first_free
   _4=_3
   _4 = fragments._c_closure_638(_4,self.__next,_0) # src/fusion/LinkedList.monty:125:8-126:24
   _4 = numpy.int32(_4) # postprocess
   self.__first_free = self.__next[_4]
   if (self.__first_free < 0): # src/fusion/LinkedList.monty:129:12-26
    self.__last_free = (- 1)
   else:
    self.__prev[self.__first_free] = (- 1)
   self.__next[_4] = self.__first_used
   if (self.__first_used >= 0): # src/fusion/LinkedList.monty:134:12-27
    self.__prev[self.__first_used] = _4
   self.__first_used = _3
   self.__nfree -= _0
   return numpy.int32(_3)
  def __recap_alt_I(self,_t__0):
    return self.__recap_I(numpy.int32(__0))
  def __recap_I(self,_0):
   _1=int((self.__next).shape[0])
   if (_0 > _1): # src/fusion/LinkedList.monty:90:12-22
    self.__next = mosek.fusion.CommonTools._resize__3II(self.__next,_0)
    self.__prev = mosek.fusion.CommonTools._resize__3II(self.__prev,_0)
    fragments._c_closure_639(_1,_0,self.__next,self.__prev) # src/fusion/LinkedList.monty:94:10-97:11
    self.__next[(_0 - 1)] = (- 1)
    self.__prev[_1] = self.__last_free
    if (self.__last_free < 0): # src/fusion/LinkedList.monty:102:14-27
     self.__first_free = _1
    else:
     self.__next[self.__last_free] = _1
    self.__last_free = (_0 - 1)
    self.__nfree += (_0 - _1)
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(int((self.__next).shape[0]))
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   _0=numpy.zeros((int((self.__next).shape[0]),), dtype=numpy.dtype(numpy.bool))
   _1=self.__first_used
   while (_1 >= 0):
    _0[_1] = True
    _1 = self.__next[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:23:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("used list/next is inconsistent")
   _1 = self.__first_free
   _2=0
   while (_1 >= 0):
    _2 += 1
    _0[_1] = True
    _1 = self.__next[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:33:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("free list/next is inconsistent")
   if (_2!=self.__nfree): # src/fusion/LinkedList.monty:36:12-22
    raise mosek_fusion_UnexpectedError._ctor_S("free next list did not contain nfree elements")
   for _3 in range(0,int((_0).shape[0])):
    if (not _0[_1]): # src/fusion/LinkedList.monty:41:14-26
     raise mosek_fusion_UnexpectedError._ctor_S("elements missing from used+free list")
   for _4 in range(0,int((_0).shape[0])):
    _0[_4] = False
   _1 = self.__last_free
   _5=0
   while (_1 >= 0):
    _5 += 1
    _0[_1] = True
    _1 = self.__prev[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:51:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("prev list is inconsistent")
   if (_5!=self.__nfree): # src/fusion/LinkedList.monty:55:12-22
    raise mosek_fusion_UnexpectedError._ctor_S("free prev list did not contain nfree elements")
   return (True)
 return LinkedInts
mosek_fusion_LinkedInts=__mk_mosek_fusion_LinkedInts()
del __mk_mosek_fusion_LinkedInts
#BEFORE CLASS
def __mk_mosek_fusion_Parameters():
 class Parameters(object):
  @staticmethod
  def setParameter(*args):
    if False: pass
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SD(*args)
    else:
      raise ValueError('Invalid argument list setParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,string)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,int32)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,double)')
  def __repr__(self): return 'mosek.fusion.Parameters'
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SD(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,numpy.float64(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,_2):
   if False: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4359:6-11
    pass
   elif (_1=="autoUpdateSolInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4360:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4362:10-41
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4364:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4366:8-35
     _3=_2
     if (0 <= _3): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4369:10-16
      _0._task_1put_1param_SD("MSK_IPAR_NUM_THREADS",_3)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   elif (_1=="intpntMultiThread"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4379:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
   if (_1=="mtSpincount"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4381:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4383:8-35
     _4=_2
     if ((0 <= _4) and (_4 <= 1000000000)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4386:10-36
      _0._task_1put_1param_SD("MSK_IPAR_MT_SPINCOUNT",_4)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4396:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4398:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4400:8-35
     _5=_2
     if (0 <= _5): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4403:10-16
      _0._task_1put_1param_SD("MSK_IPAR_BI_MAX_ITERATIONS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4413:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4415:8-35
     _6=_2
     if (0 <= _6): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4418:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4428:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4430:8-35
     _7=_2
     if (0 <= _7): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4433:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4443:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4445:8-35
     _8=_2
     if (0 <= _8): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4448:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_RESPONSE",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   elif (_1=="logLocalInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4458:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
   if (_1=="logBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4460:6-21
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4462:8-35
     _9=_2
     if (0 <= _9): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4465:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI",_9)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4475:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4477:8-35
     _10=_2
     if (0 <= _10): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4480:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI_FREQ",_10)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4490:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4492:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4494:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4496:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4498:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4500:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4502:8-35
     _11=_2
     if (0 <= _11): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4505:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INTPNT",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4515:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4517:8-35
     _12=_2
     if (0 <= _12): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4520:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_ITERATIONS",_12)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4530:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4532:8-35
     _13=_2
     if (0 <= _13): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4535:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_OFF_COL_TRH",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4545:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   if (_1=="intpntOrderGpNumSeeds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4547:6-37
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4549:8-35
     _14=_2
     if (0 <= _14): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4552:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_14)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   elif (_1=="intpntBasis"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4562:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4564:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4566:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4568:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4570:8-35
     _15=_2
     if ((- 1) <= _15): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4573:10-17
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4583:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4585:6-29
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4587:8-35
     _16=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4590:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LEVEL",_16)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4600:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4602:8-35
     _17=_2
     if (0 <= _17): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4605:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_PRESOLVE",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4615:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveMaxNumPass"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4617:6-34
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4619:8-35
     _18=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4622:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_18)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4632:6-45
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4634:8-35
     _19=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4637:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4647:6-41
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4649:8-35
     _20=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4652:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4662:6-30
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4664:8-35
     _21=_2
     if (0 <= _21): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4667:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_CRASH",_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4677:6-22
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4679:8-35
     _22=_2
     if (0 <= _22): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4682:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM",_22)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4692:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4694:8-35
     _23=_2
     if (0 <= _23): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4697:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_MINOR",_23)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4707:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4709:8-35
     _24=_2
     if (0 <= _24): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4712:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_FREQ",_24)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4722:6-42
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4724:8-35
     _25=_2
     if ((0 <= _25) and (_25 <= 100)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4727:10-29
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_25)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4737:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4739:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4741:8-35
     _26=_2
     if ((0 <= _26) and (_26 <= 100)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4744:10-29
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_26)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4754:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4756:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4758:8-35
     _27=_2
     if (0 <= _27): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4761:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_ITERATIONS",_27)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4771:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4773:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4775:8-35
     _28=_2
     if (0 <= _28): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4778:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_REFACTOR_FREQ",_28)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4788:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4790:8-35
     _29=_2
     if ((0 <= _29) and (_29 <= 32749)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4793:10-31
      _0._task_1put_1param_SD("MSK_IPAR_SIM_SEED",_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   elif (_1=="mioMode"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4803:10-27
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4805:6-22
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4807:8-35
     _30=_2
     if (0 <= _30): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4810:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO",_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4820:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4822:8-35
     _31=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4825:10-14
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO_FREQ",_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4835:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4837:8-35
     _32=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4840:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_RELAXS",_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4850:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4852:8-35
     _33=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4855:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_33)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4865:6-38
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4867:8-35
     _34=_2
     if (0 <= _34): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4870:10-16
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4880:6-34
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4882:8-35
     _35=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4885:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_35)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4895:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4897:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4899:8-35
     _36=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4902:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_HEURISTIC_LEVEL",_36)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4912:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4914:8-35
     _37=_2
     if (((- 1) <= _37) and (_37 <= 3)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4917:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_PROBING_LEVEL",_37)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4927:6-36
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4929:8-35
     _38=_2
     if (((- 1) <= _38) and (_38 <= 1)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4932:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_38)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4942:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4944:8-35
     _39=_2
     if (((- 1) <= _39) and (_39 <= 2)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4947:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_39)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4957:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4959:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4961:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4963:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="mioPropagateObjectiveConstraint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4965:10-51
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
   if (_1=="mioSeed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4967:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4969:8-35
     _40=_2
     if (0 <= _40): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4972:10-16
      _0._task_1put_1param_SD("MSK_IPAR_MIO_SEED",_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   elif (_1=="mioConicOuterApproximation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4982:10-46
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
   elif (_1=="writeLpQuotedNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4984:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
   if (_1=="writeLpLineWidth"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4986:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4988:8-35
     _41=_2
     if (40 <= _41): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4991:10-17
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_LINE_WIDTH",_41)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5001:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5003:8-35
     _42=_2
     if (0 <= _42): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5006:10-16
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_42)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   elif (_1=="writeLpFullObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5016:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   if (_1=="logInfeasAna"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5018:6-28
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5020:8-35
     _43=_2
     if (0 <= _43): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5023:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INFEAS_ANA",_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5033:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5035:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5037:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5039:8-35
     _44=_2
     if ((0 <= _44) and (_44 <= 1000000)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5042:10-33
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_PAUSE_TIME",_44)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5052:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5054:6-19
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5056:8-35
     _45=_2
     if (0 <= _45): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5059:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG",_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5069:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5071:8-35
     _46=_2
     if (0 <= _46): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5074:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_EXPAND",_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5084:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5086:8-35
     _47=_2
     if (0 <= _47): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5089:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_FILE",_47)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5099:6-24
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5101:8-35
     _48=_2
     if (0 <= _48): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5104:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_ORDER",_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5114:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5116:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5118:6-39
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5120:8-35
     _49=_2
     if ((0 <= _49) and (_49 <= 10)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5123:10-28
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_49)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5133:6-37
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5135:8-35
     _50=_2
     if ((0 <= _50) and (_50 <= 10)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5138:10-28
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5148:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5150:8-35
     _51=_2
     if (0 <= _51): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5153:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_51)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5163:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5165:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5167:10-28
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5169:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5171:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5173:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5175:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5177:6-28
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5179:8-35
     _52=_2
     if (0 <= _52): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5182:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_CRASH",_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5192:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5194:6-42
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5196:8-35
     _53=_2
     if (((- 1) <= _53) and (_53 <= 1)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5199:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_53)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5209:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5211:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5213:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5215:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5217:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   if (_1=="presolveLindepRelWorkTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5219:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5221:8-35
     _54=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5224:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_54)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5234:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5236:8-35
     _55=_2
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5239:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_55)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5249:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5251:10-43
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5253:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5255:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5257:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5259:8-35
     _56=_2
     if ((- 1) <= _56): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5262:10-17
      _0._task_1put_1param_SD("MSK_IPAR_MIO_RINS_MAX_NODES",_56)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5272:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5274:8-35
     _57=_2
     if (((- 1) <= _57) and (_57 <= 2)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5277:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_FEASPUMP_LEVEL",_57)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_1=="optimizerMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5287:6-32
    _58=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5290:8-12
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5297:6-27
    _59=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5300:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5307:6-27
    _60=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5310:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5317:6-36
    _61=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5320:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5327:6-36
    _62=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5330:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5337:6-31
    _63=_2
    if (1.000000e-14 <= _63): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5340:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5347:6-33
    _64=_2
    if ((0.000000e+00 <= _64) and (_64 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5350:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5357:6-30
    _65=_2
    if ((1.000000e-06 <= _65) and (_65 <= 9.999990e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5360:8-47
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5367:6-32
    _66=_2
    if ((1.000000e-04 <= _66) and (_66 <= 9.999990e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5370:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5377:6-29
    _67=_2
    if ((0.000000e+00 <= _67) and (_67 <= 9.999000e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5380:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5387:6-30
    _68=_2
    if ((0.000000e+00 <= _68) and (_68 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5390:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5397:6-30
    _69=_2
    if ((0.000000e+00 <= _69) and (_69 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5400:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5407:6-30
    _70=_2
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5410:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5417:6-31
    _71=_2
    if ((0.000000e+00 <= _71) and (_71 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5420:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5427:6-33
    _72=_2
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5430:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5437:6-32
    _73=_2
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5440:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5447:6-32
    _74=_2
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5450:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5457:6-32
    _75=_2
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5460:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5467:6-34
    _76=_2
    if (1.000000e+00 <= _76): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5470:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5477:6-33
    _77=_2
    if ((0.000000e+00 <= _77) and (_77 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5480:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5487:6-30
    _78=_2
    if (1.000000e-04 <= _78): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5490:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5497:6-30
    _79=_2
    if (1.000000e-04 <= _79): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5500:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5507:6-26
    _80=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5510:8-12
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5517:6-30
    _81=_2
    if (1.000000e-15 <= _81): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5520:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5527:6-28
    _82=_2
    if (0.000000e+00 <= _82): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5530:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5537:6-28
    _83=_2
    if (0.000000e+00 <= _83): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5540:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5547:6-33
    _84=_2
    if (1.000000e-09 <= _84): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5550:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5557:6-25
    _85=_2
    if (1.000000e-09 <= _85): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5560:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5567:6-25
    _86=_2
    if (1.000000e-09 <= _86): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5570:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5577:6-28
    _87=_2
    if (0.000000e+00 <= _87): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5580:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5587:6-28
    _88=_2
    if (0.000000e+00 <= _88): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5590:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5597:6-28
    _89=_2
    if (0.000000e+00 <= _89): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5600:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5607:6-30
    _90=_2
    if (1.000000e-15 <= _90): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5610:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5617:6-36
    _91=_2
    if (0.000000e+00 <= _91): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5620:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5627:6-36
    _92=_2
    if (0.000000e+00 <= _92): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5630:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5637:6-32
    _93=_2
    if (1.000000e-12 <= _93): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5640:8-25
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5647:6-26
    _94=_2
    if ((1.000000e-09 <= _94) and (_94 <= 1.000000e-03)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5650:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5657:6-45
    _95=_2
    if ((0.000000e+00 <= _95) and (_95 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5660:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   elif (_1=="dataFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5667:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (dataFileName)")
   elif (_1=="basSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5669:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basSolFileName)")
   elif (_1=="itrSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5671:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (itrSolFileName)")
   elif (_1=="intSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5673:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intSolFileName)")
   elif (_1=="writeLpGenVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5675:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpGenVarName)")
   elif (_1=="remoteAccessToken"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:5677:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteAccessToken)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SI(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,numpy.int32(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,_2):
   if False: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3309:6-11
    pass
   elif (_1=="autoUpdateSolInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3310:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3312:10-41
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3314:6-26
    _3=_2
    if (0 <= _3): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3317:8-14
     _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_3)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   elif (_1=="intpntMultiThread"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3324:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
   if (_1=="mtSpincount"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3326:6-27
    _4=_2
    if ((0 <= _4) and (_4 <= 1000000000)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3329:8-34
     _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_4)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3336:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3338:6-31
    _5=_2
    if (0 <= _5): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3341:8-14
     _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_5)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3348:6-35
    _6=_2
    if (0 <= _6): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3351:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3358:6-31
    _7=_2
    if (0 <= _7): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3361:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3368:6-27
    _8=_2
    if (0 <= _8): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3371:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_8)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   elif (_1=="logLocalInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3378:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
   if (_1=="logBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3380:6-21
    _9=_2
    if (0 <= _9): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3383:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_9)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3390:6-25
    _10=_2
    if (0 <= _10): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3393:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_10)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3400:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3402:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3404:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3406:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3408:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3410:6-25
    _11=_2
    if (0 <= _11): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3413:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_11)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3420:6-35
    _12=_2
    if (0 <= _12): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3423:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_12)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3430:6-31
    _13=_2
    if (0 <= _13): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3433:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_13)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3440:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   if (_1=="intpntOrderGpNumSeeds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3442:6-37
    _14=_2
    if (0 <= _14): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3445:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_14)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   elif (_1=="intpntBasis"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3452:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3454:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3456:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3458:6-31
    _15=_2
    if ((- 1) <= _15): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3461:8-15
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3468:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3470:6-29
    _16=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3473:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_16)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3480:6-27
    _17=_2
    if (0 <= _17): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3483:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_17)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3490:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveMaxNumPass"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3492:6-34
    _18=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3495:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_18)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3502:6-45
    _19=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3505:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_19)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3512:6-41
    _20=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3515:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_20)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3522:6-30
    _21=_2
    if (0 <= _21): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3525:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_21)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3532:6-22
    _22=_2
    if (0 <= _22): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3535:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_22)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3542:6-27
    _23=_2
    if (0 <= _23): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3545:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_23)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3552:6-26
    _24=_2
    if (0 <= _24): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3555:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_24)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3562:6-42
    _25=_2
    if ((0 <= _25) and (_25 <= 100)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3565:8-27
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_25)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3572:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3574:6-40
    _26=_2
    if ((0 <= _26) and (_26 <= 100)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3577:8-27
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_26)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3584:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3586:6-32
    _27=_2
    if (0 <= _27): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3589:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_27)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3596:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3598:6-31
    _28=_2
    if (0 <= _28): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3601:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_28)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3608:6-23
    _29=_2
    if ((0 <= _29) and (_29 <= 32749)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3611:8-29
     _0._task_1put_1param_SI("MSK_IPAR_SIM_SEED",_29)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   elif (_1=="mioMode"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3618:10-27
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3620:6-22
    _30=_2
    if (0 <= _30): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3623:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_30)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3630:6-26
    _31=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3633:8-12
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_31)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3640:6-31
    _32=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3643:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_32)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3650:6-33
    _33=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3653:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_33)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3660:6-38
    _34=_2
    if (0 <= _34): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3663:8-14
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_34)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3670:6-34
    _35=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3673:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_35)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3680:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3682:6-33
    _36=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3685:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_36)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3692:6-31
    _37=_2
    if (((- 1) <= _37) and (_37 <= 3)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3695:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_37)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3702:6-36
    _38=_2
    if (((- 1) <= _38) and (_38 <= 1)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3705:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_38)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3712:6-35
    _39=_2
    if (((- 1) <= _39) and (_39 <= 2)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3715:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_39)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3722:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3724:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3726:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3728:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="mioPropagateObjectiveConstraint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3730:10-51
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
   if (_1=="mioSeed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3732:6-23
    _40=_2
    if (0 <= _40): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3735:8-14
     _0._task_1put_1param_SI("MSK_IPAR_MIO_SEED",_40)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   elif (_1=="mioConicOuterApproximation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3742:10-46
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
   elif (_1=="writeLpQuotedNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3744:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
   if (_1=="writeLpLineWidth"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3746:6-32
    _41=_2
    if (40 <= _41): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3749:8-15
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_41)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3756:6-35
    _42=_2
    if (0 <= _42): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3759:8-14
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_42)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   elif (_1=="writeLpFullObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3766:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   if (_1=="logInfeasAna"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3768:6-28
    _43=_2
    if (0 <= _43): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3771:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_43)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3778:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3780:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3782:6-32
    _44=_2
    if ((0 <= _44) and (_44 <= 1000000)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3785:8-31
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_44)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3792:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3794:6-19
    _45=_2
    if (0 <= _45): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3797:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG",_45)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3804:6-25
    _46=_2
    if (0 <= _46): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3807:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_46)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3814:6-23
    _47=_2
    if (0 <= _47): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3817:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_47)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3824:6-24
    _48=_2
    if (0 <= _48): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3827:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_48)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3834:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3836:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3838:6-39
    _49=_2
    if ((0 <= _49) and (_49 <= 10)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3841:8-26
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_49)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3848:6-37
    _50=_2
    if ((0 <= _50) and (_50 <= 10)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3851:8-26
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_50)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3858:6-33
    _51=_2
    if (0 <= _51): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3861:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_51)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3868:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3870:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3872:10-28
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3874:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3876:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3878:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3880:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3882:6-28
    _52=_2
    if (0 <= _52): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3885:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_52)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3892:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3894:6-42
    _53=_2
    if (((- 1) <= _53) and (_53 <= 1)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3897:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_53)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3904:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3906:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3908:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3910:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3912:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   if (_1=="presolveLindepRelWorkTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3914:6-40
    _54=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3917:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_54)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3924:6-40
    _55=_2
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3927:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_55)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3934:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3936:10-43
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3938:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3940:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3942:6-31
    _56=_2
    if ((- 1) <= _56): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3945:8-15
     _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_56)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3952:6-32
    _57=_2
    if (((- 1) <= _57) and (_57 <= 2)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3955:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",_57)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_1=="optimizerMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3962:6-32
    _58=numpy.float64(_2)
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3965:8-12
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3972:6-27
    _59=numpy.float64(_2)
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3975:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3982:6-27
    _60=numpy.float64(_2)
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3985:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3992:6-36
    _61=numpy.float64(_2)
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3995:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4002:6-36
    _62=numpy.float64(_2)
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4005:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4012:6-31
    _63=numpy.float64(_2)
    if (1.000000e-14 <= _63): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4015:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4022:6-33
    _64=numpy.float64(_2)
    if ((0.000000e+00 <= _64) and (_64 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4025:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4032:6-30
    _65=numpy.float64(_2)
    if ((1.000000e-06 <= _65) and (_65 <= 9.999990e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4035:8-47
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4042:6-32
    _66=numpy.float64(_2)
    if ((1.000000e-04 <= _66) and (_66 <= 9.999990e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4045:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4052:6-29
    _67=numpy.float64(_2)
    if ((0.000000e+00 <= _67) and (_67 <= 9.999000e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4055:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4062:6-30
    _68=numpy.float64(_2)
    if ((0.000000e+00 <= _68) and (_68 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4065:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4072:6-30
    _69=numpy.float64(_2)
    if ((0.000000e+00 <= _69) and (_69 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4075:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4082:6-30
    _70=numpy.float64(_2)
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4085:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4092:6-31
    _71=numpy.float64(_2)
    if ((0.000000e+00 <= _71) and (_71 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4095:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4102:6-33
    _72=numpy.float64(_2)
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4105:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4112:6-32
    _73=numpy.float64(_2)
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4115:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4122:6-32
    _74=numpy.float64(_2)
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4125:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4132:6-32
    _75=numpy.float64(_2)
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4135:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4142:6-34
    _76=numpy.float64(_2)
    if (1.000000e+00 <= _76): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4145:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4152:6-33
    _77=numpy.float64(_2)
    if ((0.000000e+00 <= _77) and (_77 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4155:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4162:6-30
    _78=numpy.float64(_2)
    if (1.000000e-04 <= _78): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4165:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4172:6-30
    _79=numpy.float64(_2)
    if (1.000000e-04 <= _79): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4175:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4182:6-26
    _80=numpy.float64(_2)
    if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4185:8-12
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4192:6-30
    _81=numpy.float64(_2)
    if (1.000000e-15 <= _81): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4195:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4202:6-28
    _82=numpy.float64(_2)
    if (0.000000e+00 <= _82): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4205:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4212:6-28
    _83=numpy.float64(_2)
    if (0.000000e+00 <= _83): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4215:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4222:6-33
    _84=numpy.float64(_2)
    if (1.000000e-09 <= _84): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4225:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4232:6-25
    _85=numpy.float64(_2)
    if (1.000000e-09 <= _85): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4235:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4242:6-25
    _86=numpy.float64(_2)
    if (1.000000e-09 <= _86): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4245:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4252:6-28
    _87=numpy.float64(_2)
    if (0.000000e+00 <= _87): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4255:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4262:6-28
    _88=numpy.float64(_2)
    if (0.000000e+00 <= _88): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4265:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4272:6-28
    _89=numpy.float64(_2)
    if (0.000000e+00 <= _89): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4275:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4282:6-30
    _90=numpy.float64(_2)
    if (1.000000e-15 <= _90): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4285:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4292:6-36
    _91=numpy.float64(_2)
    if (0.000000e+00 <= _91): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4295:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4302:6-36
    _92=numpy.float64(_2)
    if (0.000000e+00 <= _92): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4305:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4312:6-32
    _93=numpy.float64(_2)
    if (1.000000e-12 <= _93): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4315:8-25
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4322:6-26
    _94=numpy.float64(_2)
    if ((1.000000e-09 <= _94) and (_94 <= 1.000000e-03)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4325:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4332:6-45
    _95=numpy.float64(_2)
    if ((0.000000e+00 <= _95) and (_95 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4335:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   elif (_1=="dataFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4342:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (dataFileName)")
   elif (_1=="basSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4344:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basSolFileName)")
   elif (_1=="itrSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4346:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (itrSolFileName)")
   elif (_1=="intSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4348:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intSolFileName)")
   elif (_1=="writeLpGenVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4350:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpGenVarName)")
   elif (_1=="remoteAccessToken"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:4352:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteAccessToken)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_S__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_S__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SS(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2)
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2):
   if False: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1673:6-11
    pass
   if (_1=="autoUpdateSolInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1674:6-33
    _3=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_3 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1677:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
    _0._task_1put_1param_SI("MSK_IPAR_AUTO_UPDATE_SOL_INFO",_3)
    return 
   if (_1=="removeUnusedSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1682:6-37
    _4=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_4 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1685:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
    _0._task_1put_1param_SI("MSK_IPAR_REMOVE_UNUSED_SOLUTIONS",_4)
    return 
   if (_1=="numThreads"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1690:6-26
    try:
     _5=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _5): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1695:10-16
      _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    except mosek_fusion_ValueConversionError as _6:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_1=="intpntMultiThread"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1702:6-33
    _7=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_7 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1705:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMultiThread)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MULTI_THREAD",_7)
    return 
   if (_1=="mtSpincount"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1710:6-27
    try:
     _8=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _8) and (_8 <= 1000000000)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1715:10-36
      _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    except mosek_fusion_ValueConversionError as _9:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   if (_1=="optimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1722:6-25
    _10=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_10 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1725:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_OPTIMIZER",_10)
    return 
   if (_1=="biMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1730:6-31
    try:
     _11=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _11): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1735:10-16
      _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    except mosek_fusion_ValueConversionError as _12:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1742:6-35
    try:
     _13=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _13): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1747:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    except mosek_fusion_ValueConversionError as _14:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1754:6-31
    try:
     _15=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _15): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1759:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    except mosek_fusion_ValueConversionError as _16:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1766:6-27
    try:
     _17=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _17): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1771:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    except mosek_fusion_ValueConversionError as _18:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logLocalInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1778:6-28
    _19=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_19 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1781:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
    _0._task_1put_1param_SI("MSK_IPAR_LOG_LOCAL_INFO",_19)
    return 
   if (_1=="logBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1786:6-21
    try:
     _20=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _20): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1791:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    except mosek_fusion_ValueConversionError as _21:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1798:6-25
    try:
     _22=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _22): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1803:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_22)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    except mosek_fusion_ValueConversionError as _23:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   if (_1=="biCleanOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1810:6-32
    _24=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_24 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1813:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_CLEAN_OPTIMIZER",_24)
    return 
   if (_1=="intpntStartingPoint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1818:6-35
    _25=mosek.fusion.Parameters.__string_1to_1startpointtype_1value_S(_2)
    if (_25 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1821:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_STARTING_POINT",_25)
    return 
   if (_1=="intpntDiffStep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1826:6-30
    _26=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_26 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1829:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_DIFF_STEP",_26)
    return 
   if (_1=="intpntScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1834:6-29
    _27=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_27 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1837:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SCALING",_27)
    return 
   if (_1=="intpntSolveForm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1842:6-31
    _28=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_28 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1845:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SOLVE_FORM",_28)
    return 
   if (_1=="logIntpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1850:6-25
    try:
     _29=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _29): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1855:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    except mosek_fusion_ValueConversionError as _30:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1862:6-35
    try:
     _31=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _31): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1867:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    except mosek_fusion_ValueConversionError as _32:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1874:6-31
    try:
     _33=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _33): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1879:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_33)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    except mosek_fusion_ValueConversionError as _34:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   if (_1=="intpntOrderMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1886:6-33
    _35=mosek.fusion.Parameters.__string_1to_1orderingtype_1value_S(_2)
    if (_35 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1889:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_METHOD",_35)
    return 
   if (_1=="intpntOrderGpNumSeeds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1894:6-37
    try:
     _36=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _36): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1899:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_36)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
    except mosek_fusion_ValueConversionError as _37:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   if (_1=="intpntBasis"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1906:6-27
    _38=mosek.fusion.Parameters.__string_1to_1basindtype_1value_S(_2)
    if (_38 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1909:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_BASIS",_38)
    return 
   if (_1=="biIgnoreMaxIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1914:6-31
    _39=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_39 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1917:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_MAX_ITER",_39)
    return 
   if (_1=="biIgnoreNumError"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1922:6-32
    _40=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_40 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1925:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_NUM_ERROR",_40)
    return 
   if (_1=="intpntMaxNumCor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1930:6-31
    try:
     _41=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _41): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1935:10-17
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_41)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    except mosek_fusion_ValueConversionError as _42:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   if (_1=="presolveUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1942:6-27
    _43=mosek.fusion.Parameters.__string_1to_1presolvemode_1value_S(_2)
    if (_43 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1945:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_USE",_43)
    return 
   if (_1=="presolveLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1950:6-29
    try:
     _44=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1955:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_44)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    except mosek_fusion_ValueConversionError as _45:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1962:6-27
    try:
     _46=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _46): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1967:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    except mosek_fusion_ValueConversionError as _47:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   if (_1=="presolveLindepUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1974:6-33
    _48=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_48 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1977:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_USE",_48)
    return 
   if (_1=="presolveMaxNumPass"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1982:6-34
    try:
     _49=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1987:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_49)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
    except mosek_fusion_ValueConversionError as _50:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1994:6-45
    try:
     _51=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1999:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_51)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    except mosek_fusion_ValueConversionError as _52:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2006:6-41
    try:
     _53=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2011:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_53)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    except mosek_fusion_ValueConversionError as _54:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2018:6-30
    try:
     _55=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _55): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2023:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_55)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    except mosek_fusion_ValueConversionError as _56:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2030:6-22
    try:
     _57=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _57): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2035:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_57)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    except mosek_fusion_ValueConversionError as _58:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2042:6-27
    try:
     _59=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _59): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2047:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_59)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    except mosek_fusion_ValueConversionError as _60:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2054:6-26
    try:
     _61=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _61): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2059:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_61)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    except mosek_fusion_ValueConversionError as _62:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2066:6-42
    try:
     _63=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _63) and (_63 <= 100)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2071:10-29
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_63)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    except mosek_fusion_ValueConversionError as _64:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   if (_1=="simPrimalSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2078:6-34
    _65=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_65 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2081:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_SELECTION",_65)
    return 
   if (_1=="simDualRestrictSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2086:6-40
    try:
     _66=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _66) and (_66 <= 100)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2091:10-29
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_66)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    except mosek_fusion_ValueConversionError as _67:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   if (_1=="simDualSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2098:6-32
    _68=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_68 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2101:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_SELECTION",_68)
    return 
   if (_1=="simMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2106:6-32
    try:
     _69=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _69): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2111:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_69)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    except mosek_fusion_ValueConversionError as _70:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   if (_1=="simHotstartLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2118:6-29
    _71=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_71 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2121:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART_LU",_71)
    return 
   if (_1=="simRefactorFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2126:6-31
    try:
     _72=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _72): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2131:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_72)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    except mosek_fusion_ValueConversionError as _73:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2138:6-23
    try:
     _74=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _74) and (_74 <= 32749)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2143:10-31
      _0._task_1put_1param_SI("MSK_IPAR_SIM_SEED",_74)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
    except mosek_fusion_ValueConversionError as _75:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   if (_1=="mioMode"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2150:6-23
    _76=mosek.fusion.Parameters.__string_1to_1miomode_1value_S(_2)
    if (_76 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2153:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_MODE",_76)
    return 
   if (_1=="logMio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2158:6-22
    try:
     _77=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _77): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2163:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_77)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    except mosek_fusion_ValueConversionError as _78:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2170:6-26
    try:
     _79=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2175:10-14
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_79)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    except mosek_fusion_ValueConversionError as _80:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2182:6-31
    try:
     _81=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2187:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_81)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    except mosek_fusion_ValueConversionError as _82:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2194:6-33
    try:
     _83=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2199:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_83)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    except mosek_fusion_ValueConversionError as _84:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2206:6-38
    try:
     _85=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _85): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2211:10-16
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_85)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
    except mosek_fusion_ValueConversionError as _86:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2218:6-34
    try:
     _87=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2223:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_87)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    except mosek_fusion_ValueConversionError as _88:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   if (_1=="mioNodeSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2230:6-32
    _89=mosek.fusion.Parameters.__string_1to_1mionodeseltype_1value_S(_2)
    if (_89 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2233:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_SELECTION",_89)
    return 
   if (_1=="mioHeuristicLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2238:6-33
    try:
     _90=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2243:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_90)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    except mosek_fusion_ValueConversionError as _91:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2250:6-31
    try:
     _92=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _92) and (_92 <= 3)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2255:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_92)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    except mosek_fusion_ValueConversionError as _93:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2262:6-36
    try:
     _94=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _94) and (_94 <= 1)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2267:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_94)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    except mosek_fusion_ValueConversionError as _95:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2274:6-35
    try:
     _96=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _96) and (_96 <= 2)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2279:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_96)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    except mosek_fusion_ValueConversionError as _97:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   if (_1=="mioBranchDir"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2286:6-28
    _98=mosek.fusion.Parameters.__string_1to_1branchdir_1value_S(_2)
    if (_98 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2289:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_DIR",_98)
    return 
   if (_1=="mioRootOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2294:6-32
    _99=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_99 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2297:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_OPTIMIZER",_99)
    return 
   if (_1=="mioNodeOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2302:6-32
    _100=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_100 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2305:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_OPTIMIZER",_100)
    return 
   if (_1=="mioPerspectiveReformulate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2310:6-41
    _101=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_101 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2313:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE",_101)
    return 
   if (_1=="mioPropagateObjectiveConstraint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2318:6-47
    _102=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_102 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2321:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT",_102)
    return 
   if (_1=="mioSeed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2326:6-23
    try:
     _103=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _103): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2331:10-16
      _0._task_1put_1param_SI("MSK_IPAR_MIO_SEED",_103)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
    except mosek_fusion_ValueConversionError as _104:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   if (_1=="mioConicOuterApproximation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2338:6-42
    _105=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_105 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2341:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION",_105)
    return 
   if (_1=="writeLpQuotedNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2346:6-34
    _106=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_106 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2349:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpQuotedNames)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_QUOTED_NAMES",_106)
    return 
   if (_1=="writeLpLineWidth"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2354:6-32
    try:
     _107=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (40 <= _107): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2359:10-17
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_107)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    except mosek_fusion_ValueConversionError as _108:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpTermsPerLine"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2366:6-35
    try:
     _109=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _109): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2371:10-16
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_TERMS_PER_LINE",_109)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
    except mosek_fusion_ValueConversionError as _110:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpTermsPerLine)")
   if (_1=="writeLpFullObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2378:6-30
    _111=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_111 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2381:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_FULL_OBJ",_111)
    return 
   if (_1=="logInfeasAna"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2386:6-28
    try:
     _112=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _112): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2391:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_112)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    except mosek_fusion_ValueConversionError as _113:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   if (_1=="licenseWait"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2398:6-27
    _114=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_114 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2401:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_WAIT",_114)
    return 
   if (_1=="licenseSuppressExpireWrns"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2406:6-41
    _115=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_115 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2409:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS",_115)
    return 
   if (_1=="licensePauseTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2414:6-32
    try:
     _116=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _116) and (_116 <= 1000000)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2419:10-33
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_116)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    except mosek_fusion_ValueConversionError as _117:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   if (_1=="licenseDebug"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2426:6-28
    _118=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_118 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2429:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_DEBUG",_118)
    return 
   if (_1=="log"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2434:6-19
    try:
     _119=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _119): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2439:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG",_119)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    except mosek_fusion_ValueConversionError as _120:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2446:6-25
    try:
     _121=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _121): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2451:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_121)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    except mosek_fusion_ValueConversionError as _122:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2458:6-23
    try:
     _123=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _123): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2463:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_123)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    except mosek_fusion_ValueConversionError as _124:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2470:6-24
    try:
     _125=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _125): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2475:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_125)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    except mosek_fusion_ValueConversionError as _126:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   if (_1=="simScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2482:6-26
    _127=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_127 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2485:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING",_127)
    return 
   if (_1=="simScalingMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2490:6-32
    _128=mosek.fusion.Parameters.__string_1to_1scalingmethod_1value_S(_2)
    if (_128 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2493:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING_METHOD",_128)
    return 
   if (_1=="simPrimalPhaseoneMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2498:6-39
    try:
     _129=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _129) and (_129 <= 10)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2503:10-28
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_129)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _130:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2510:6-37
    try:
     _131=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _131) and (_131 <= 10)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2515:10-28
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_131)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _132:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2522:6-33
    try:
     _133=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _133): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2527:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_133)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    except mosek_fusion_ValueConversionError as _134:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   if (_1=="simHotstart"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2534:6-27
    _135=mosek.fusion.Parameters.__string_1to_1simhotstart_1value_S(_2)
    if (_135 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2537:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART",_135)
    return 
   if (_1=="simBasisFactorUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2542:6-33
    _136=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_136 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2545:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_BASIS_FACTOR_USE",_136)
    return 
   if (_1=="simDegen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2550:6-24
    _137=mosek.fusion.Parameters.__string_1to_1simdegen_1value_S(_2)
    if (_137 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2553:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DEGEN",_137)
    return 
   if (_1=="simReformulation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2558:6-32
    _138=mosek.fusion.Parameters.__string_1to_1simreform_1value_S(_2)
    if (_138 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2561:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_REFORMULATION",_138)
    return 
   if (_1=="simExploitDupvec"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2566:6-32
    _139=mosek.fusion.Parameters.__string_1to_1simdupvec_1value_S(_2)
    if (_139 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2569:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_EXPLOIT_DUPVEC",_139)
    return 
   if (_1=="simSaveLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2574:6-25
    _140=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_140 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2577:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SAVE_LU",_140)
    return 
   if (_1=="simNonSingular"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2582:6-30
    _141=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_141 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2585:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_NON_SINGULAR",_141)
    return 
   if (_1=="simDualCrash"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2590:6-28
    try:
     _142=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _142): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2595:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_142)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    except mosek_fusion_ValueConversionError as _143:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   if (_1=="infeasPreferPrimal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2602:6-34
    _144=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_144 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2605:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
    _0._task_1put_1param_SI("MSK_IPAR_INFEAS_PREFER_PRIMAL",_144)
    return 
   if (_1=="mioRootRepeatPresolveLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2610:6-42
    try:
     _145=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _145) and (_145 <= 1)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2615:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_145)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    except mosek_fusion_ValueConversionError as _146:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   if (_1=="mioCutCmir"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2622:6-26
    _147=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_147 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2625:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CMIR",_147)
    return 
   if (_1=="mioCutClique"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2630:6-28
    _148=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_148 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2633:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CLIQUE",_148)
    return 
   if (_1=="mioCutImpliedBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2638:6-34
    _149=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_149 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2641:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_IMPLIED_BOUND",_149)
    return 
   if (_1=="mioCutKnapsackCover"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2646:6-35
    _150=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_150 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2649:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_KNAPSACK_COVER",_150)
    return 
   if (_1=="mioCutGmi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2654:6-25
    _151=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_151 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2657:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_GMI",_151)
    return 
   if (_1=="presolveLindepRelWorkTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2662:6-40
    try:
     _152=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2667:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_152)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    except mosek_fusion_ValueConversionError as _153:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2674:6-40
    try:
     _154=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2679:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_154)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    except mosek_fusion_ValueConversionError as _155:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   if (_1=="cacheLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2686:6-28
    _156=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_156 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2689:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
    _0._task_1put_1param_SI("MSK_IPAR_CACHE_LICENSE",_156)
    return 
   if (_1=="intpntRegularizationUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2694:6-39
    _157=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_157 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2697:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_REGULARIZATION_USE",_157)
    return 
   if (_1=="simSolveForm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2702:6-28
    _158=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_158 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2705:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SOLVE_FORM",_158)
    return 
   if (_1=="simSwitchOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2710:6-34
    _159=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_159 < 0): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2713:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SWITCH_OPTIMIZER",_159)
    return 
   if (_1=="mioRinsMaxNodes"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2718:6-31
    try:
     _160=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _160): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2723:10-17
      _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_160)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    except mosek_fusion_ValueConversionError as _161:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2730:6-32
    try:
     _162=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _162) and (_162 <= 2)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2735:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",_162)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
    except mosek_fusion_ValueConversionError as _163:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_1=="optimizerMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2742:6-32
    try:
     _164=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2747:10-14
      _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_164)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
    except mosek_fusion_ValueConversionError as _165:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2756:6-27
    try:
     _166=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2761:10-14
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_166)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
    except mosek_fusion_ValueConversionError as _167:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2770:6-27
    try:
     _168=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2775:10-14
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_168)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
    except mosek_fusion_ValueConversionError as _169:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2784:6-36
    try:
     _170=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2789:10-14
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_170)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _171:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2798:6-36
    try:
     _172=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2803:10-14
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_172)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _173:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2812:6-31
    try:
     _174=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-14 <= _174): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2817:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_174)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
    except mosek_fusion_ValueConversionError as _175:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2826:6-33
    try:
     _176=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _176) and (_176 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2831:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_176)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
    except mosek_fusion_ValueConversionError as _177:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2840:6-30
    try:
     _178=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-06 <= _178) and (_178 <= 9.999990e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2845:10-49
      _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_178)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
    except mosek_fusion_ValueConversionError as _179:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2854:6-32
    try:
     _180=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-04 <= _180) and (_180 <= 9.999990e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2859:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_180)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
    except mosek_fusion_ValueConversionError as _181:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2868:6-29
    try:
     _182=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _182) and (_182 <= 9.999000e-01)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2873:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_182)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
    except mosek_fusion_ValueConversionError as _183:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2882:6-30
    try:
     _184=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _184) and (_184 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2887:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_184)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
    except mosek_fusion_ValueConversionError as _185:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2896:6-30
    try:
     _186=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _186) and (_186 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2901:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_186)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
    except mosek_fusion_ValueConversionError as _187:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2910:6-30
    try:
     _188=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _188) and (_188 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2915:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_188)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
    except mosek_fusion_ValueConversionError as _189:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2924:6-31
    try:
     _190=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _190) and (_190 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2929:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_190)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
    except mosek_fusion_ValueConversionError as _191:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2938:6-33
    try:
     _192=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _192) and (_192 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2943:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_192)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
    except mosek_fusion_ValueConversionError as _193:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2952:6-32
    try:
     _194=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _194) and (_194 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2957:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_194)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
    except mosek_fusion_ValueConversionError as _195:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2966:6-32
    try:
     _196=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _196) and (_196 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2971:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_196)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
    except mosek_fusion_ValueConversionError as _197:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2980:6-32
    try:
     _198=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _198) and (_198 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2985:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_198)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
    except mosek_fusion_ValueConversionError as _199:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2994:6-34
    try:
     _200=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e+00 <= _200): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:2999:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_200)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
    except mosek_fusion_ValueConversionError as _201:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3008:6-33
    try:
     _202=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _202) and (_202 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3013:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_202)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
    except mosek_fusion_ValueConversionError as _203:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3022:6-30
    try:
     _204=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _204): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3027:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_204)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
    except mosek_fusion_ValueConversionError as _205:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3036:6-30
    try:
     _206=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _206): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3041:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_206)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
    except mosek_fusion_ValueConversionError as _207:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3050:6-26
    try:
     _208=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3055:10-14
      _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_208)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
    except mosek_fusion_ValueConversionError as _209:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3064:6-30
    try:
     _210=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _210): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3069:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_210)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
    except mosek_fusion_ValueConversionError as _211:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3078:6-28
    try:
     _212=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _212): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3083:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_212)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
    except mosek_fusion_ValueConversionError as _213:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3092:6-28
    try:
     _214=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _214): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3097:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_214)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
    except mosek_fusion_ValueConversionError as _215:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3106:6-33
    try:
     _216=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _216): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3111:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_216)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
    except mosek_fusion_ValueConversionError as _217:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="basisTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3120:6-25
    try:
     _218=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _218): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3125:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_218)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
    except mosek_fusion_ValueConversionError as _219:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3134:6-25
    try:
     _220=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _220): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3139:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_220)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
    except mosek_fusion_ValueConversionError as _221:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3148:6-28
    try:
     _222=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _222): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3153:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_222)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
    except mosek_fusion_ValueConversionError as _223:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3162:6-28
    try:
     _224=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _224): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3167:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_224)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
    except mosek_fusion_ValueConversionError as _225:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3176:6-28
    try:
     _226=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _226): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3181:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_226)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
    except mosek_fusion_ValueConversionError as _227:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3190:6-30
    try:
     _228=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _228): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3195:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_228)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
    except mosek_fusion_ValueConversionError as _229:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3204:6-36
    try:
     _230=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _230): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3209:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_230)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
    except mosek_fusion_ValueConversionError as _231:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3218:6-36
    try:
     _232=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _232): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3223:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_232)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
    except mosek_fusion_ValueConversionError as _233:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3232:6-32
    try:
     _234=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-12 <= _234): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3237:10-27
      _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_234)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
    except mosek_fusion_ValueConversionError as _235:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3246:6-26
    try:
     _236=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-09 <= _236) and (_236 <= 1.000000e-03)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3251:10-49
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_236)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
    except mosek_fusion_ValueConversionError as _237:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3260:6-45
    try:
     _238=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _238) and (_238 <= 1.000000e+00)): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3265:10-49
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_238)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    except mosek_fusion_ValueConversionError as _239:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   if (_1=="dataFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3274:6-28
    _0._task_1put_1param_SS("MSK_SPAR_DATA_FILE_NAME",_2)
    return 
   if (_1=="basSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3279:6-30
    _0._task_1put_1param_SS("MSK_SPAR_BAS_SOL_FILE_NAME",_2)
    return 
   if (_1=="itrSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3284:6-30
    _0._task_1put_1param_SS("MSK_SPAR_ITR_SOL_FILE_NAME",_2)
    return 
   if (_1=="intSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3289:6-30
    _0._task_1put_1param_SS("MSK_SPAR_INT_SOL_FILE_NAME",_2)
    return 
   if (_1=="writeLpGenVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3294:6-33
    _0._task_1put_1param_SS("MSK_SPAR_WRITE_LP_GEN_VAR_NAME",_2)
    return 
   if (_1=="remoteAccessToken"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:3299:6-33
    _0._task_1put_1param_SS("MSK_SPAR_REMOTE_ACCESS_TOKEN",_2)
    return 
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def __string_1to_1scopr_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scopr_1value_S(_0)
  @staticmethod
  def __string_1to_1scopr_1value_S(_0):
   if (_0=="ent"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1663:6-16
    return numpy.int32(0)
   if (_0=="exp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1664:6-16
    return numpy.int32(1)
   if (_0=="log"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1665:6-16
    return numpy.int32(2)
   if (_0=="pow"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1666:6-16
    return numpy.int32(3)
   if (_0=="sqrt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1667:6-17
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1optimizertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1optimizertype_1value_S(_0)
  @staticmethod
  def __string_1to_1optimizertype_1value_S(_0):
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1652:6-17
    return numpy.int32(2)
   if (_0=="intpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1653:6-19
    return numpy.int32(4)
   if (_0=="conic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1654:6-18
    return numpy.int32(0)
   if (_0=="primalSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1655:6-26
    return numpy.int32(6)
   if (_0=="dualSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1656:6-24
    return numpy.int32(1)
   if (_0=="freeSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1657:6-24
    return numpy.int32(3)
   if (_0=="mixedInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1658:6-21
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1uplo_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1uplo_1value_S(_0)
  @staticmethod
  def __string_1to_1uplo_1value_S(_0):
   if (_0=="lo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1646:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1647:6-15
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1boundkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1boundkey_1value_S(_0)
  @staticmethod
  def __string_1to_1boundkey_1value_S(_0):
   if (_0=="lo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1637:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1638:6-15
    return numpy.int32(1)
   if (_0=="fx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1639:6-15
    return numpy.int32(2)
   if (_0=="fr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1640:6-15
    return numpy.int32(3)
   if (_0=="ra"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1641:6-15
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solsta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solsta_1value_S(_0)
  @staticmethod
  def __string_1to_1solsta_1value_S(_0):
   if (_0=="unknown"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1623:6-20
    return numpy.int32(0)
   if (_0=="optimal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1624:6-20
    return numpy.int32(1)
   if (_0=="primFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1625:6-21
    return numpy.int32(2)
   if (_0=="dualFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1626:6-21
    return numpy.int32(3)
   if (_0=="primAndDualFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1627:6-28
    return numpy.int32(4)
   if (_0=="primInfeasCer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1628:6-26
    return numpy.int32(5)
   if (_0=="dualInfeasCer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1629:6-26
    return numpy.int32(6)
   if (_0=="primIllposedCer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1630:6-28
    return numpy.int32(7)
   if (_0=="dualIllposedCer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1631:6-28
    return numpy.int32(8)
   if (_0=="integerOptimal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1632:6-27
    return numpy.int32(9)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iparam_1value_S(_0)
  @staticmethod
  def __string_1to_1iparam_1value_S(_0):
   if (_0=="autoUpdateSolInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1439:6-30
    return numpy.int32(3)
   if (_0=="removeUnusedSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1440:6-34
    return numpy.int32(118)
   if (_0=="intpntHotstart"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1441:6-27
    return numpy.int32(18)
   if (_0=="intpntPurify"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1442:6-25
    return numpy.int32(26)
   if (_0=="numThreads"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1443:6-23
    return numpy.int32(87)
   if (_0=="intpntMultiThread"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1444:6-30
    return numpy.int32(22)
   if (_0=="timingLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1445:6-24
    return numpy.int32(152)
   if (_0=="mtSpincount"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1446:6-24
    return numpy.int32(86)
   if (_0=="maxNumWarnings"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1447:6-27
    return numpy.int32(60)
   if (_0=="optimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1448:6-22
    return numpy.int32(97)
   if (_0=="biMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1449:6-28
    return numpy.int32(8)
   if (_0=="licenseTrhExpiryWrn"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1450:6-32
    return numpy.int32(34)
   if (_0=="logIncludeSummary"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1451:6-30
    return numpy.int32(45)
   if (_0=="logCutSecondOpt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1452:6-28
    return numpy.int32(41)
   if (_0=="logAnaPro"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1453:6-22
    return numpy.int32(37)
   if (_0=="logResponse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1454:6-24
    return numpy.int32(53)
   if (_0=="logLocalInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1455:6-25
    return numpy.int32(48)
   if (_0=="logBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1456:6-18
    return numpy.int32(38)
   if (_0=="logBiFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1457:6-22
    return numpy.int32(39)
   if (_0=="biCleanOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1458:6-29
    return numpy.int32(5)
   if (_0=="intpntMaxNumRefinementSteps"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1459:6-40
    return numpy.int32(21)
   if (_0=="intpntStartingPoint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1460:6-32
    return numpy.int32(30)
   if (_0=="intpntDiffStep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1461:6-27
    return numpy.int32(17)
   if (_0=="intpntScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1462:6-26
    return numpy.int32(28)
   if (_0=="intpntSolveForm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1463:6-28
    return numpy.int32(29)
   if (_0=="logIntpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1464:6-22
    return numpy.int32(47)
   if (_0=="intpntMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1465:6-32
    return numpy.int32(19)
   if (_0=="intpntOffColTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1466:6-28
    return numpy.int32(23)
   if (_0=="intpntOrderMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1467:6-30
    return numpy.int32(25)
   if (_0=="intpntOrderGpNumSeeds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1468:6-34
    return numpy.int32(24)
   if (_0=="intpntBasis"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1469:6-24
    return numpy.int32(16)
   if (_0=="biIgnoreMaxIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1470:6-28
    return numpy.int32(6)
   if (_0=="biIgnoreNumError"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1471:6-29
    return numpy.int32(7)
   if (_0=="intpntMaxNumCor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1472:6-28
    return numpy.int32(20)
   if (_0=="presolveUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1473:6-24
    return numpy.int32(108)
   if (_0=="presolveLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1474:6-26
    return numpy.int32(102)
   if (_0=="logPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1475:6-24
    return numpy.int32(52)
   if (_0=="presolveLindepUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1476:6-30
    return numpy.int32(105)
   if (_0=="presolveMaxNumPass"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1477:6-31
    return numpy.int32(106)
   if (_0=="presolveEliminatorMaxNumTries"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1478:6-42
    return numpy.int32(101)
   if (_0=="presolveEliminatorMaxFill"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1479:6-38
    return numpy.int32(100)
   if (_0=="presolveMaxNumReductions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1480:6-37
    return numpy.int32(107)
   if (_0=="simStabilityPriority"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1481:6-33
    return numpy.int32(145)
   if (_0=="simPrimalCrash"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1482:6-27
    return numpy.int32(134)
   if (_0=="logSim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1483:6-19
    return numpy.int32(56)
   if (_0=="logSimMinor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1484:6-24
    return numpy.int32(58)
   if (_0=="logSimFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1485:6-23
    return numpy.int32(57)
   if (_0=="simPrimalRestrictSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1486:6-39
    return numpy.int32(136)
   if (_0=="simPrimalSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1487:6-31
    return numpy.int32(137)
   if (_0=="simDualRestrictSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1488:6-37
    return numpy.int32(126)
   if (_0=="simDualSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1489:6-29
    return numpy.int32(127)
   if (_0=="simMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1490:6-29
    return numpy.int32(131)
   if (_0=="simHotstartLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1491:6-26
    return numpy.int32(130)
   if (_0=="simRefactorFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1492:6-28
    return numpy.int32(138)
   if (_0=="simSeed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1493:6-20
    return numpy.int32(143)
   if (_0=="mioMode"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1494:6-20
    return numpy.int32(75)
   if (_0=="logMio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1495:6-19
    return numpy.int32(49)
   if (_0=="logMioFreq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1496:6-23
    return numpy.int32(50)
   if (_0=="mioMaxNumRelaxs"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1497:6-28
    return numpy.int32(72)
   if (_0=="mioMaxNumBranches"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1498:6-30
    return numpy.int32(71)
   if (_0=="mioMaxNumRootCutRounds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1499:6-35
    return numpy.int32(73)
   if (_0=="mioMaxNumSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1500:6-31
    return numpy.int32(74)
   if (_0=="mioNodeSelection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1501:6-29
    return numpy.int32(77)
   if (_0=="mioHeuristicLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1502:6-30
    return numpy.int32(70)
   if (_0=="mioProbingLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1503:6-28
    return numpy.int32(79)
   if (_0=="mioCutSelectionLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1504:6-33
    return numpy.int32(68)
   if (_0=="mioVbDetectionLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1505:6-32
    return numpy.int32(85)
   if (_0=="mioBranchDir"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1506:6-25
    return numpy.int32(61)
   if (_0=="mioRootOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1507:6-29
    return numpy.int32(82)
   if (_0=="mioNodeOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1508:6-29
    return numpy.int32(76)
   if (_0=="mioPerspectiveReformulate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1509:6-38
    return numpy.int32(78)
   if (_0=="mioPropagateObjectiveConstraint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1510:6-44
    return numpy.int32(80)
   if (_0=="mioSeed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1511:6-20
    return numpy.int32(84)
   if (_0=="mioConicOuterApproximation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1512:6-39
    return numpy.int32(62)
   if (_0=="readKeepFreeCon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1513:6-28
    return numpy.int32(112)
   if (_0=="readMpsFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1514:6-26
    return numpy.int32(115)
   if (_0=="writeMpsFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1515:6-27
    return numpy.int32(170)
   if (_0=="readMpsWidth"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1516:6-25
    return numpy.int32(116)
   if (_0=="readDebug"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1517:6-22
    return numpy.int32(111)
   if (_0=="readLpQuotedNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1518:6-30
    return numpy.int32(114)
   if (_0=="writeDataParam"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1519:6-27
    return numpy.int32(157)
   if (_0=="writeFreeCon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1520:6-25
    return numpy.int32(158)
   if (_0=="writeGenericNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1521:6-30
    return numpy.int32(159)
   if (_0=="writeGenericNamesIo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1522:6-32
    return numpy.int32(160)
   if (_0=="writeCompression"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1523:6-29
    return numpy.int32(156)
   if (_0=="writeMpsInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1524:6-24
    return numpy.int32(171)
   if (_0=="writeLpStrictFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1525:6-32
    return numpy.int32(168)
   if (_0=="writeLpQuotedNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1526:6-31
    return numpy.int32(167)
   if (_0=="writeLpLineWidth"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1527:6-29
    return numpy.int32(166)
   if (_0=="writeLpTermsPerLine"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1528:6-32
    return numpy.int32(169)
   if (_0=="writeLpFullObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1529:6-27
    return numpy.int32(165)
   if (_0=="writePrecision"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1530:6-27
    return numpy.int32(172)
   if (_0=="writeSolIgnoreInvalidNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1531:6-39
    return numpy.int32(176)
   if (_0=="writeSolHead"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1532:6-25
    return numpy.int32(175)
   if (_0=="writeSolConstraints"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1533:6-32
    return numpy.int32(174)
   if (_0=="writeSolVariables"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1534:6-30
    return numpy.int32(177)
   if (_0=="writeSolBarvariables"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1535:6-33
    return numpy.int32(173)
   if (_0=="writeBasHead"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1536:6-25
    return numpy.int32(154)
   if (_0=="writeBasConstraints"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1537:6-32
    return numpy.int32(153)
   if (_0=="writeBasVariables"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1538:6-30
    return numpy.int32(155)
   if (_0=="writeIntHead"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1539:6-25
    return numpy.int32(163)
   if (_0=="writeIntConstraints"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1540:6-32
    return numpy.int32(162)
   if (_0=="writeIntVariables"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1541:6-30
    return numpy.int32(164)
   if (_0=="solReadNameWidth"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1542:6-29
    return numpy.int32(149)
   if (_0=="solReadWidth"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1543:6-25
    return numpy.int32(150)
   if (_0=="infeasReportAuto"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1544:6-29
    return numpy.int32(14)
   if (_0=="infeasReportLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1545:6-30
    return numpy.int32(15)
   if (_0=="infeasGenericNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1546:6-31
    return numpy.int32(12)
   if (_0=="logInfeasAna"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1547:6-25
    return numpy.int32(46)
   if (_0=="licenseWait"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1548:6-24
    return numpy.int32(35)
   if (_0=="licenseSuppressExpireWrns"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1549:6-38
    return numpy.int32(33)
   if (_0=="licensePauseTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1550:6-29
    return numpy.int32(32)
   if (_0=="licenseDebug"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1551:6-25
    return numpy.int32(31)
   if (_0=="solFilterKeepBasic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1552:6-31
    return numpy.int32(147)
   if (_0=="solFilterKeepRanged"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1553:6-32
    return numpy.int32(148)
   if (_0=="log"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1554:6-16
    return numpy.int32(36)
   if (_0=="logExpand"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1555:6-22
    return numpy.int32(42)
   if (_0=="logFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1556:6-20
    return numpy.int32(44)
   if (_0=="logOrder"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1557:6-21
    return numpy.int32(51)
   if (_0=="logSensitivity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1558:6-27
    return numpy.int32(54)
   if (_0=="logSensitivityOpt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1559:6-30
    return numpy.int32(55)
   if (_0=="readTaskIgnoreParam"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1560:6-32
    return numpy.int32(117)
   if (_0=="writeTaskIncSol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1561:6-28
    return numpy.int32(178)
   if (_0=="paramReadCaseName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1562:6-30
    return numpy.int32(98)
   if (_0=="paramReadIgnError"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1563:6-30
    return numpy.int32(99)
   if (_0=="solutionCallback"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1564:6-29
    return numpy.int32(151)
   if (_0=="simScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1565:6-23
    return numpy.int32(141)
   if (_0=="simScalingMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1566:6-29
    return numpy.int32(142)
   if (_0=="simPrimalPhaseoneMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1567:6-36
    return numpy.int32(135)
   if (_0=="simDualPhaseoneMethod"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1568:6-34
    return numpy.int32(125)
   if (_0=="simMaxNumSetbacks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1569:6-30
    return numpy.int32(132)
   if (_0=="simHotstart"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1570:6-24
    return numpy.int32(129)
   if (_0=="simBasisFactorUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1571:6-30
    return numpy.int32(122)
   if (_0=="simDegen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1572:6-21
    return numpy.int32(123)
   if (_0=="simReformulation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1573:6-29
    return numpy.int32(139)
   if (_0=="simExploitDupvec"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1574:6-29
    return numpy.int32(128)
   if (_0=="simSaveLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1575:6-22
    return numpy.int32(140)
   if (_0=="simNonSingular"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1576:6-27
    return numpy.int32(133)
   if (_0=="simDualCrash"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1577:6-25
    return numpy.int32(124)
   if (_0=="logStorage"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1578:6-23
    return numpy.int32(59)
   if (_0=="infeasPreferPrimal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1579:6-31
    return numpy.int32(13)
   if (_0=="readLpDropNewVarsInBou"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1580:6-35
    return numpy.int32(113)
   if (_0=="opfWriteLineLength"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1581:6-31
    return numpy.int32(90)
   if (_0=="opfWriteHints"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1582:6-26
    return numpy.int32(89)
   if (_0=="opfWriteParameters"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1583:6-31
    return numpy.int32(91)
   if (_0=="opfWriteProblem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1584:6-28
    return numpy.int32(92)
   if (_0=="opfWriteHeader"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1585:6-27
    return numpy.int32(88)
   if (_0=="opfWriteSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1586:6-30
    return numpy.int32(96)
   if (_0=="opfWriteSolBas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1587:6-27
    return numpy.int32(93)
   if (_0=="opfWriteSolItg"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1588:6-27
    return numpy.int32(94)
   if (_0=="opfWriteSolItr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1589:6-27
    return numpy.int32(95)
   if (_0=="ptfWriteTransform"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1590:6-30
    return numpy.int32(110)
   if (_0=="primalRepairOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1591:6-34
    return numpy.int32(109)
   if (_0=="mioRootRepeatPresolveLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1592:6-39
    return numpy.int32(83)
   if (_0=="mioCutCmir"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1593:6-23
    return numpy.int32(64)
   if (_0=="mioCutClique"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1594:6-25
    return numpy.int32(63)
   if (_0=="mioCutImpliedBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1595:6-31
    return numpy.int32(66)
   if (_0=="mioCutKnapsackCover"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1596:6-32
    return numpy.int32(67)
   if (_0=="mioCutGmi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1597:6-22
    return numpy.int32(65)
   if (_0=="sensitivityType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1598:6-28
    return numpy.int32(121)
   if (_0=="presolveLindepRelWorkTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1599:6-37
    return numpy.int32(104)
   if (_0=="presolveLindepAbsWorkTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1600:6-37
    return numpy.int32(103)
   if (_0=="sensitivityAll"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1601:6-27
    return numpy.int32(119)
   if (_0=="logFeasRepair"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1602:6-26
    return numpy.int32(43)
   if (_0=="cacheLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1603:6-25
    return numpy.int32(9)
   if (_0=="intpntRegularizationUse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1604:6-36
    return numpy.int32(27)
   if (_0=="simSolveForm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1605:6-25
    return numpy.int32(144)
   if (_0=="simSwitchOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1606:6-31
    return numpy.int32(146)
   if (_0=="writeIgnoreIncompatibleItems"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1607:6-41
    return numpy.int32(161)
   if (_0=="checkConvexity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1608:6-27
    return numpy.int32(10)
   if (_0=="logCheckConvexity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1609:6-30
    return numpy.int32(40)
   if (_0=="autoSortABeforeOpt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1610:6-31
    return numpy.int32(2)
   if (_0=="sensitivityOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1611:6-33
    return numpy.int32(120)
   if (_0=="writeXmlMode"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1612:6-25
    return numpy.int32(179)
   if (_0=="anaSolBasis"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1613:6-24
    return numpy.int32(0)
   if (_0=="anaSolPrintViolated"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1614:6-32
    return numpy.int32(1)
   if (_0=="basisSolveUsePlusOne"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1615:6-33
    return numpy.int32(4)
   if (_0=="compressStatfile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1616:6-29
    return numpy.int32(11)
   if (_0=="mioRinsMaxNodes"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1617:6-28
    return numpy.int32(81)
   if (_0=="mioFeaspumpLevel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1618:6-29
    return numpy.int32(69)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1simseltype_1value_S(_0):
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1429:6-17
    return numpy.int32(0)
   if (_0=="full"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1430:6-17
    return numpy.int32(1)
   if (_0=="ase"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1431:6-16
    return numpy.int32(2)
   if (_0=="devex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1432:6-18
    return numpy.int32(3)
   if (_0=="se"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1433:6-15
    return numpy.int32(4)
   if (_0=="partial"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1434:6-20
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1objsense_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1objsense_1value_S(_0)
  @staticmethod
  def __string_1to_1objsense_1value_S(_0):
   if (_0=="minimize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1423:6-21
    return numpy.int32(0)
   if (_0=="maximize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1424:6-21
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miomode_1value_S(_0)
  @staticmethod
  def __string_1to_1miomode_1value_S(_0):
   if (_0=="ignored"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1417:6-20
    return numpy.int32(0)
   if (_0=="satisfied"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1418:6-22
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1iinfitem_1value_S(_0):
   if (_0=="anaProNumCon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1312:6-25
    return numpy.int32(0)
   if (_0=="anaProNumConLo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1313:6-27
    return numpy.int32(3)
   if (_0=="anaProNumConUp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1314:6-27
    return numpy.int32(5)
   if (_0=="anaProNumConRa"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1315:6-27
    return numpy.int32(4)
   if (_0=="anaProNumConEq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1316:6-27
    return numpy.int32(1)
   if (_0=="anaProNumConFr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1317:6-27
    return numpy.int32(2)
   if (_0=="anaProNumVar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1318:6-25
    return numpy.int32(6)
   if (_0=="anaProNumVarLo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1319:6-27
    return numpy.int32(12)
   if (_0=="anaProNumVarUp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1320:6-27
    return numpy.int32(14)
   if (_0=="anaProNumVarRa"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1321:6-27
    return numpy.int32(13)
   if (_0=="anaProNumVarEq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1322:6-27
    return numpy.int32(9)
   if (_0=="anaProNumVarFr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1323:6-27
    return numpy.int32(10)
   if (_0=="anaProNumVarCont"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1324:6-29
    return numpy.int32(8)
   if (_0=="anaProNumVarBin"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1325:6-28
    return numpy.int32(7)
   if (_0=="anaProNumVarInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1326:6-28
    return numpy.int32(11)
   if (_0=="optimizeResponse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1327:6-29
    return numpy.int32(71)
   if (_0=="intpntIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1328:6-23
    return numpy.int32(16)
   if (_0=="intpntFactorDimDense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1329:6-33
    return numpy.int32(15)
   if (_0=="intpntSolveDual"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1330:6-28
    return numpy.int32(18)
   if (_0=="mioNodeDepth"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1331:6-25
    return numpy.int32(22)
   if (_0=="mioNumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1332:6-22
    return numpy.int32(48)
   if (_0=="mioNumbin"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1333:6-22
    return numpy.int32(33)
   if (_0=="mioNumint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1334:6-22
    return numpy.int32(42)
   if (_0=="mioNumcont"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1335:6-23
    return numpy.int32(38)
   if (_0=="mioNumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1336:6-22
    return numpy.int32(35)
   if (_0=="mioNumcone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1337:6-23
    return numpy.int32(36)
   if (_0=="mioNumqcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1338:6-25
    return numpy.int32(46)
   if (_0=="mioNumrqcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1339:6-26
    return numpy.int32(47)
   if (_0=="mioNumpexpcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1340:6-28
    return numpy.int32(44)
   if (_0=="mioNumdexpcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1341:6-28
    return numpy.int32(40)
   if (_0=="mioNumppowcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1342:6-28
    return numpy.int32(45)
   if (_0=="mioNumdpowcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1343:6-28
    return numpy.int32(41)
   if (_0=="mioNumconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1344:6-26
    return numpy.int32(37)
   if (_0=="mioNumbinconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1345:6-29
    return numpy.int32(34)
   if (_0=="mioNumintconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1346:6-29
    return numpy.int32(43)
   if (_0=="mioNumcontconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1347:6-30
    return numpy.int32(39)
   if (_0=="mioPresolvedNumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1348:6-31
    return numpy.int32(65)
   if (_0=="mioPresolvedNumbin"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1349:6-31
    return numpy.int32(50)
   if (_0=="mioPresolvedNumint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1350:6-31
    return numpy.int32(59)
   if (_0=="mioPresolvedNumcont"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1351:6-32
    return numpy.int32(55)
   if (_0=="mioPresolvedNumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1352:6-31
    return numpy.int32(52)
   if (_0=="mioPresolvedNumcone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1353:6-32
    return numpy.int32(53)
   if (_0=="mioPresolvedNumqcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1354:6-34
    return numpy.int32(63)
   if (_0=="mioPresolvedNumrqcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1355:6-35
    return numpy.int32(64)
   if (_0=="mioPresolvedNumpexpcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1356:6-37
    return numpy.int32(61)
   if (_0=="mioPresolvedNumdexpcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1357:6-37
    return numpy.int32(57)
   if (_0=="mioPresolvedNumppowcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1358:6-37
    return numpy.int32(62)
   if (_0=="mioPresolvedNumdpowcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1359:6-37
    return numpy.int32(58)
   if (_0=="mioPresolvedNumconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1360:6-35
    return numpy.int32(54)
   if (_0=="mioPresolvedNumbinconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1361:6-38
    return numpy.int32(51)
   if (_0=="mioPresolvedNumintconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1362:6-38
    return numpy.int32(60)
   if (_0=="mioPresolvedNumcontconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1363:6-39
    return numpy.int32(56)
   if (_0=="mioCliqueTableSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1364:6-31
    return numpy.int32(20)
   if (_0=="mioConstructSolution"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1365:6-33
    return numpy.int32(21)
   if (_0=="mioNumIntSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1366:6-31
    return numpy.int32(29)
   if (_0=="mioObjBoundDefined"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1367:6-31
    return numpy.int32(49)
   if (_0=="mioNumActiveNodes"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1368:6-30
    return numpy.int32(23)
   if (_0=="mioNumRelax"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1369:6-24
    return numpy.int32(31)
   if (_0=="mioNumBranch"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1370:6-25
    return numpy.int32(24)
   if (_0=="mioTotalNumCuts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1371:6-28
    return numpy.int32(67)
   if (_0=="mioNumCmirCuts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1372:6-27
    return numpy.int32(26)
   if (_0=="mioNumCliqueCuts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1373:6-29
    return numpy.int32(25)
   if (_0=="mioNumImpliedBoundCuts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1374:6-35
    return numpy.int32(28)
   if (_0=="mioNumKnapsackCoverCuts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1375:6-36
    return numpy.int32(30)
   if (_0=="mioNumGomoryCuts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1376:6-29
    return numpy.int32(27)
   if (_0=="mioNumRepeatedPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1377:6-35
    return numpy.int32(32)
   if (_0=="mioUserObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1378:6-26
    return numpy.int32(68)
   if (_0=="mioRelgapSatisfied"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1379:6-31
    return numpy.int32(66)
   if (_0=="mioAbsgapSatisfied"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1380:6-31
    return numpy.int32(19)
   if (_0=="rdProtype"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1381:6-22
    return numpy.int32(80)
   if (_0=="rdNumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1382:6-21
    return numpy.int32(75)
   if (_0=="rdNumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1383:6-21
    return numpy.int32(79)
   if (_0=="rdNumbarvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1384:6-24
    return numpy.int32(74)
   if (_0=="rdNumintvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1385:6-24
    return numpy.int32(77)
   if (_0=="rdNumq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1386:6-19
    return numpy.int32(78)
   if (_0=="simDualDegIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1387:6-27
    return numpy.int32(81)
   if (_0=="simDualInfIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1388:6-27
    return numpy.int32(84)
   if (_0=="simDualHotstartLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1389:6-30
    return numpy.int32(83)
   if (_0=="simPrimalIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1390:6-26
    return numpy.int32(92)
   if (_0=="simDualIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1391:6-24
    return numpy.int32(85)
   if (_0=="intpntNumThreads"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1392:6-29
    return numpy.int32(17)
   if (_0=="simPrimalInfIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1393:6-29
    return numpy.int32(91)
   if (_0=="simPrimalDegIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1394:6-29
    return numpy.int32(88)
   if (_0=="simPrimalHotstart"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1395:6-30
    return numpy.int32(89)
   if (_0=="simPrimalHotstartLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1396:6-32
    return numpy.int32(90)
   if (_0=="simDualHotstart"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1397:6-28
    return numpy.int32(82)
   if (_0=="solItrProsta"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1398:6-25
    return numpy.int32(98)
   if (_0=="solItrSolsta"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1399:6-25
    return numpy.int32(99)
   if (_0=="solBasProsta"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1400:6-25
    return numpy.int32(94)
   if (_0=="solBasSolsta"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1401:6-25
    return numpy.int32(95)
   if (_0=="solItgProsta"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1402:6-25
    return numpy.int32(96)
   if (_0=="solItgSolsta"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1403:6-25
    return numpy.int32(97)
   if (_0=="simNumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1404:6-22
    return numpy.int32(86)
   if (_0=="simNumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1405:6-22
    return numpy.int32(87)
   if (_0=="optNumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1406:6-22
    return numpy.int32(69)
   if (_0=="optNumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1407:6-22
    return numpy.int32(70)
   if (_0=="stoNumARealloc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1408:6-27
    return numpy.int32(100)
   if (_0=="rdNumcone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1409:6-22
    return numpy.int32(76)
   if (_0=="simSolveDual"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1410:6-25
    return numpy.int32(93)
   if (_0=="purifyPrimalSuccess"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1411:6-32
    return numpy.int32(73)
   if (_0=="purifyDualSuccess"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1412:6-30
    return numpy.int32(72)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1compresstype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1compresstype_1value_S(_0)
  @staticmethod
  def __string_1to_1compresstype_1value_S(_0):
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1304:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1305:6-17
    return numpy.int32(1)
   if (_0=="gzip"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1306:6-17
    return numpy.int32(2)
   if (_0=="zstd"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1307:6-17
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mpsformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mpsformat_1value_S(_0)
  @staticmethod
  def __string_1to_1mpsformat_1value_S(_0):
   if (_0=="strict"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1296:6-19
    return numpy.int32(0)
   if (_0=="relaxed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1297:6-20
    return numpy.int32(1)
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1298:6-17
    return numpy.int32(2)
   if (_0=="cplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1299:6-18
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mionodeseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mionodeseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1mionodeseltype_1value_S(_0):
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1288:6-17
    return numpy.int32(0)
   if (_0=="first"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1289:6-18
    return numpy.int32(1)
   if (_0=="best"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1290:6-17
    return numpy.int32(2)
   if (_0=="pseudo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1291:6-19
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1streamtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1streamtype_1value_S(_0)
  @staticmethod
  def __string_1to_1streamtype_1value_S(_0):
   if (_0=="log"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1280:6-16
    return numpy.int32(0)
   if (_0=="msg"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1281:6-16
    return numpy.int32(1)
   if (_0=="err"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1282:6-16
    return numpy.int32(2)
   if (_0=="wrn"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1283:6-16
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simreform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simreform_1value_S(_0)
  @staticmethod
  def __string_1to_1simreform_1value_S(_0):
   if (_0=="on"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1272:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1273:6-16
    return numpy.int32(0)
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1274:6-17
    return numpy.int32(2)
   if (_0=="aggressive"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1275:6-23
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1nametype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1nametype_1value_S(_0)
  @staticmethod
  def __string_1to_1nametype_1value_S(_0):
   if (_0=="gen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1265:6-16
    return numpy.int32(0)
   if (_0=="mps"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1266:6-16
    return numpy.int32(1)
   if (_0=="lp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1267:6-15
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1dinfitem_1value_S(_0):
   if (_0=="biTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1171:6-19
    return numpy.int32(5)
   if (_0=="biPrimalTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1172:6-25
    return numpy.int32(4)
   if (_0=="biDualTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1173:6-23
    return numpy.int32(3)
   if (_0=="biCleanTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1174:6-24
    return numpy.int32(2)
   if (_0=="biCleanPrimalTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1175:6-30
    return numpy.int32(1)
   if (_0=="biCleanDualTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1176:6-28
    return numpy.int32(0)
   if (_0=="intpntTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1177:6-23
    return numpy.int32(13)
   if (_0=="intpntOrderTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1178:6-28
    return numpy.int32(10)
   if (_0=="intpntPrimalObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1179:6-28
    return numpy.int32(12)
   if (_0=="intpntDualObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1180:6-26
    return numpy.int32(7)
   if (_0=="intpntPrimalFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1181:6-29
    return numpy.int32(11)
   if (_0=="intpntDualFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1182:6-27
    return numpy.int32(6)
   if (_0=="intpntOptStatus"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1183:6-28
    return numpy.int32(9)
   if (_0=="simTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1184:6-20
    return numpy.int32(45)
   if (_0=="simPrimalTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1185:6-26
    return numpy.int32(44)
   if (_0=="simDualTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1186:6-24
    return numpy.int32(41)
   if (_0=="simObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1187:6-19
    return numpy.int32(43)
   if (_0=="simFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1188:6-20
    return numpy.int32(42)
   if (_0=="mioTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1189:6-20
    return numpy.int32(29)
   if (_0=="mioRootPresolveTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1190:6-32
    return numpy.int32(28)
   if (_0=="mioRootOptimizerTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1191:6-33
    return numpy.int32(27)
   if (_0=="toConicTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1192:6-24
    return numpy.int32(89)
   if (_0=="mioConstructSolutionObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1193:6-36
    return numpy.int32(16)
   if (_0=="mioObjInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1194:6-22
    return numpy.int32(23)
   if (_0=="mioObjBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1195:6-24
    return numpy.int32(22)
   if (_0=="mioObjRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1196:6-25
    return numpy.int32(24)
   if (_0=="mioObjAbsGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1197:6-25
    return numpy.int32(21)
   if (_0=="mioUserObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1198:6-26
    return numpy.int32(30)
   if (_0=="mioCmirSeparationTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1199:6-34
    return numpy.int32(15)
   if (_0=="mioCliqueSeparationTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1200:6-36
    return numpy.int32(14)
   if (_0=="mioKnapsackCoverSeparationTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1201:6-43
    return numpy.int32(20)
   if (_0=="mioGmiSeparationTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1202:6-33
    return numpy.int32(18)
   if (_0=="mioImpliedBoundTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1203:6-32
    return numpy.int32(19)
   if (_0=="mioRootCutgenTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1204:6-30
    return numpy.int32(26)
   if (_0=="mioProbingTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1205:6-27
    return numpy.int32(25)
   if (_0=="optimizerTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1206:6-26
    return numpy.int32(31)
   if (_0=="presolveTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1207:6-25
    return numpy.int32(34)
   if (_0=="mioDualBoundAfterPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1208:6-38
    return numpy.int32(17)
   if (_0=="presolveEliTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1209:6-28
    return numpy.int32(32)
   if (_0=="presolveLindepTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1210:6-31
    return numpy.int32(33)
   if (_0=="rdTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1211:6-19
    return numpy.int32(40)
   if (_0=="solItrPrimalObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1212:6-28
    return numpy.int32(84)
   if (_0=="solItrPviolcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1213:6-27
    return numpy.int32(86)
   if (_0=="solItrPviolvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1214:6-27
    return numpy.int32(88)
   if (_0=="solItrPviolbarvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1215:6-30
    return numpy.int32(85)
   if (_0=="solItrPviolcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1216:6-29
    return numpy.int32(87)
   if (_0=="solItrDualObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1217:6-26
    return numpy.int32(69)
   if (_0=="solItrDviolcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1218:6-27
    return numpy.int32(71)
   if (_0=="solItrDviolvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1219:6-27
    return numpy.int32(73)
   if (_0=="solItrDviolbarvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1220:6-30
    return numpy.int32(70)
   if (_0=="solItrDviolcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1221:6-29
    return numpy.int32(72)
   if (_0=="solItrNrmXc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1222:6-24
    return numpy.int32(81)
   if (_0=="solItrNrmXx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1223:6-24
    return numpy.int32(82)
   if (_0=="solItrNrmBarx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1224:6-26
    return numpy.int32(75)
   if (_0=="solItrNrmY"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1225:6-23
    return numpy.int32(83)
   if (_0=="solItrNrmSlc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1226:6-25
    return numpy.int32(76)
   if (_0=="solItrNrmSuc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1227:6-25
    return numpy.int32(79)
   if (_0=="solItrNrmSlx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1228:6-25
    return numpy.int32(77)
   if (_0=="solItrNrmSux"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1229:6-25
    return numpy.int32(80)
   if (_0=="solItrNrmSnx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1230:6-25
    return numpy.int32(78)
   if (_0=="solItrNrmBars"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1231:6-26
    return numpy.int32(74)
   if (_0=="solBasPrimalObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1232:6-28
    return numpy.int32(57)
   if (_0=="solBasPviolcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1233:6-27
    return numpy.int32(58)
   if (_0=="solBasPviolvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1234:6-27
    return numpy.int32(59)
   if (_0=="solBasDualObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1235:6-26
    return numpy.int32(46)
   if (_0=="solBasDviolcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1236:6-27
    return numpy.int32(47)
   if (_0=="solBasDviolvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1237:6-27
    return numpy.int32(48)
   if (_0=="solBasNrmXc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1238:6-24
    return numpy.int32(54)
   if (_0=="solBasNrmXx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1239:6-24
    return numpy.int32(55)
   if (_0=="solBasNrmBarx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1240:6-26
    return numpy.int32(49)
   if (_0=="solBasNrmY"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1241:6-23
    return numpy.int32(56)
   if (_0=="solBasNrmSlc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1242:6-25
    return numpy.int32(50)
   if (_0=="solBasNrmSuc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1243:6-25
    return numpy.int32(52)
   if (_0=="solBasNrmSlx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1244:6-25
    return numpy.int32(51)
   if (_0=="solBasNrmSux"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1245:6-25
    return numpy.int32(53)
   if (_0=="solItgPrimalObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1246:6-28
    return numpy.int32(63)
   if (_0=="solItgPviolcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1247:6-27
    return numpy.int32(65)
   if (_0=="solItgPviolvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1248:6-27
    return numpy.int32(68)
   if (_0=="solItgPviolbarvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1249:6-30
    return numpy.int32(64)
   if (_0=="solItgPviolcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1250:6-29
    return numpy.int32(66)
   if (_0=="solItgPviolitg"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1251:6-27
    return numpy.int32(67)
   if (_0=="solItgNrmXc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1252:6-24
    return numpy.int32(61)
   if (_0=="solItgNrmXx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1253:6-24
    return numpy.int32(62)
   if (_0=="solItgNrmBarx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1254:6-26
    return numpy.int32(60)
   if (_0=="intpntFactorNumFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1255:6-33
    return numpy.int32(8)
   if (_0=="qcqoReformulateTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1256:6-32
    return numpy.int32(37)
   if (_0=="qcqoReformulateMaxPerturbation"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1257:6-43
    return numpy.int32(36)
   if (_0=="qcqoReformulateWorstCholeskyDiagScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1258:6-52
    return numpy.int32(39)
   if (_0=="qcqoReformulateWorstCholeskyColumnScaling"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1259:6-54
    return numpy.int32(38)
   if (_0=="primalRepairPenaltyObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1260:6-35
    return numpy.int32(35)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1xmlwriteroutputtype_1value_S(_0)
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_S(_0):
   if (_0=="row"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1165:6-16
    return numpy.int32(0)
   if (_0=="col"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1166:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1prosta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1prosta_1value_S(_0)
  @staticmethod
  def __string_1to_1prosta_1value_S(_0):
   if (_0=="unknown"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1152:6-20
    return numpy.int32(0)
   if (_0=="primAndDualFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1153:6-28
    return numpy.int32(1)
   if (_0=="primFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1154:6-21
    return numpy.int32(2)
   if (_0=="dualFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1155:6-21
    return numpy.int32(3)
   if (_0=="primInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1156:6-23
    return numpy.int32(4)
   if (_0=="dualInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1157:6-23
    return numpy.int32(5)
   if (_0=="primAndDualInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1158:6-30
    return numpy.int32(6)
   if (_0=="illPosed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1159:6-21
    return numpy.int32(7)
   if (_0=="primInfeasOrUnbounded"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1160:6-34
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1liinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1liinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1liinfitem_1value_S(_0):
   if (_0=="mioAnz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1135:6-19
    return numpy.int32(7)
   if (_0=="mioPresolvedAnz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1136:6-28
    return numpy.int32(9)
   if (_0=="mioSimplexIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1137:6-27
    return numpy.int32(10)
   if (_0=="mioIntpntIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1138:6-26
    return numpy.int32(8)
   if (_0=="biPrimalIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1139:6-25
    return numpy.int32(5)
   if (_0=="biDualIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1140:6-23
    return numpy.int32(4)
   if (_0=="biCleanPrimalIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1141:6-30
    return numpy.int32(3)
   if (_0=="biCleanDualIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1142:6-28
    return numpy.int32(1)
   if (_0=="biCleanPrimalDegIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1143:6-33
    return numpy.int32(2)
   if (_0=="biCleanDualDegIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1144:6-31
    return numpy.int32(0)
   if (_0=="intpntFactorNumNz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1145:6-30
    return numpy.int32(6)
   if (_0=="rdNumanz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1146:6-21
    return numpy.int32(11)
   if (_0=="rdNumqnz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1147:6-21
    return numpy.int32(12)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1variabletype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1variabletype_1value_S(_0)
  @staticmethod
  def __string_1to_1variabletype_1value_S(_0):
   if (_0=="typeCont"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1129:6-21
    return numpy.int32(0)
   if (_0=="typeInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1130:6-20
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1orderingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1orderingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1orderingtype_1value_S(_0):
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1119:6-17
    return numpy.int32(0)
   if (_0=="appminloc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1120:6-22
    return numpy.int32(1)
   if (_0=="experimental"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1121:6-25
    return numpy.int32(2)
   if (_0=="tryGraphpar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1122:6-24
    return numpy.int32(3)
   if (_0=="forceGraphpar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1123:6-26
    return numpy.int32(4)
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1124:6-17
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1transpose_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1transpose_1value_S(_0)
  @staticmethod
  def __string_1to_1transpose_1value_S(_0):
   if (_0=="no"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1113:6-15
    return numpy.int32(0)
   if (_0=="yes"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1114:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1presolvemode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1presolvemode_1value_S(_0)
  @staticmethod
  def __string_1to_1presolvemode_1value_S(_0):
   if (_0=="off"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1106:6-16
    return numpy.int32(0)
   if (_0=="on"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1107:6-15
    return numpy.int32(1)
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1108:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1checkconvexitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_S(_0):
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1099:6-17
    return numpy.int32(0)
   if (_0=="simple"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1100:6-19
    return numpy.int32(1)
   if (_0=="full"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1101:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dataformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dataformat_1value_S(_0)
  @staticmethod
  def __string_1to_1dataformat_1value_S(_0):
   if (_0=="extension"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1086:6-22
    return numpy.int32(0)
   if (_0=="mps"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1087:6-16
    return numpy.int32(1)
   if (_0=="lp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1088:6-15
    return numpy.int32(2)
   if (_0=="op"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1089:6-15
    return numpy.int32(3)
   if (_0=="freeMps"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1090:6-20
    return numpy.int32(4)
   if (_0=="task"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1091:6-17
    return numpy.int32(5)
   if (_0=="ptf"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1092:6-16
    return numpy.int32(6)
   if (_0=="cb"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1093:6-15
    return numpy.int32(7)
   if (_0=="jsonTask"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1094:6-21
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1basindtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1basindtype_1value_S(_0)
  @staticmethod
  def __string_1to_1basindtype_1value_S(_0):
   if (_0=="never"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1077:6-18
    return numpy.int32(0)
   if (_0=="always"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1078:6-19
    return numpy.int32(1)
   if (_0=="noError"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1079:6-20
    return numpy.int32(2)
   if (_0=="ifFeasible"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1080:6-23
    return numpy.int32(3)
   if (_0=="reservered"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1081:6-23
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iomode_1value_S(_0)
  @staticmethod
  def __string_1to_1iomode_1value_S(_0):
   if (_0=="read"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1070:6-17
    return numpy.int32(0)
   if (_0=="write"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1071:6-18
    return numpy.int32(1)
   if (_0=="readwrite"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1072:6-22
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1liinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1liinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1liinf_1value_S(_0):
   if (_0=="intpntLenbarvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1058:6-28
    return numpy.int32(6)
   if (_0=="intpntFactorNumNzBefore"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1059:6-36
    return numpy.int32(3)
   if (_0=="intpntFactorNumNzAfter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1060:6-35
    return numpy.int32(2)
   if (_0=="intpntFactorMlOrderSparseLNz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1061:6-41
    return numpy.int32(1)
   if (_0=="intpntFactorGpOrderSparseLNz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1062:6-41
    return numpy.int32(0)
   if (_0=="presolveStackSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1063:6-30
    return numpy.int32(7)
   if (_0=="intpntFactorVNz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1064:6-28
    return numpy.int32(5)
   if (_0=="intpntFactorUpdatedVNz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1065:6-35
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sparam_1value_S(_0)
  @staticmethod
  def __string_1to_1sparam_1value_S(_0):
   if (_0=="dataFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1030:6-25
    return numpy.int32(1)
   if (_0=="paramReadFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1031:6-30
    return numpy.int32(7)
   if (_0=="paramWriteFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1032:6-31
    return numpy.int32(8)
   if (_0=="paramCommentSign"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1033:6-29
    return numpy.int32(6)
   if (_0=="debugFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1034:6-26
    return numpy.int32(2)
   if (_0=="basSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1035:6-27
    return numpy.int32(0)
   if (_0=="itrSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1036:6-27
    return numpy.int32(4)
   if (_0=="intSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1037:6-27
    return numpy.int32(3)
   if (_0=="solFilterXcLow"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1038:6-27
    return numpy.int32(16)
   if (_0=="solFilterXcUpr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1039:6-27
    return numpy.int32(17)
   if (_0=="solFilterXxLow"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1040:6-27
    return numpy.int32(18)
   if (_0=="solFilterXxUpr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1041:6-27
    return numpy.int32(19)
   if (_0=="readMpsObjName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1042:6-27
    return numpy.int32(10)
   if (_0=="readMpsRanName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1043:6-27
    return numpy.int32(11)
   if (_0=="readMpsRhsName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1044:6-27
    return numpy.int32(12)
   if (_0=="readMpsBouName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1045:6-27
    return numpy.int32(9)
   if (_0=="statFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1046:6-25
    return numpy.int32(20)
   if (_0=="statName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1047:6-21
    return numpy.int32(22)
   if (_0=="statKey"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1048:6-20
    return numpy.int32(21)
   if (_0=="writeLpGenVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1049:6-30
    return numpy.int32(23)
   if (_0=="sensitivityResFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1050:6-35
    return numpy.int32(15)
   if (_0=="sensitivityFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1051:6-32
    return numpy.int32(14)
   if (_0=="mioDebugString"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1052:6-27
    return numpy.int32(5)
   if (_0=="remoteAccessToken"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1053:6-30
    return numpy.int32(13)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdegen_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdegen_1value_S(_0)
  @staticmethod
  def __string_1to_1simdegen_1value_S(_0):
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1021:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1022:6-17
    return numpy.int32(1)
   if (_0=="aggressive"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1023:6-23
    return numpy.int32(2)
   if (_0=="moderate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1024:6-21
    return numpy.int32(3)
   if (_0=="minimum"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1025:6-20
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1language_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1language_1value_S(_0)
  @staticmethod
  def __string_1to_1language_1value_S(_0):
   if (_0=="eng"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1015:6-16
    return numpy.int32(0)
   if (_0=="dan"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1016:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sensitivitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sensitivitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1sensitivitytype_1value_S(_0):
   if (_0=="basis"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1010:6-18
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1dinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1dinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1dinf_1value_S(_0):
   if (_0=="sensitivityPrimalTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:923:6-34
    return numpy.int32(78)
   if (_0=="sensitivityDualTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:924:6-32
    return numpy.int32(77)
   if (_0=="intpntGfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:925:6-24
    return numpy.int32(55)
   if (_0=="intpntMu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:926:6-21
    return numpy.int32(62)
   if (_0=="intpntInitIterTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:927:6-31
    return numpy.int32(57)
   if (_0=="intpntFactorTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:928:6-29
    return numpy.int32(53)
   if (_0=="intpntInitSearchTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:929:6-33
    return numpy.int32(58)
   if (_0=="intpntFormSearchTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:930:6-33
    return numpy.int32(54)
   if (_0=="intpntUpdateTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:931:6-29
    return numpy.int32(67)
   if (_0=="intpntFactorSetupTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:932:6-34
    return numpy.int32(46)
   if (_0=="intpntFactorSchurTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:933:6-34
    return numpy.int32(40)
   if (_0=="intpntFactorHatSchurTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:934:6-37
    return numpy.int32(37)
   if (_0=="intpntFactorHatSchurPushTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:935:6-41
    return numpy.int32(36)
   if (_0=="intpntFactorHatSchurPullTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:936:6-41
    return numpy.int32(34)
   if (_0=="intpntFactorBarSchurTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:937:6-37
    return numpy.int32(14)
   if (_0=="intpntFactorBarSchurDeTabTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:938:6-42
    return numpy.int32(11)
   if (_0=="intpntFactorBarSchurSpTabTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:939:6-42
    return numpy.int32(13)
   if (_0=="intpntFactorSparseLTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:940:6-36
    return numpy.int32(50)
   if (_0=="intpntFactorSparseLUpdateLastTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:941:6-46
    return numpy.int32(52)
   if (_0=="intpntFactorSparseLFactorLastTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:942:6-46
    return numpy.int32(48)
   if (_0=="intpntFactorDenseLTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:943:6-35
    return numpy.int32(29)
   if (_0=="intpntFactorDenseTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:944:6-34
    return numpy.int32(30)
   if (_0=="intpntFactorDenseDotaTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:945:6-38
    return numpy.int32(17)
   if (_0=="intpntFactorDenseDotaSolveTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:946:6-43
    return numpy.int32(16)
   if (_0=="intpntFactorDenseDotatdotaTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:947:6-43
    return numpy.int32(19)
   if (_0=="intpntFactorDenseDotlInitTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:948:6-42
    return numpy.int32(26)
   if (_0=="intpntFactorDenseDotlFactorTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:949:6-44
    return numpy.int32(25)
   if (_0=="intpntIterNonCorrectorFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:950:6-40
    return numpy.int32(59)
   if (_0=="intpntIterOneCorrectorFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:951:6-40
    return numpy.int32(60)
   if (_0=="intpntSolveTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:952:6-28
    return numpy.int32(66)
   if (_0=="intpntIterRefTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:953:6-30
    return numpy.int32(61)
   if (_0=="intpntSolveSparseLTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:954:6-35
    return numpy.int32(65)
   if (_0=="intpntSolveDenseLTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:955:6-34
    return numpy.int32(64)
   if (_0=="intpntFactorSetupFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:956:6-35
    return numpy.int32(42)
   if (_0=="intpntFactorSetupHatSchurFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:957:6-43
    return numpy.int32(44)
   if (_0=="intpntFactorSchurFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:958:6-35
    return numpy.int32(39)
   if (_0=="intpntFactorHatSchurFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:959:6-38
    return numpy.int32(32)
   if (_0=="intpntFactorHatSchurPushFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:960:6-42
    return numpy.int32(35)
   if (_0=="intpntFactorHatSchurPullFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:961:6-42
    return numpy.int32(33)
   if (_0=="intpntFactorBarSchurFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:962:6-38
    return numpy.int32(12)
   if (_0=="intpntFactorSparseLFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:963:6-37
    return numpy.int32(49)
   if (_0=="intpntFactorMlOrderSparseLFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:964:6-44
    return numpy.int32(38)
   if (_0=="intpntFactorGpOrderSparseLFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:965:6-44
    return numpy.int32(31)
   if (_0=="intpntFactorSparseLUpdateLastFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:966:6-47
    return numpy.int32(51)
   if (_0=="intpntFactorSparseLFactorLastFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:967:6-47
    return numpy.int32(47)
   if (_0=="intpntFactorDenseLFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:968:6-36
    return numpy.int32(28)
   if (_0=="intpntFactorDenseFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:969:6-35
    return numpy.int32(27)
   if (_0=="intpntFactorDenseDotaFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:970:6-39
    return numpy.int32(15)
   if (_0=="intpntFactorDenseDotatdotaFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:971:6-44
    return numpy.int32(18)
   if (_0=="intpntFactorDenseDotlFactor_initFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:972:6-50
    return numpy.int32(23)
   if (_0=="intpntFactorDenseDotlFactorFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:973:6-45
    return numpy.int32(24)
   if (_0=="intpntFactorDenseDotl11FactorFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:974:6-47
    return numpy.int32(20)
   if (_0=="intpntFactorDenseDotl21FactorFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:975:6-47
    return numpy.int32(21)
   if (_0=="intpntFactorDenseDotl22FactorFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:976:6-47
    return numpy.int32(22)
   if (_0=="presolveAcoltTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:977:6-30
    return numpy.int32(68)
   if (_0=="presolveSetupTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:978:6-30
    return numpy.int32(73)
   if (_0=="presolveCheckproTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:979:6-33
    return numpy.int32(69)
   if (_0=="presolveDupconTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:980:6-31
    return numpy.int32(70)
   if (_0=="presolveDupvarTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:981:6-31
    return numpy.int32(71)
   if (_0=="presolveFinalTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:982:6-30
    return numpy.int32(72)
   if (_0=="presolveSubDomvarTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:983:6-34
    return numpy.int32(74)
   if (_0=="presolveSubRelaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:984:6-33
    return numpy.int32(75)
   if (_0=="primalSimplexInftime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:985:6-33
    return numpy.int32(76)
   if (_0=="dualSimplexInftime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:986:6-31
    return numpy.int32(10)
   if (_0=="intpntGpOrderSavedFlops"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:987:6-36
    return numpy.int32(56)
   if (_0=="intpntFactorSetupDetectDenseTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:988:6-45
    return numpy.int32(41)
   if (_0=="intpntFactorSetupMlOrderTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:989:6-41
    return numpy.int32(45)
   if (_0=="intpntFactorSetupGpOrderTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:990:6-41
    return numpy.int32(43)
   if (_0=="biCrashTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:991:6-24
    return numpy.int32(1)
   if (_0=="biCrashLuTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:992:6-26
    return numpy.int32(0)
   if (_0=="biFactorTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:993:6-25
    return numpy.int32(5)
   if (_0=="biFactorWork"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:994:6-25
    return numpy.int32(6)
   if (_0=="biPrimalDone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:995:6-25
    return numpy.int32(7)
   if (_0=="biDualDone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:996:6-23
    return numpy.int32(2)
   if (_0=="simPrimalObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:997:6-25
    return numpy.int32(82)
   if (_0=="simPrimalFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:998:6-26
    return numpy.int32(81)
   if (_0=="simDualObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:999:6-23
    return numpy.int32(80)
   if (_0=="simDualFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1000:6-24
    return numpy.int32(79)
   if (_0=="biPrimalObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1001:6-24
    return numpy.int32(9)
   if (_0=="biDualObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1002:6-22
    return numpy.int32(4)
   if (_0=="biPrimalFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1003:6-25
    return numpy.int32(8)
   if (_0=="biDualFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1004:6-23
    return numpy.int32(3)
   if (_0=="intpntPurifyTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:1005:6-29
    return numpy.int32(63)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingtype_1value_S(_0):
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:915:6-17
    return numpy.int32(0)
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:916:6-17
    return numpy.int32(1)
   if (_0=="moderate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:917:6-21
    return numpy.int32(2)
   if (_0=="aggressive"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:918:6-23
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mark_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mark_1value_S(_0)
  @staticmethod
  def __string_1to_1mark_1value_S(_0):
   if (_0=="lo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:909:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:910:6-15
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1branchdir_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1branchdir_1value_S(_0)
  @staticmethod
  def __string_1to_1branchdir_1value_S(_0):
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:897:6-17
    return numpy.int32(0)
   if (_0=="up"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:898:6-15
    return numpy.int32(1)
   if (_0=="down"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:899:6-17
    return numpy.int32(2)
   if (_0=="near"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:900:6-17
    return numpy.int32(3)
   if (_0=="far"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:901:6-16
    return numpy.int32(4)
   if (_0=="rootLp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:902:6-19
    return numpy.int32(5)
   if (_0=="guided"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:903:6-19
    return numpy.int32(6)
   if (_0=="pseudocost"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:904:6-23
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemtype_1value_S(_0)
  @staticmethod
  def __string_1to_1problemtype_1value_S(_0):
   if (_0=="lo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:888:6-15
    return numpy.int32(0)
   if (_0=="qo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:889:6-15
    return numpy.int32(1)
   if (_0=="qcqo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:890:6-17
    return numpy.int32(2)
   if (_0=="conic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:891:6-18
    return numpy.int32(3)
   if (_0=="mixed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:892:6-18
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1inftype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1inftype_1value_S(_0)
  @staticmethod
  def __string_1to_1inftype_1value_S(_0):
   if (_0=="douType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:881:6-20
    return numpy.int32(0)
   if (_0=="intType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:882:6-20
    return numpy.int32(1)
   if (_0=="lintType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:883:6-21
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1conetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1conetype_1value_S(_0)
  @staticmethod
  def __string_1to_1conetype_1value_S(_0):
   if (_0=="quad"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:870:6-17
    return numpy.int32(0)
   if (_0=="rquad"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:871:6-18
    return numpy.int32(1)
   if (_0=="pexp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:872:6-17
    return numpy.int32(2)
   if (_0=="dexp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:873:6-17
    return numpy.int32(3)
   if (_0=="ppow"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:874:6-17
    return numpy.int32(4)
   if (_0=="dpow"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:875:6-17
    return numpy.int32(5)
   if (_0=="zero"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:876:6-17
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1onoffkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1onoffkey_1value_S(_0)
  @staticmethod
  def __string_1to_1onoffkey_1value_S(_0):
   if (_0=="on"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:864:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:865:6-16
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simhotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simhotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1simhotstart_1value_S(_0):
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:857:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:858:6-17
    return numpy.int32(1)
   if (_0=="statusKeys"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:859:6-23
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solveform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solveform_1value_S(_0)
  @staticmethod
  def __string_1to_1solveform_1value_S(_0):
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:850:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:851:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:852:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1iinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1iinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1iinf_1value_S(_0):
   if (_0=="versionMajor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:748:6-25
    return numpy.int32(95)
   if (_0=="versionMinor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:749:6-25
    return numpy.int32(96)
   if (_0=="versionRevision"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:750:6-28
    return numpy.int32(97)
   if (_0=="presolveLindepWork"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:751:6-31
    return numpy.int32(60)
   if (_0=="presolveLindepPivots"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:752:6-33
    return numpy.int32(58)
   if (_0=="presolveLindepSkipped"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:753:6-34
    return numpy.int32(59)
   if (_0=="presolveOutofspace"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:754:6-31
    return numpy.int32(80)
   if (_0=="presolveBadPrecision"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:755:6-33
    return numpy.int32(32)
   if (_0=="optObjectiveSense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:756:6-30
    return numpy.int32(30)
   if (_0=="optimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:757:6-22
    return numpy.int32(31)
   if (_0=="intpntFirRefIter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:758:6-29
    return numpy.int32(9)
   if (_0=="intpntNumRefSteps"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:759:6-30
    return numpy.int32(14)
   if (_0=="intpntFactorDim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:760:6-28
    return numpy.int32(2)
   if (_0=="intpntFactorSchurNumSingular"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:761:6-41
    return numpy.int32(8)
   if (_0=="intpntFactorNumDenseA"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:762:6-34
    return numpy.int32(4)
   if (_0=="intpntFactorNumDenseADup"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:763:6-37
    return numpy.int32(5)
   if (_0=="intpntFactorNumDenseW"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:764:6-34
    return numpy.int32(6)
   if (_0=="intpntNumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:765:6-25
    return numpy.int32(21)
   if (_0=="intpntNumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:766:6-25
    return numpy.int32(28)
   if (_0=="intpntNumbarvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:767:6-28
    return numpy.int32(15)
   if (_0=="intpntNumblo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:768:6-25
    return numpy.int32(18)
   if (_0=="intpntNumbup"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:769:6-25
    return numpy.int32(20)
   if (_0=="intpntNumbfr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:770:6-25
    return numpy.int32(16)
   if (_0=="intpntNumbfx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:771:6-25
    return numpy.int32(17)
   if (_0=="intpntNumcone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:772:6-26
    return numpy.int32(22)
   if (_0=="intpntNumconevar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:773:6-29
    return numpy.int32(23)
   if (_0=="intpntNumbndcone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:774:6-29
    return numpy.int32(19)
   if (_0=="intpntNumrqcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:775:6-29
    return numpy.int32(27)
   if (_0=="intpntNumqcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:776:6-28
    return numpy.int32(26)
   if (_0=="intpntNumpexpcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:777:6-31
    return numpy.int32(24)
   if (_0=="intpntNumppowcones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:778:6-31
    return numpy.int32(25)
   if (_0=="intpntMinconedim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:779:6-29
    return numpy.int32(13)
   if (_0=="intpntMaxconedim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:780:6-29
    return numpy.int32(12)
   if (_0=="intpntMaxbarvardim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:781:6-31
    return numpy.int32(11)
   if (_0=="presolveNumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:782:6-27
    return numpy.int32(69)
   if (_0=="presolveNumcfr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:783:6-27
    return numpy.int32(65)
   if (_0=="presolveNumcfx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:784:6-27
    return numpy.int32(66)
   if (_0=="presolveNumclo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:785:6-27
    return numpy.int32(67)
   if (_0=="presolveNumcup"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:786:6-27
    return numpy.int32(71)
   if (_0=="presolveNumcra"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:787:6-27
    return numpy.int32(70)
   if (_0=="presolveNumcnl"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:788:6-27
    return numpy.int32(68)
   if (_0=="presolveNumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:789:6-27
    return numpy.int32(73)
   if (_0=="presolveNumvfr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:790:6-27
    return numpy.int32(74)
   if (_0=="presolveNumvfx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:791:6-27
    return numpy.int32(75)
   if (_0=="presolveNumvlo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:792:6-27
    return numpy.int32(76)
   if (_0=="presolveNumvup"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:793:6-27
    return numpy.int32(79)
   if (_0=="presolveNumvra"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:794:6-27
    return numpy.int32(78)
   if (_0=="presolveNumvnl"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:795:6-27
    return numpy.int32(77)
   if (_0=="presolveNumnza"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:796:6-27
    return numpy.int32(72)
   if (_0=="presolveFnumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:797:6-28
    return numpy.int32(40)
   if (_0=="presolveFnumcfr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:798:6-28
    return numpy.int32(36)
   if (_0=="presolveFnumcfx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:799:6-28
    return numpy.int32(37)
   if (_0=="presolveFnumclo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:800:6-28
    return numpy.int32(38)
   if (_0=="presolveFnumcup"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:801:6-28
    return numpy.int32(42)
   if (_0=="presolveFnumcra"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:802:6-28
    return numpy.int32(41)
   if (_0=="presolveFnumcnl"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:803:6-28
    return numpy.int32(39)
   if (_0=="presolveFnumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:804:6-28
    return numpy.int32(44)
   if (_0=="presolveFnumvfr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:805:6-28
    return numpy.int32(45)
   if (_0=="presolveFnumvfx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:806:6-28
    return numpy.int32(46)
   if (_0=="presolveFnumvlo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:807:6-28
    return numpy.int32(47)
   if (_0=="presolveFnumvup"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:808:6-28
    return numpy.int32(50)
   if (_0=="presolveFnumvra"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:809:6-28
    return numpy.int32(49)
   if (_0=="presolveFnumvnl"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:810:6-28
    return numpy.int32(48)
   if (_0=="presolveFnumnza"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:811:6-28
    return numpy.int32(43)
   if (_0=="presolveNumElimns"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:812:6-30
    return numpy.int32(62)
   if (_0=="presolveEliNumTries"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:813:6-32
    return numpy.int32(35)
   if (_0=="presolveEliNumFreedCon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:814:6-35
    return numpy.int32(33)
   if (_0=="presolveEliNumFreedConTotal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:815:6-40
    return numpy.int32(34)
   if (_0=="presolveLindepNumTries"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:816:6-35
    return numpy.int32(56)
   if (_0=="presolveLindepNum"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:817:6-30
    return numpy.int32(55)
   if (_0=="presolveForceConNum"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:818:6-32
    return numpy.int32(51)
   if (_0=="presolveForceConNumVar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:819:6-35
    return numpy.int32(52)
   if (_0=="presolveForceVarNum"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:820:6-32
    return numpy.int32(53)
   if (_0=="presolveForceVarNumCon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:821:6-35
    return numpy.int32(54)
   if (_0=="presolvePivOnConNum"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:822:6-32
    return numpy.int32(81)
   if (_0=="presolveNumDouBlocks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:823:6-33
    return numpy.int32(61)
   if (_0=="presolveNumSimplifiedDouBlocks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:824:6-43
    return numpy.int32(64)
   if (_0=="presolveSizeSimplifiedDouBlocks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:825:6-44
    return numpy.int32(82)
   if (_0=="presolveNumQuadConeOrthoTrans"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:826:6-42
    return numpy.int32(63)
   if (_0=="intpntFactorNum"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:827:6-28
    return numpy.int32(3)
   if (_0=="intpntFactorNumSolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:828:6-33
    return numpy.int32(7)
   if (_0=="simPrimalHotstartNumBasics"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:829:6-39
    return numpy.int32(92)
   if (_0=="simPrimalHotstartBasisRank"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:830:6-39
    return numpy.int32(91)
   if (_0=="simDualHotstartNumBasics"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:831:6-37
    return numpy.int32(84)
   if (_0=="simDualHotstartBasisRank"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:832:6-37
    return numpy.int32(83)
   if (_0=="intpntGpOrderEmployed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:833:6-34
    return numpy.int32(10)
   if (_0=="numLuFactorizations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:834:6-32
    return numpy.int32(29)
   if (_0=="simPrimalTrust"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:835:6-27
    return numpy.int32(94)
   if (_0=="simDualTrust"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:836:6-25
    return numpy.int32(86)
   if (_0=="simPrimalNumSetbacks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:837:6-33
    return numpy.int32(93)
   if (_0=="simDualNumSetbacks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:838:6-31
    return numpy.int32(85)
   if (_0=="simNumDupvec"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:839:6-25
    return numpy.int32(89)
   if (_0=="simNumPrimalBoundswaps"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:840:6-35
    return numpy.int32(90)
   if (_0=="simNumDualBoundswaps"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:841:6-33
    return numpy.int32(87)
   if (_0=="simNumDualIntegerPivots"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:842:6-36
    return numpy.int32(88)
   if (_0=="biPrimalInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:843:6-25
    return numpy.int32(1)
   if (_0=="biDualInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:844:6-23
    return numpy.int32(0)
   if (_0=="presolveLindepNumTruncTries"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:845:6-40
    return numpy.int32(57)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1symmattype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1symmattype_1value_S(_0)
  @staticmethod
  def __string_1to_1symmattype_1value_S(_0):
   if (_0=="sparse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:743:6-19
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescode_1value_S(_0)
  @staticmethod
  def __string_1to_1rescode_1value_S(_0):
   if (_0=="ok"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:281:6-15
    return numpy.int32(0)
   if (_0=="wrnOpenParamFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:282:6-29
    return numpy.int32(50)
   if (_0=="wrnLargeBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:283:6-26
    return numpy.int32(51)
   if (_0=="wrnLargeLoBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:284:6-28
    return numpy.int32(52)
   if (_0=="wrnLargeUpBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:285:6-28
    return numpy.int32(53)
   if (_0=="wrnLargeConFx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:286:6-26
    return numpy.int32(54)
   if (_0=="wrnLargeCj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:287:6-23
    return numpy.int32(57)
   if (_0=="wrnLargeAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:288:6-24
    return numpy.int32(62)
   if (_0=="wrnZeroAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:289:6-23
    return numpy.int32(63)
   if (_0=="wrnNameMaxLen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:290:6-26
    return numpy.int32(65)
   if (_0=="wrnSparMaxLen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:291:6-26
    return numpy.int32(66)
   if (_0=="wrnMpsSplitRhsVector"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:292:6-33
    return numpy.int32(70)
   if (_0=="wrnMpsSplitRanVector"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:293:6-33
    return numpy.int32(71)
   if (_0=="wrnMpsSplitBouVector"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:294:6-33
    return numpy.int32(72)
   if (_0=="wrnLpOldQuadFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:295:6-31
    return numpy.int32(80)
   if (_0=="wrnLpDropVariable"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:296:6-30
    return numpy.int32(85)
   if (_0=="wrnNzInUprTri"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:297:6-26
    return numpy.int32(200)
   if (_0=="wrnDroppedNzQobj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:298:6-29
    return numpy.int32(201)
   if (_0=="wrnIgnoreInteger"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:299:6-29
    return numpy.int32(250)
   if (_0=="wrnNoGlobalOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:300:6-33
    return numpy.int32(251)
   if (_0=="wrnMioInfeasibleFinal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:301:6-34
    return numpy.int32(270)
   if (_0=="wrnSolFilter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:302:6-25
    return numpy.int32(300)
   if (_0=="wrnUndefSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:303:6-32
    return numpy.int32(350)
   if (_0=="wrnSolFileIgnoredCon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:304:6-33
    return numpy.int32(351)
   if (_0=="wrnSolFileIgnoredVar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:305:6-33
    return numpy.int32(352)
   if (_0=="wrnTooFewBasisVars"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:306:6-31
    return numpy.int32(400)
   if (_0=="wrnTooManyBasisVars"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:307:6-32
    return numpy.int32(405)
   if (_0=="wrnLicenseExpire"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:308:6-29
    return numpy.int32(500)
   if (_0=="wrnLicenseServer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:309:6-29
    return numpy.int32(501)
   if (_0=="wrnEmptyName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:310:6-25
    return numpy.int32(502)
   if (_0=="wrnUsingGenericNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:311:6-33
    return numpy.int32(503)
   if (_0=="wrnLicenseFeatureExpire"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:312:6-36
    return numpy.int32(505)
   if (_0=="wrnParamNameDou"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:313:6-28
    return numpy.int32(510)
   if (_0=="wrnParamNameInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:314:6-28
    return numpy.int32(511)
   if (_0=="wrnParamNameStr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:315:6-28
    return numpy.int32(512)
   if (_0=="wrnParamStrValue"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:316:6-29
    return numpy.int32(515)
   if (_0=="wrnParamIgnoredCmio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:317:6-32
    return numpy.int32(516)
   if (_0=="wrnZerosInSparseRow"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:318:6-32
    return numpy.int32(705)
   if (_0=="wrnZerosInSparseCol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:319:6-32
    return numpy.int32(710)
   if (_0=="wrnIncompleteLinearDependencyCheck"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:320:6-47
    return numpy.int32(800)
   if (_0=="wrnEliminatorSpace"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:321:6-31
    return numpy.int32(801)
   if (_0=="wrnPresolveOutofspace"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:322:6-34
    return numpy.int32(802)
   if (_0=="wrnWriteChangedNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:323:6-33
    return numpy.int32(803)
   if (_0=="wrnWriteDiscardedCfix"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:324:6-34
    return numpy.int32(804)
   if (_0=="wrnDuplicateConstraintNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:325:6-40
    return numpy.int32(850)
   if (_0=="wrnDuplicateVariableNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:326:6-38
    return numpy.int32(851)
   if (_0=="wrnDuplicateBarvariableNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:327:6-41
    return numpy.int32(852)
   if (_0=="wrnDuplicateConeNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:328:6-34
    return numpy.int32(853)
   if (_0=="wrnAnaLargeBounds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:329:6-30
    return numpy.int32(900)
   if (_0=="wrnAnaCZero"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:330:6-24
    return numpy.int32(901)
   if (_0=="wrnAnaEmptyCols"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:331:6-28
    return numpy.int32(902)
   if (_0=="wrnAnaCloseBounds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:332:6-30
    return numpy.int32(903)
   if (_0=="wrnAnaAlmostIntBounds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:333:6-34
    return numpy.int32(904)
   if (_0=="wrnQuadConesWithRootFixedAtZero"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:334:6-44
    return numpy.int32(930)
   if (_0=="wrnRquadConesWithRootFixedAtZero"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:335:6-45
    return numpy.int32(931)
   if (_0=="wrnExpConesWithVariablesFixedAtZero"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:336:6-48
    return numpy.int32(932)
   if (_0=="wrnPowConesWithRootFixedAtZero"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:337:6-43
    return numpy.int32(933)
   if (_0=="wrnNoDualizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:338:6-26
    return numpy.int32(950)
   if (_0=="wrnSymMatLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:339:6-27
    return numpy.int32(960)
   if (_0=="errLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:340:6-23
    return numpy.int32(1000)
   if (_0=="errLicenseExpired"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:341:6-30
    return numpy.int32(1001)
   if (_0=="errLicenseVersion"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:342:6-30
    return numpy.int32(1002)
   if (_0=="errSizeLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:343:6-27
    return numpy.int32(1005)
   if (_0=="errProbLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:344:6-27
    return numpy.int32(1006)
   if (_0=="errFileLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:345:6-27
    return numpy.int32(1007)
   if (_0=="errMissingLicenseFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:346:6-34
    return numpy.int32(1008)
   if (_0=="errSizeLicenseCon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:347:6-30
    return numpy.int32(1010)
   if (_0=="errSizeLicenseVar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:348:6-30
    return numpy.int32(1011)
   if (_0=="errSizeLicenseIntvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:349:6-33
    return numpy.int32(1012)
   if (_0=="errOptimizerLicense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:350:6-32
    return numpy.int32(1013)
   if (_0=="errFlexlm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:351:6-22
    return numpy.int32(1014)
   if (_0=="errLicenseServer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:352:6-29
    return numpy.int32(1015)
   if (_0=="errLicenseMax"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:353:6-26
    return numpy.int32(1016)
   if (_0=="errLicenseMoseklmDaemon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:354:6-36
    return numpy.int32(1017)
   if (_0=="errLicenseFeature"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:355:6-30
    return numpy.int32(1018)
   if (_0=="errPlatformNotLicensed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:356:6-35
    return numpy.int32(1019)
   if (_0=="errLicenseCannotAllocate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:357:6-37
    return numpy.int32(1020)
   if (_0=="errLicenseCannotConnect"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:358:6-36
    return numpy.int32(1021)
   if (_0=="errLicenseInvalidHostid"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:359:6-36
    return numpy.int32(1025)
   if (_0=="errLicenseServerVersion"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:360:6-36
    return numpy.int32(1026)
   if (_0=="errLicenseNoServerSupport"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:361:6-38
    return numpy.int32(1027)
   if (_0=="errLicenseNoServerLine"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:362:6-35
    return numpy.int32(1028)
   if (_0=="errOlderDll"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:363:6-24
    return numpy.int32(1035)
   if (_0=="errNewerDll"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:364:6-24
    return numpy.int32(1036)
   if (_0=="errLinkFileDll"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:365:6-27
    return numpy.int32(1040)
   if (_0=="errThreadMutexInit"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:366:6-31
    return numpy.int32(1045)
   if (_0=="errThreadMutexLock"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:367:6-31
    return numpy.int32(1046)
   if (_0=="errThreadMutexUnlock"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:368:6-33
    return numpy.int32(1047)
   if (_0=="errThreadCreate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:369:6-28
    return numpy.int32(1048)
   if (_0=="errThreadCondInit"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:370:6-30
    return numpy.int32(1049)
   if (_0=="errUnknown"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:371:6-23
    return numpy.int32(1050)
   if (_0=="errSpace"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:372:6-21
    return numpy.int32(1051)
   if (_0=="errFileOpen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:373:6-24
    return numpy.int32(1052)
   if (_0=="errFileRead"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:374:6-24
    return numpy.int32(1053)
   if (_0=="errFileWrite"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:375:6-25
    return numpy.int32(1054)
   if (_0=="errDataFileExt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:376:6-27
    return numpy.int32(1055)
   if (_0=="errInvalidFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:377:6-31
    return numpy.int32(1056)
   if (_0=="errInvalidSolFileName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:378:6-34
    return numpy.int32(1057)
   if (_0=="errEndOfFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:379:6-25
    return numpy.int32(1059)
   if (_0=="errNullEnv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:380:6-23
    return numpy.int32(1060)
   if (_0=="errNullTask"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:381:6-24
    return numpy.int32(1061)
   if (_0=="errInvalidStream"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:382:6-29
    return numpy.int32(1062)
   if (_0=="errNoInitEnv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:383:6-25
    return numpy.int32(1063)
   if (_0=="errInvalidTask"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:384:6-27
    return numpy.int32(1064)
   if (_0=="errNullPointer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:385:6-27
    return numpy.int32(1065)
   if (_0=="errLivingTasks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:386:6-27
    return numpy.int32(1066)
   if (_0=="errBlankName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:387:6-25
    return numpy.int32(1070)
   if (_0=="errDupName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:388:6-23
    return numpy.int32(1071)
   if (_0=="errFormatString"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:389:6-28
    return numpy.int32(1072)
   if (_0=="errInvalidObjName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:390:6-30
    return numpy.int32(1075)
   if (_0=="errInvalidConName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:391:6-30
    return numpy.int32(1076)
   if (_0=="errInvalidVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:392:6-30
    return numpy.int32(1077)
   if (_0=="errInvalidConeName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:393:6-31
    return numpy.int32(1078)
   if (_0=="errInvalidBarvarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:394:6-33
    return numpy.int32(1079)
   if (_0=="errSpaceLeaking"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:395:6-28
    return numpy.int32(1080)
   if (_0=="errSpaceNoInfo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:396:6-27
    return numpy.int32(1081)
   if (_0=="errReadFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:397:6-26
    return numpy.int32(1090)
   if (_0=="errMpsFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:398:6-23
    return numpy.int32(1100)
   if (_0=="errMpsInvField"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:399:6-27
    return numpy.int32(1101)
   if (_0=="errMpsInvMarker"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:400:6-28
    return numpy.int32(1102)
   if (_0=="errMpsNullConName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:401:6-30
    return numpy.int32(1103)
   if (_0=="errMpsNullVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:402:6-30
    return numpy.int32(1104)
   if (_0=="errMpsUndefConName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:403:6-31
    return numpy.int32(1105)
   if (_0=="errMpsUndefVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:404:6-31
    return numpy.int32(1106)
   if (_0=="errMpsInvConKey"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:405:6-28
    return numpy.int32(1107)
   if (_0=="errMpsInvBoundKey"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:406:6-30
    return numpy.int32(1108)
   if (_0=="errMpsInvSecName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:407:6-29
    return numpy.int32(1109)
   if (_0=="errMpsNoObjective"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:408:6-30
    return numpy.int32(1110)
   if (_0=="errMpsSplittedVar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:409:6-30
    return numpy.int32(1111)
   if (_0=="errMpsMulConName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:410:6-29
    return numpy.int32(1112)
   if (_0=="errMpsMulQsec"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:411:6-26
    return numpy.int32(1113)
   if (_0=="errMpsMulQobj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:412:6-26
    return numpy.int32(1114)
   if (_0=="errMpsInvSecOrder"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:413:6-30
    return numpy.int32(1115)
   if (_0=="errMpsMulCsec"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:414:6-26
    return numpy.int32(1116)
   if (_0=="errMpsConeType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:415:6-27
    return numpy.int32(1117)
   if (_0=="errMpsConeOverlap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:416:6-30
    return numpy.int32(1118)
   if (_0=="errMpsConeRepeat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:417:6-29
    return numpy.int32(1119)
   if (_0=="errMpsNonSymmetricQ"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:418:6-32
    return numpy.int32(1120)
   if (_0=="errMpsDuplicateQElement"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:419:6-36
    return numpy.int32(1121)
   if (_0=="errMpsInvalidObjsense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:420:6-34
    return numpy.int32(1122)
   if (_0=="errMpsTabInField2"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:421:6-30
    return numpy.int32(1125)
   if (_0=="errMpsTabInField3"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:422:6-30
    return numpy.int32(1126)
   if (_0=="errMpsTabInField5"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:423:6-30
    return numpy.int32(1127)
   if (_0=="errMpsInvalidObjName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:424:6-33
    return numpy.int32(1128)
   if (_0=="errLpIncompatible"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:425:6-30
    return numpy.int32(1150)
   if (_0=="errLpEmpty"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:426:6-23
    return numpy.int32(1151)
   if (_0=="errLpDupSlackName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:427:6-30
    return numpy.int32(1152)
   if (_0=="errWriteMpsInvalidName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:428:6-35
    return numpy.int32(1153)
   if (_0=="errLpInvalidVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:429:6-32
    return numpy.int32(1154)
   if (_0=="errLpFreeConstraint"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:430:6-32
    return numpy.int32(1155)
   if (_0=="errWriteOpfInvalidVarName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:431:6-38
    return numpy.int32(1156)
   if (_0=="errLpFileFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:432:6-28
    return numpy.int32(1157)
   if (_0=="errWriteLpFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:433:6-29
    return numpy.int32(1158)
   if (_0=="errReadLpMissingEndTag"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:434:6-35
    return numpy.int32(1159)
   if (_0=="errLpFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:435:6-24
    return numpy.int32(1160)
   if (_0=="errWriteLpNonUniqueName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:436:6-36
    return numpy.int32(1161)
   if (_0=="errReadLpNonexistingName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:437:6-37
    return numpy.int32(1162)
   if (_0=="errLpWriteConicProblem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:438:6-35
    return numpy.int32(1163)
   if (_0=="errLpWriteGecoProblem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:439:6-34
    return numpy.int32(1164)
   if (_0=="errWritingFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:440:6-27
    return numpy.int32(1166)
   if (_0=="errPtfFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:441:6-25
    return numpy.int32(1167)
   if (_0=="errOpfFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:442:6-25
    return numpy.int32(1168)
   if (_0=="errOpfNewVariable"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:443:6-30
    return numpy.int32(1169)
   if (_0=="errInvalidNameInSolFile"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:444:6-36
    return numpy.int32(1170)
   if (_0=="errLpInvalidConName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:445:6-32
    return numpy.int32(1171)
   if (_0=="errOpfPrematureEof"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:446:6-31
    return numpy.int32(1172)
   if (_0=="errJsonSyntax"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:447:6-26
    return numpy.int32(1175)
   if (_0=="errJsonString"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:448:6-26
    return numpy.int32(1176)
   if (_0=="errJsonNumberOverflow"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:449:6-34
    return numpy.int32(1177)
   if (_0=="errJsonFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:450:6-26
    return numpy.int32(1178)
   if (_0=="errJsonData"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:451:6-24
    return numpy.int32(1179)
   if (_0=="errJsonMissingData"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:452:6-31
    return numpy.int32(1180)
   if (_0=="errArgumentLenneq"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:453:6-30
    return numpy.int32(1197)
   if (_0=="errArgumentType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:454:6-28
    return numpy.int32(1198)
   if (_0=="errNumArguments"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:455:6-28
    return numpy.int32(1199)
   if (_0=="errInArgument"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:456:6-26
    return numpy.int32(1200)
   if (_0=="errArgumentDimension"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:457:6-33
    return numpy.int32(1201)
   if (_0=="errShapeIsTooLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:458:6-31
    return numpy.int32(1202)
   if (_0=="errIndexIsTooSmall"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:459:6-31
    return numpy.int32(1203)
   if (_0=="errIndexIsTooLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:460:6-31
    return numpy.int32(1204)
   if (_0=="errParamName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:461:6-25
    return numpy.int32(1205)
   if (_0=="errParamNameDou"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:462:6-28
    return numpy.int32(1206)
   if (_0=="errParamNameInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:463:6-28
    return numpy.int32(1207)
   if (_0=="errParamNameStr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:464:6-28
    return numpy.int32(1208)
   if (_0=="errParamIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:465:6-26
    return numpy.int32(1210)
   if (_0=="errParamIsTooLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:466:6-31
    return numpy.int32(1215)
   if (_0=="errParamIsTooSmall"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:467:6-31
    return numpy.int32(1216)
   if (_0=="errParamValueStr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:468:6-29
    return numpy.int32(1217)
   if (_0=="errParamType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:469:6-25
    return numpy.int32(1218)
   if (_0=="errInfDouIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:470:6-27
    return numpy.int32(1219)
   if (_0=="errInfIntIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:471:6-27
    return numpy.int32(1220)
   if (_0=="errIndexArrIsTooSmall"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:472:6-34
    return numpy.int32(1221)
   if (_0=="errIndexArrIsTooLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:473:6-34
    return numpy.int32(1222)
   if (_0=="errInfLintIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:474:6-28
    return numpy.int32(1225)
   if (_0=="errArgIsTooSmall"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:475:6-29
    return numpy.int32(1226)
   if (_0=="errArgIsTooLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:476:6-29
    return numpy.int32(1227)
   if (_0=="errInvalidWhichsol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:477:6-31
    return numpy.int32(1228)
   if (_0=="errInfDouName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:478:6-26
    return numpy.int32(1230)
   if (_0=="errInfIntName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:479:6-26
    return numpy.int32(1231)
   if (_0=="errInfType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:480:6-23
    return numpy.int32(1232)
   if (_0=="errInfLintName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:481:6-27
    return numpy.int32(1234)
   if (_0=="errIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:482:6-21
    return numpy.int32(1235)
   if (_0=="errWhichsol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:483:6-24
    return numpy.int32(1236)
   if (_0=="errSolitem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:484:6-23
    return numpy.int32(1237)
   if (_0=="errWhichitemNotAllowed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:485:6-35
    return numpy.int32(1238)
   if (_0=="errMaxnumcon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:486:6-25
    return numpy.int32(1240)
   if (_0=="errMaxnumvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:487:6-25
    return numpy.int32(1241)
   if (_0=="errMaxnumbarvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:488:6-28
    return numpy.int32(1242)
   if (_0=="errMaxnumqnz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:489:6-25
    return numpy.int32(1243)
   if (_0=="errTooSmallMaxNumNz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:490:6-32
    return numpy.int32(1245)
   if (_0=="errInvalidIdx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:491:6-26
    return numpy.int32(1246)
   if (_0=="errInvalidMaxNum"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:492:6-29
    return numpy.int32(1247)
   if (_0=="errNumconlim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:493:6-25
    return numpy.int32(1250)
   if (_0=="errNumvarlim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:494:6-25
    return numpy.int32(1251)
   if (_0=="errTooSmallMaxnumanz"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:495:6-33
    return numpy.int32(1252)
   if (_0=="errInvAptre"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:496:6-24
    return numpy.int32(1253)
   if (_0=="errMulAElement"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:497:6-27
    return numpy.int32(1254)
   if (_0=="errInvBk"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:498:6-21
    return numpy.int32(1255)
   if (_0=="errInvBkc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:499:6-22
    return numpy.int32(1256)
   if (_0=="errInvBkx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:500:6-22
    return numpy.int32(1257)
   if (_0=="errInvVarType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:501:6-26
    return numpy.int32(1258)
   if (_0=="errSolverProbtype"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:502:6-30
    return numpy.int32(1259)
   if (_0=="errObjectiveRange"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:503:6-30
    return numpy.int32(1260)
   if (_0=="errUndefSolution"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:504:6-29
    return numpy.int32(1265)
   if (_0=="errBasis"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:505:6-21
    return numpy.int32(1266)
   if (_0=="errInvSkc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:506:6-22
    return numpy.int32(1267)
   if (_0=="errInvSkx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:507:6-22
    return numpy.int32(1268)
   if (_0=="errInvSkn"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:508:6-22
    return numpy.int32(1274)
   if (_0=="errInvSkStr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:509:6-24
    return numpy.int32(1269)
   if (_0=="errInvSk"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:510:6-21
    return numpy.int32(1270)
   if (_0=="errInvConeTypeStr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:511:6-30
    return numpy.int32(1271)
   if (_0=="errInvConeType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:512:6-27
    return numpy.int32(1272)
   if (_0=="errInvalidSurplus"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:513:6-30
    return numpy.int32(1275)
   if (_0=="errInvNameItem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:514:6-27
    return numpy.int32(1280)
   if (_0=="errProItem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:515:6-23
    return numpy.int32(1281)
   if (_0=="errInvalidFormatType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:516:6-33
    return numpy.int32(1283)
   if (_0=="errFirsti"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:517:6-22
    return numpy.int32(1285)
   if (_0=="errLasti"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:518:6-21
    return numpy.int32(1286)
   if (_0=="errFirstj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:519:6-22
    return numpy.int32(1287)
   if (_0=="errLastj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:520:6-21
    return numpy.int32(1288)
   if (_0=="errMaxLenIsTooSmall"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:521:6-32
    return numpy.int32(1289)
   if (_0=="errNonlinearEquality"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:522:6-33
    return numpy.int32(1290)
   if (_0=="errNonconvex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:523:6-25
    return numpy.int32(1291)
   if (_0=="errNonlinearRanged"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:524:6-31
    return numpy.int32(1292)
   if (_0=="errConQNotPsd"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:525:6-26
    return numpy.int32(1293)
   if (_0=="errConQNotNsd"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:526:6-26
    return numpy.int32(1294)
   if (_0=="errObjQNotPsd"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:527:6-26
    return numpy.int32(1295)
   if (_0=="errObjQNotNsd"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:528:6-26
    return numpy.int32(1296)
   if (_0=="errArgumentPermArray"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:529:6-33
    return numpy.int32(1299)
   if (_0=="errConeIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:530:6-25
    return numpy.int32(1300)
   if (_0=="errConeSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:531:6-24
    return numpy.int32(1301)
   if (_0=="errConeOverlap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:532:6-27
    return numpy.int32(1302)
   if (_0=="errConeRepVar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:533:6-26
    return numpy.int32(1303)
   if (_0=="errMaxnumcone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:534:6-26
    return numpy.int32(1304)
   if (_0=="errConeType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:535:6-24
    return numpy.int32(1305)
   if (_0=="errConeTypeStr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:536:6-27
    return numpy.int32(1306)
   if (_0=="errConeOverlapAppend"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:537:6-33
    return numpy.int32(1307)
   if (_0=="errRemoveConeVariable"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:538:6-34
    return numpy.int32(1310)
   if (_0=="errAppendingTooBigCone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:539:6-35
    return numpy.int32(1311)
   if (_0=="errConeParameter"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:540:6-29
    return numpy.int32(1320)
   if (_0=="errSolFileInvalidNumber"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:541:6-36
    return numpy.int32(1350)
   if (_0=="errHugeC"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:542:6-21
    return numpy.int32(1375)
   if (_0=="errHugeAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:543:6-23
    return numpy.int32(1380)
   if (_0=="errDuplicateAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:544:6-28
    return numpy.int32(1385)
   if (_0=="errLowerBoundIsANan"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:545:6-32
    return numpy.int32(1390)
   if (_0=="errUpperBoundIsANan"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:546:6-32
    return numpy.int32(1391)
   if (_0=="errInfiniteBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:547:6-29
    return numpy.int32(1400)
   if (_0=="errInvQobjSubi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:548:6-27
    return numpy.int32(1401)
   if (_0=="errInvQobjSubj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:549:6-27
    return numpy.int32(1402)
   if (_0=="errInvQobjVal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:550:6-26
    return numpy.int32(1403)
   if (_0=="errInvQconSubk"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:551:6-27
    return numpy.int32(1404)
   if (_0=="errInvQconSubi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:552:6-27
    return numpy.int32(1405)
   if (_0=="errInvQconSubj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:553:6-27
    return numpy.int32(1406)
   if (_0=="errInvQconVal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:554:6-26
    return numpy.int32(1407)
   if (_0=="errQconSubiTooSmall"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:555:6-32
    return numpy.int32(1408)
   if (_0=="errQconSubiTooLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:556:6-32
    return numpy.int32(1409)
   if (_0=="errQobjUpperTriangle"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:557:6-33
    return numpy.int32(1415)
   if (_0=="errQconUpperTriangle"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:558:6-33
    return numpy.int32(1417)
   if (_0=="errFixedBoundValues"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:559:6-32
    return numpy.int32(1420)
   if (_0=="errTooSmallATruncationValue"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:560:6-40
    return numpy.int32(1421)
   if (_0=="errInvalidObjectiveSense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:561:6-37
    return numpy.int32(1445)
   if (_0=="errUndefinedObjectiveSense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:562:6-39
    return numpy.int32(1446)
   if (_0=="errYIsUndefined"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:563:6-28
    return numpy.int32(1449)
   if (_0=="errNanInDoubleData"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:564:6-31
    return numpy.int32(1450)
   if (_0=="errNanInBlc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:565:6-24
    return numpy.int32(1461)
   if (_0=="errNanInBuc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:566:6-24
    return numpy.int32(1462)
   if (_0=="errNanInC"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:567:6-22
    return numpy.int32(1470)
   if (_0=="errNanInBlx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:568:6-24
    return numpy.int32(1471)
   if (_0=="errNanInBux"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:569:6-24
    return numpy.int32(1472)
   if (_0=="errInvalidAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:570:6-26
    return numpy.int32(1473)
   if (_0=="errSymMatInvalid"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:571:6-29
    return numpy.int32(1480)
   if (_0=="errSymMatHuge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:572:6-26
    return numpy.int32(1482)
   if (_0=="errInvProblem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:573:6-26
    return numpy.int32(1500)
   if (_0=="errMixedConicAndNl"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:574:6-31
    return numpy.int32(1501)
   if (_0=="errGlobalInvConicProblem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:575:6-37
    return numpy.int32(1503)
   if (_0=="errInvOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:576:6-28
    return numpy.int32(1550)
   if (_0=="errMioNoOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:577:6-30
    return numpy.int32(1551)
   if (_0=="errNoOptimizerVarType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:578:6-34
    return numpy.int32(1552)
   if (_0=="errFinalSolution"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:579:6-29
    return numpy.int32(1560)
   if (_0=="errFirst"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:580:6-21
    return numpy.int32(1570)
   if (_0=="errLast"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:581:6-20
    return numpy.int32(1571)
   if (_0=="errSliceSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:582:6-25
    return numpy.int32(1572)
   if (_0=="errNegativeSurplus"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:583:6-31
    return numpy.int32(1573)
   if (_0=="errNegativeAppend"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:584:6-30
    return numpy.int32(1578)
   if (_0=="errPostsolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:585:6-25
    return numpy.int32(1580)
   if (_0=="errOverflow"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:586:6-24
    return numpy.int32(1590)
   if (_0=="errNoBasisSol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:587:6-26
    return numpy.int32(1600)
   if (_0=="errBasisFactor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:588:6-27
    return numpy.int32(1610)
   if (_0=="errBasisSingular"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:589:6-29
    return numpy.int32(1615)
   if (_0=="errFactor"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:590:6-22
    return numpy.int32(1650)
   if (_0=="errFeasrepairCannotRelax"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:591:6-37
    return numpy.int32(1700)
   if (_0=="errFeasrepairSolvingRelaxed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:592:6-40
    return numpy.int32(1701)
   if (_0=="errFeasrepairInconsistentBound"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:593:6-43
    return numpy.int32(1702)
   if (_0=="errRepairInvalidProblem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:594:6-36
    return numpy.int32(1710)
   if (_0=="errRepairOptimizationFailed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:595:6-40
    return numpy.int32(1711)
   if (_0=="errNameMaxLen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:596:6-26
    return numpy.int32(1750)
   if (_0=="errNameIsNull"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:597:6-26
    return numpy.int32(1760)
   if (_0=="errInvalidCompression"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:598:6-34
    return numpy.int32(1800)
   if (_0=="errInvalidIomode"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:599:6-29
    return numpy.int32(1801)
   if (_0=="errNoPrimalInfeasCer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:600:6-33
    return numpy.int32(2000)
   if (_0=="errNoDualInfeasCer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:601:6-31
    return numpy.int32(2001)
   if (_0=="errNoSolutionInCallback"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:602:6-36
    return numpy.int32(2500)
   if (_0=="errInvMarki"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:603:6-24
    return numpy.int32(2501)
   if (_0=="errInvMarkj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:604:6-24
    return numpy.int32(2502)
   if (_0=="errInvNumi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:605:6-23
    return numpy.int32(2503)
   if (_0=="errInvNumj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:606:6-23
    return numpy.int32(2504)
   if (_0=="errTaskIncompatible"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:607:6-32
    return numpy.int32(2560)
   if (_0=="errTaskInvalid"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:608:6-27
    return numpy.int32(2561)
   if (_0=="errTaskWrite"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:609:6-25
    return numpy.int32(2562)
   if (_0=="errLuMaxNumTries"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:610:6-29
    return numpy.int32(2800)
   if (_0=="errInvalidUtf8"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:611:6-27
    return numpy.int32(2900)
   if (_0=="errInvalidWchar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:612:6-28
    return numpy.int32(2901)
   if (_0=="errNoDualForItgSol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:613:6-31
    return numpy.int32(2950)
   if (_0=="errNoSnxForBasSol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:614:6-30
    return numpy.int32(2953)
   if (_0=="errInternal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:615:6-24
    return numpy.int32(3000)
   if (_0=="errApiArrayTooSmall"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:616:6-32
    return numpy.int32(3001)
   if (_0=="errApiCbConnect"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:617:6-28
    return numpy.int32(3002)
   if (_0=="errApiFatalError"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:618:6-29
    return numpy.int32(3005)
   if (_0=="errApiInternal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:619:6-27
    return numpy.int32(3999)
   if (_0=="errSenFormat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:620:6-25
    return numpy.int32(3050)
   if (_0=="errSenUndefName"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:621:6-28
    return numpy.int32(3051)
   if (_0=="errSenIndexRange"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:622:6-29
    return numpy.int32(3052)
   if (_0=="errSenBoundInvalidUp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:623:6-33
    return numpy.int32(3053)
   if (_0=="errSenBoundInvalidLo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:624:6-33
    return numpy.int32(3054)
   if (_0=="errSenIndexInvalid"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:625:6-31
    return numpy.int32(3055)
   if (_0=="errSenInvalidRegexp"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:626:6-32
    return numpy.int32(3056)
   if (_0=="errSenSolutionStatus"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:627:6-33
    return numpy.int32(3057)
   if (_0=="errSenNumerical"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:628:6-28
    return numpy.int32(3058)
   if (_0=="errSenUnhandledProblemType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:629:6-39
    return numpy.int32(3080)
   if (_0=="errUnbStepSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:630:6-27
    return numpy.int32(3100)
   if (_0=="errIdenticalTasks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:631:6-30
    return numpy.int32(3101)
   if (_0=="errAdInvalidCodelist"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:632:6-33
    return numpy.int32(3102)
   if (_0=="errInternalTestFailed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:633:6-34
    return numpy.int32(3500)
   if (_0=="errXmlInvalidProblemType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:634:6-37
    return numpy.int32(3600)
   if (_0=="errInvalidAmplStub"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:635:6-31
    return numpy.int32(3700)
   if (_0=="errInt64ToInt32Cast"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:636:6-32
    return numpy.int32(3800)
   if (_0=="errSizeLicenseNumcores"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:637:6-35
    return numpy.int32(3900)
   if (_0=="errInfeasUndefined"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:638:6-31
    return numpy.int32(3910)
   if (_0=="errNoBarxForSolution"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:639:6-33
    return numpy.int32(3915)
   if (_0=="errNoBarsForSolution"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:640:6-33
    return numpy.int32(3916)
   if (_0=="errBarVarDim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:641:6-25
    return numpy.int32(3920)
   if (_0=="errSymMatInvalidRowIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:642:6-37
    return numpy.int32(3940)
   if (_0=="errSymMatInvalidColIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:643:6-37
    return numpy.int32(3941)
   if (_0=="errSymMatNotLowerTringular"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:644:6-39
    return numpy.int32(3942)
   if (_0=="errSymMatInvalidValue"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:645:6-34
    return numpy.int32(3943)
   if (_0=="errSymMatDuplicate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:646:6-31
    return numpy.int32(3944)
   if (_0=="errInvalidSymMatDim"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:647:6-32
    return numpy.int32(3950)
   if (_0=="errInvalidFileFormatForSymMat"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:648:6-42
    return numpy.int32(4000)
   if (_0=="errInvalidFileFormatForCfix"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:649:6-40
    return numpy.int32(4001)
   if (_0=="errInvalidFileFormatForRangedConstraints"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:650:6-53
    return numpy.int32(4002)
   if (_0=="errInvalidFileFormatForFreeConstraints"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:651:6-51
    return numpy.int32(4003)
   if (_0=="errInvalidFileFormatForCones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:652:6-41
    return numpy.int32(4005)
   if (_0=="errInvalidFileFormatForNonlinear"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:653:6-45
    return numpy.int32(4010)
   if (_0=="errDuplicateConstraintNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:654:6-40
    return numpy.int32(4500)
   if (_0=="errDuplicateVariableNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:655:6-38
    return numpy.int32(4501)
   if (_0=="errDuplicateBarvariableNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:656:6-41
    return numpy.int32(4502)
   if (_0=="errDuplicateConeNames"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:657:6-34
    return numpy.int32(4503)
   if (_0=="errNonUniqueArray"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:658:6-30
    return numpy.int32(5000)
   if (_0=="errArgumentIsTooLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:659:6-34
    return numpy.int32(5005)
   if (_0=="errMioInternal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:660:6-27
    return numpy.int32(5010)
   if (_0=="errInvalidProblemType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:661:6-34
    return numpy.int32(6000)
   if (_0=="errUnhandledSolutionStatus"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:662:6-39
    return numpy.int32(6010)
   if (_0=="errUpperTriangle"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:663:6-29
    return numpy.int32(6020)
   if (_0=="errLauSingularMatrix"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:664:6-33
    return numpy.int32(7000)
   if (_0=="errLauNotPositiveDefinite"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:665:6-38
    return numpy.int32(7001)
   if (_0=="errLauInvalidLowerTriangularMatrix"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:666:6-47
    return numpy.int32(7002)
   if (_0=="errLauUnknown"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:667:6-26
    return numpy.int32(7005)
   if (_0=="errLauArgM"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:668:6-23
    return numpy.int32(7010)
   if (_0=="errLauArgN"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:669:6-23
    return numpy.int32(7011)
   if (_0=="errLauArgK"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:670:6-23
    return numpy.int32(7012)
   if (_0=="errLauArgTransa"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:671:6-28
    return numpy.int32(7015)
   if (_0=="errLauArgTransb"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:672:6-28
    return numpy.int32(7016)
   if (_0=="errLauArgUplo"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:673:6-26
    return numpy.int32(7017)
   if (_0=="errLauArgTrans"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:674:6-27
    return numpy.int32(7018)
   if (_0=="errLauInvalidSparseSymmetricMatrix"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:675:6-47
    return numpy.int32(7019)
   if (_0=="errCbfParse"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:676:6-24
    return numpy.int32(7100)
   if (_0=="errCbfObjSense"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:677:6-27
    return numpy.int32(7101)
   if (_0=="errCbfNoVariables"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:678:6-30
    return numpy.int32(7102)
   if (_0=="errCbfTooManyConstraints"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:679:6-37
    return numpy.int32(7103)
   if (_0=="errCbfTooManyVariables"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:680:6-35
    return numpy.int32(7104)
   if (_0=="errCbfNoVersionSpecified"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:681:6-37
    return numpy.int32(7105)
   if (_0=="errCbfSyntax"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:682:6-25
    return numpy.int32(7106)
   if (_0=="errCbfDuplicateObj"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:683:6-31
    return numpy.int32(7107)
   if (_0=="errCbfDuplicateCon"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:684:6-31
    return numpy.int32(7108)
   if (_0=="errCbfDuplicateVar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:685:6-31
    return numpy.int32(7109)
   if (_0=="errCbfDuplicateInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:686:6-31
    return numpy.int32(7110)
   if (_0=="errCbfInvalidVarType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:687:6-33
    return numpy.int32(7111)
   if (_0=="errCbfInvalidConType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:688:6-33
    return numpy.int32(7112)
   if (_0=="errCbfInvalidDomainDimension"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:689:6-41
    return numpy.int32(7113)
   if (_0=="errCbfDuplicateObjacoord"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:690:6-37
    return numpy.int32(7114)
   if (_0=="errCbfDuplicateBcoord"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:691:6-34
    return numpy.int32(7115)
   if (_0=="errCbfDuplicateAcoord"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:692:6-34
    return numpy.int32(7116)
   if (_0=="errCbfTooFewVariables"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:693:6-34
    return numpy.int32(7117)
   if (_0=="errCbfTooFewConstraints"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:694:6-36
    return numpy.int32(7118)
   if (_0=="errCbfTooFewInts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:695:6-29
    return numpy.int32(7119)
   if (_0=="errCbfTooManyInts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:696:6-30
    return numpy.int32(7120)
   if (_0=="errCbfInvalidIntIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:697:6-34
    return numpy.int32(7121)
   if (_0=="errCbfUnsupported"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:698:6-30
    return numpy.int32(7122)
   if (_0=="errCbfDuplicatePsdvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:699:6-34
    return numpy.int32(7123)
   if (_0=="errCbfInvalidPsdvarDimension"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:700:6-41
    return numpy.int32(7124)
   if (_0=="errCbfTooFewPsdvar"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:701:6-31
    return numpy.int32(7125)
   if (_0=="errCbfInvalidExpDimension"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:702:6-38
    return numpy.int32(7126)
   if (_0=="errCbfDuplicatePowCones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:703:6-36
    return numpy.int32(7130)
   if (_0=="errCbfDuplicatePowStarCones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:704:6-40
    return numpy.int32(7131)
   if (_0=="errCbfInvalidPower"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:705:6-31
    return numpy.int32(7132)
   if (_0=="errCbfPowerConeIsTooLong"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:706:6-37
    return numpy.int32(7133)
   if (_0=="errCbfInvalidPowerConeIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:707:6-40
    return numpy.int32(7134)
   if (_0=="errCbfInvalidPowerStarConeIndex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:708:6-44
    return numpy.int32(7135)
   if (_0=="errCbfUnhandledPowerConeType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:709:6-41
    return numpy.int32(7136)
   if (_0=="errCbfUnhandledPowerStarConeType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:710:6-45
    return numpy.int32(7137)
   if (_0=="errCbfPowerConeMismatch"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:711:6-36
    return numpy.int32(7138)
   if (_0=="errCbfPowerStarConeMismatch"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:712:6-40
    return numpy.int32(7139)
   if (_0=="errCbfInvalidNumberOfCones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:713:6-39
    return numpy.int32(7740)
   if (_0=="errCbfInvalidDimensionOfCones"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:714:6-42
    return numpy.int32(7741)
   if (_0=="errMioInvalidRootOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:715:6-39
    return numpy.int32(7700)
   if (_0=="errMioInvalidNodeOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:716:6-39
    return numpy.int32(7701)
   if (_0=="errToconicConstrQNotPsd"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:717:6-36
    return numpy.int32(7800)
   if (_0=="errToconicConstraintFx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:718:6-35
    return numpy.int32(7801)
   if (_0=="errToconicConstraintRa"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:719:6-35
    return numpy.int32(7802)
   if (_0=="errToconicConstrNotConic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:720:6-37
    return numpy.int32(7803)
   if (_0=="errToconicObjectiveNotPsd"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:721:6-38
    return numpy.int32(7804)
   if (_0=="errServerConnect"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:722:6-29
    return numpy.int32(8000)
   if (_0=="errServerProtocol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:723:6-30
    return numpy.int32(8001)
   if (_0=="errServerStatus"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:724:6-28
    return numpy.int32(8002)
   if (_0=="errServerToken"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:725:6-27
    return numpy.int32(8003)
   if (_0=="errServerProblemSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:726:6-33
    return numpy.int32(8008)
   if (_0=="trmMaxIterations"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:727:6-29
    return numpy.int32(10000)
   if (_0=="trmMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:728:6-23
    return numpy.int32(10001)
   if (_0=="trmObjectiveRange"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:729:6-30
    return numpy.int32(10002)
   if (_0=="trmMioNumRelaxs"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:730:6-28
    return numpy.int32(10008)
   if (_0=="trmMioNumBranches"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:731:6-30
    return numpy.int32(10009)
   if (_0=="trmNumMaxNumIntSolutions"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:732:6-37
    return numpy.int32(10015)
   if (_0=="trmStall"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:733:6-21
    return numpy.int32(10006)
   if (_0=="trmUserCallback"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:734:6-28
    return numpy.int32(10007)
   if (_0=="trmMaxNumSetbacks"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:735:6-30
    return numpy.int32(10020)
   if (_0=="trmNumericalProblem"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:736:6-32
    return numpy.int32(10025)
   if (_0=="trmInternal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:737:6-24
    return numpy.int32(10030)
   if (_0=="trmInternalStop"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:738:6-28
    return numpy.int32(10031)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingmethod_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingmethod_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingmethod_1value_S(_0):
   if (_0=="pow2"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:275:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:276:6-17
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1value_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1value_1value_S(_0)
  @staticmethod
  def __string_1to_1value_1value_S(_0):
   if (_0=="maxStrLen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:269:6-22
    return numpy.int32(1024)
   if (_0=="licenseBufferLength"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:270:6-32
    return numpy.int32(21)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1soltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1soltype_1value_S(_0)
  @staticmethod
  def __string_1to_1soltype_1value_S(_0):
   if (_0=="bas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:262:6-16
    return numpy.int32(1)
   if (_0=="itr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:263:6-16
    return numpy.int32(0)
   if (_0=="itg"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:264:6-16
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1startpointtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1startpointtype_1value_S(_0)
  @staticmethod
  def __string_1to_1startpointtype_1value_S(_0):
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:254:6-17
    return numpy.int32(0)
   if (_0=="guess"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:255:6-18
    return numpy.int32(1)
   if (_0=="constant"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:256:6-21
    return numpy.int32(2)
   if (_0=="satisfyBounds"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:257:6-26
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1stakey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1stakey_1value_S(_0)
  @staticmethod
  def __string_1to_1stakey_1value_S(_0):
   if (_0=="unk"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:243:6-16
    return numpy.int32(0)
   if (_0=="bas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:244:6-16
    return numpy.int32(1)
   if (_0=="supbas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:245:6-19
    return numpy.int32(2)
   if (_0=="low"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:246:6-16
    return numpy.int32(3)
   if (_0=="upr"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:247:6-16
    return numpy.int32(4)
   if (_0=="fix"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:248:6-16
    return numpy.int32(5)
   if (_0=="inf"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:249:6-16
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdupvec_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdupvec_1value_S(_0)
  @staticmethod
  def __string_1to_1simdupvec_1value_S(_0):
   if (_0=="on"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:236:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:237:6-16
    return numpy.int32(0)
   if (_0=="free"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:238:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescodetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescodetype_1value_S(_0)
  @staticmethod
  def __string_1to_1rescodetype_1value_S(_0):
   if (_0=="ok"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:227:6-15
    return numpy.int32(0)
   if (_0=="wrn"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:228:6-16
    return numpy.int32(1)
   if (_0=="trm"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:229:6-16
    return numpy.int32(2)
   if (_0=="err"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:230:6-16
    return numpy.int32(3)
   if (_0=="unk"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:231:6-16
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1purify_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1purify_1value_S(_0)
  @staticmethod
  def __string_1to_1purify_1value_S(_0):
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:218:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:219:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:220:6-17
    return numpy.int32(2)
   if (_0=="primalDual"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:221:6-23
    return numpy.int32(3)
   if (_0=="auto"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:222:6-17
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solitem_1value_S(_0)
  @staticmethod
  def __string_1to_1solitem_1value_S(_0):
   if (_0=="xc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:206:6-15
    return numpy.int32(0)
   if (_0=="xx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:207:6-15
    return numpy.int32(1)
   if (_0=="y"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:208:6-14
    return numpy.int32(2)
   if (_0=="slc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:209:6-16
    return numpy.int32(3)
   if (_0=="suc"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:210:6-16
    return numpy.int32(4)
   if (_0=="slx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:211:6-16
    return numpy.int32(5)
   if (_0=="sux"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:212:6-16
    return numpy.int32(6)
   if (_0=="snx"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:213:6-16
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miocontsoltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miocontsoltype_1value_S(_0)
  @staticmethod
  def __string_1to_1miocontsoltype_1value_S(_0):
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:198:6-17
    return numpy.int32(0)
   if (_0=="root"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:199:6-17
    return numpy.int32(1)
   if (_0=="itg"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:200:6-16
    return numpy.int32(2)
   if (_0=="itgRel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:201:6-19
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dparam_1value_S(_0)
  @staticmethod
  def __string_1to_1dparam_1value_S(_0):
   if (_0=="dataTolCjLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:135:6-27
    return numpy.int32(13)
   if (_0=="dataTolCHuge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:136:6-25
    return numpy.int32(12)
   if (_0=="dataTolAijLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:137:6-28
    return numpy.int32(9)
   if (_0=="dataTolAijHuge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:138:6-27
    return numpy.int32(8)
   if (_0=="dataSymMatTol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:139:6-26
    return numpy.int32(5)
   if (_0=="dataSymMatTolLarge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:140:6-31
    return numpy.int32(7)
   if (_0=="dataSymMatTolHuge"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:141:6-30
    return numpy.int32(6)
   if (_0=="dataTolBoundInf"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:142:6-28
    return numpy.int32(10)
   if (_0=="dataTolBoundWrn"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:143:6-28
    return numpy.int32(11)
   if (_0=="dataTolQij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:144:6-23
    return numpy.int32(14)
   if (_0=="dataTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:145:6-21
    return numpy.int32(15)
   if (_0=="semidefiniteTolApprox"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:146:6-34
    return numpy.int32(54)
   if (_0=="optimizerMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:147:6-29
    return numpy.int32(47)
   if (_0=="lowerObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:148:6-24
    return numpy.int32(38)
   if (_0=="upperObjCut"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:149:6-24
    return numpy.int32(57)
   if (_0=="upperObjCutFiniteTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:150:6-33
    return numpy.int32(58)
   if (_0=="lowerObjCutFiniteTrh"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:151:6-33
    return numpy.int32(39)
   if (_0=="intpntTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:152:6-28
    return numpy.int32(35)
   if (_0=="intpntTolStepSize"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:153:6-30
    return numpy.int32(37)
   if (_0=="simLuTolRelPiv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:154:6-27
    return numpy.int32(55)
   if (_0=="intpntTolRelStep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:155:6-29
    return numpy.int32(36)
   if (_0=="intpntTolPath"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:156:6-26
    return numpy.int32(32)
   if (_0=="intpntTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:157:6-27
    return numpy.int32(33)
   if (_0=="intpntTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:158:6-27
    return numpy.int32(28)
   if (_0=="intpntTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:159:6-27
    return numpy.int32(31)
   if (_0=="intpntTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:160:6-28
    return numpy.int32(30)
   if (_0=="intpntCoTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:161:6-30
    return numpy.int32(21)
   if (_0=="intpntCoTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:162:6-29
    return numpy.int32(20)
   if (_0=="intpntCoTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:163:6-29
    return numpy.int32(16)
   if (_0=="intpntCoTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:164:6-29
    return numpy.int32(18)
   if (_0=="intpntCoTolNearRel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:165:6-31
    return numpy.int32(19)
   if (_0=="intpntCoTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:166:6-30
    return numpy.int32(17)
   if (_0=="intpntQoTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:167:6-30
    return numpy.int32(27)
   if (_0=="intpntQoTolPfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:168:6-29
    return numpy.int32(26)
   if (_0=="intpntQoTolDfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:169:6-29
    return numpy.int32(22)
   if (_0=="intpntQoTolMuRed"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:170:6-29
    return numpy.int32(24)
   if (_0=="intpntQoTolNearRel"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:171:6-31
    return numpy.int32(25)
   if (_0=="intpntQoTolInfeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:172:6-30
    return numpy.int32(23)
   if (_0=="intpntTolPsafe"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:173:6-27
    return numpy.int32(34)
   if (_0=="intpntTolDsafe"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:174:6-27
    return numpy.int32(29)
   if (_0=="mioMaxTime"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:175:6-23
    return numpy.int32(40)
   if (_0=="mioRelGapConst"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:176:6-27
    return numpy.int32(41)
   if (_0=="mioTolRelGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:177:6-25
    return numpy.int32(46)
   if (_0=="mioTolAbsGap"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:178:6-25
    return numpy.int32(42)
   if (_0=="mioTolAbsRelaxInt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:179:6-30
    return numpy.int32(43)
   if (_0=="basisTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:180:6-22
    return numpy.int32(3)
   if (_0=="basisTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:181:6-22
    return numpy.int32(2)
   if (_0=="basisRelTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:182:6-25
    return numpy.int32(1)
   if (_0=="presolveTolX"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:183:6-25
    return numpy.int32(52)
   if (_0=="presolveTolS"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:184:6-25
    return numpy.int32(51)
   if (_0=="presolveTolAij"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:185:6-27
    return numpy.int32(49)
   if (_0=="presolveTolAbsLindep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:186:6-33
    return numpy.int32(48)
   if (_0=="presolveTolRelLindep"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:187:6-33
    return numpy.int32(50)
   if (_0=="simplexAbsTolPiv"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:188:6-29
    return numpy.int32(56)
   if (_0=="mioTolFeas"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:189:6-23
    return numpy.int32(44)
   if (_0=="anaSolInfeasTol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:190:6-28
    return numpy.int32(0)
   if (_0=="checkConvexityRelTol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:191:6-33
    return numpy.int32(4)
   if (_0=="qcqoReformulateRelDropTol"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:192:6-38
    return numpy.int32(53)
   if (_0=="mioTolRelDualBoundImprovement"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:193:6-42
    return numpy.int32(45)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1parametertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1parametertype_1value_S(_0)
  @staticmethod
  def __string_1to_1parametertype_1value_S(_0):
   if (_0=="invalidType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:127:6-24
    return numpy.int32(0)
   if (_0=="douType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:128:6-20
    return numpy.int32(1)
   if (_0=="intType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:129:6-20
    return numpy.int32(2)
   if (_0=="strType"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:130:6-20
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1feature_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1feature_1value_S(_0)
  @staticmethod
  def __string_1to_1feature_1value_S(_0):
   if (_0=="pts"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:121:6-16
    return numpy.int32(0)
   if (_0=="pton"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:122:6-17
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemitem_1value_S(_0)
  @staticmethod
  def __string_1to_1problemitem_1value_S(_0):
   if (_0=="var"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:114:6-16
    return numpy.int32(0)
   if (_0=="con"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:115:6-16
    return numpy.int32(1)
   if (_0=="cone"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:116:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1intpnthotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1intpnthotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1intpnthotstart_1value_S(_0):
   if (_0=="none"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:106:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:107:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:108:6-17
    return numpy.int32(2)
   if (_0=="primalDual"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:109:6-23
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1callbackcode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1callbackcode_1value_S(_0)
  @staticmethod
  def __string_1to_1callbackcode_1value_S(_0):
   if (_0=="beginRootCutgen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:9:6-28
    return numpy.int32(22)
   if (_0=="imRootCutgen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:10:6-25
    return numpy.int32(76)
   if (_0=="endRootCutgen"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:11:6-26
    return numpy.int32(51)
   if (_0=="beginOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:12:6-27
    return numpy.int32(12)
   if (_0=="endOptimizer"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:13:6-25
    return numpy.int32(41)
   if (_0=="beginPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:14:6-26
    return numpy.int32(13)
   if (_0=="updatePresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:15:6-27
    return numpy.int32(88)
   if (_0=="imPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:16:6-23
    return numpy.int32(70)
   if (_0=="endPresolve"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:17:6-24
    return numpy.int32(42)
   if (_0=="beginIntpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:18:6-24
    return numpy.int32(9)
   if (_0=="intpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:19:6-19
    return numpy.int32(79)
   if (_0=="imIntpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:20:6-21
    return numpy.int32(62)
   if (_0=="endIntpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:21:6-22
    return numpy.int32(38)
   if (_0=="beginConic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:22:6-23
    return numpy.int32(1)
   if (_0=="conic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:23:6-18
    return numpy.int32(27)
   if (_0=="imConic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:24:6-20
    return numpy.int32(57)
   if (_0=="endConic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:25:6-21
    return numpy.int32(30)
   if (_0=="primalSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:26:6-26
    return numpy.int32(81)
   if (_0=="dualSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:27:6-24
    return numpy.int32(28)
   if (_0=="beginBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:28:6-20
    return numpy.int32(0)
   if (_0=="imBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:29:6-17
    return numpy.int32(56)
   if (_0=="endBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:30:6-18
    return numpy.int32(29)
   if (_0=="beginPrimalBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:31:6-26
    return numpy.int32(14)
   if (_0=="imPrimalBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:32:6-23
    return numpy.int32(71)
   if (_0=="updatePrimalBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:33:6-27
    return numpy.int32(89)
   if (_0=="endPrimalBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:34:6-24
    return numpy.int32(43)
   if (_0=="beginDualBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:35:6-24
    return numpy.int32(2)
   if (_0=="imDualBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:36:6-21
    return numpy.int32(58)
   if (_0=="updateDualBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:37:6-25
    return numpy.int32(85)
   if (_0=="endDualBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:38:6-22
    return numpy.int32(31)
   if (_0=="beginSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:39:6-27
    return numpy.int32(24)
   if (_0=="imSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:40:6-24
    return numpy.int32(78)
   if (_0=="beginPrimalSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:41:6-33
    return numpy.int32(19)
   if (_0=="updatePrimalSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:42:6-34
    return numpy.int32(91)
   if (_0=="endPrimalSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:43:6-31
    return numpy.int32(48)
   if (_0=="beginDualSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:44:6-31
    return numpy.int32(6)
   if (_0=="updateDualSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:45:6-32
    return numpy.int32(87)
   if (_0=="endDualSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:46:6-29
    return numpy.int32(35)
   if (_0=="endSimplexBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:47:6-25
    return numpy.int32(53)
   if (_0=="beginMio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:48:6-21
    return numpy.int32(11)
   if (_0=="imMio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:49:6-18
    return numpy.int32(65)
   if (_0=="newIntMio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:50:6-22
    return numpy.int32(80)
   if (_0=="endMio"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:51:6-19
    return numpy.int32(40)
   if (_0=="beginSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:52:6-25
    return numpy.int32(23)
   if (_0=="beginDualSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:53:6-29
    return numpy.int32(5)
   if (_0=="imDualSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:54:6-26
    return numpy.int32(60)
   if (_0=="updateDualSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:55:6-30
    return numpy.int32(86)
   if (_0=="endDualSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:56:6-27
    return numpy.int32(34)
   if (_0=="beginPrimalSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:57:6-31
    return numpy.int32(18)
   if (_0=="imPrimalSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:58:6-28
    return numpy.int32(73)
   if (_0=="updatePrimalSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:59:6-32
    return numpy.int32(90)
   if (_0=="endPrimalSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:60:6-29
    return numpy.int32(47)
   if (_0=="endSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:61:6-23
    return numpy.int32(52)
   if (_0=="beginInfeasAna"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:62:6-27
    return numpy.int32(8)
   if (_0=="endInfeasAna"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:63:6-25
    return numpy.int32(37)
   if (_0=="imPrimalSensivity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:64:6-30
    return numpy.int32(72)
   if (_0=="imDualSensivity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:65:6-28
    return numpy.int32(59)
   if (_0=="imMioIntpnt"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:66:6-24
    return numpy.int32(67)
   if (_0=="imMioPrimalSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:67:6-31
    return numpy.int32(68)
   if (_0=="imMioDualSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:68:6-29
    return numpy.int32(66)
   if (_0=="beginPrimalSetupBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:69:6-31
    return numpy.int32(17)
   if (_0=="endPrimalSetupBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:70:6-29
    return numpy.int32(46)
   if (_0=="beginDualSetupBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:71:6-29
    return numpy.int32(4)
   if (_0=="endDualSetupBi"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:72:6-27
    return numpy.int32(33)
   if (_0=="beginPrimalSensitivity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:73:6-35
    return numpy.int32(16)
   if (_0=="endPrimalSensitivity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:74:6-33
    return numpy.int32(45)
   if (_0=="beginDualSensitivity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:75:6-33
    return numpy.int32(3)
   if (_0=="endDualSensitivity"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:76:6-31
    return numpy.int32(32)
   if (_0=="beginLicenseWait"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:77:6-29
    return numpy.int32(10)
   if (_0=="endLicenseWait"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:78:6-27
    return numpy.int32(39)
   if (_0=="imLicenseWait"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:79:6-26
    return numpy.int32(63)
   if (_0=="beginQcqoReformulate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:80:6-33
    return numpy.int32(20)
   if (_0=="endQcqoReformulate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:81:6-31
    return numpy.int32(49)
   if (_0=="imQoReformulate"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:82:6-28
    return numpy.int32(74)
   if (_0=="beginToConic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:83:6-25
    return numpy.int32(25)
   if (_0=="endToConic"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:84:6-23
    return numpy.int32(54)
   if (_0=="beginFullConvexityCheck"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:85:6-36
    return numpy.int32(7)
   if (_0=="endFullConvexityCheck"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:86:6-34
    return numpy.int32(36)
   if (_0=="imFullConvexityCheck"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:87:6-33
    return numpy.int32(61)
   if (_0=="beginPrimalRepair"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:88:6-30
    return numpy.int32(15)
   if (_0=="endPrimalRepair"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:89:6-28
    return numpy.int32(44)
   if (_0=="beginRead"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:90:6-22
    return numpy.int32(21)
   if (_0=="imRead"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:91:6-19
    return numpy.int32(75)
   if (_0=="endRead"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:92:6-20
    return numpy.int32(50)
   if (_0=="beginWrite"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:93:6-23
    return numpy.int32(26)
   if (_0=="endWrite"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:94:6-21
    return numpy.int32(55)
   if (_0=="readOpfSection"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:95:6-27
    return numpy.int32(83)
   if (_0=="imLu"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:96:6-17
    return numpy.int32(64)
   if (_0=="imOrder"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:97:6-20
    return numpy.int32(69)
   if (_0=="imSimplex"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:98:6-22
    return numpy.int32(77)
   if (_0=="readOpf"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:99:6-20
    return numpy.int32(82)
   if (_0=="writeOpf"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:100:6-21
    return numpy.int32(92)
   if (_0=="solvingRemote"): # bld/hull/final/default/monty2-2.5.0/src/fusion/Parameters.mbi:101:6-26
    return numpy.int32(84)
   return numpy.int32((- 1))
 return Parameters
mosek_fusion_Parameters=__mk_mosek_fusion_Parameters()
del __mk_mosek_fusion_Parameters
def __mk_mosek_fusion_Utils_StringIntMap():
  class StringIntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_S(self,key): return key in self.__d
    def _getItem_S(self,key): return self.__d[key]
    def _setItem_SI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  return StringIntMap
mosek_fusion_Utils_StringIntMap=__mk_mosek_fusion_Utils_StringIntMap()
def __mk_mosek_fusion_Utils_IntMap():
  class IntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_J(self,key): return key in self.__d
    def _getItem_J(self,key): return self.__d[key]
    def _setItem_JI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  
  
  
  return IntMap
mosek_fusion_Utils_IntMap=__mk_mosek_fusion_Utils_IntMap()
def __mk_mosek_fusion_Utils_StringBuffer():
  class StringBuffer:
    def __init__(self):
      self.__buf = []
    def __a(self,v):
      self.__buf.append(str(v))
      return self
    def __a_array(self,v):
      if v is None: self.__buf.append("None")
      else: self.__buf.append(str(v))
      return self
  
    _a_Z   = __a
    _a_I   = __a
    _a_J   = __a
    _a_U   = __a
    _a_D   = __a
    _a_S   = __a
    _a_B   = __a
    _a__3I = __a_array
    def _a__3J(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%i' % i for i in v]),']'])
      else:             self.__buf.append('None')
      return self
    def _a__3D(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%g' % i for i in v]),']'])
      else:             self.__buf.append('None')
      return self
    _a__3S = __a_array
    def _lf_(self):
      self.__buf.append('\n')
      return self
    def _clear_ (self):
      self.__buf = []
      return self
    def _toString_(self):
      return ''.join(self.__buf)
    def _toString_(self):
      return ''.join(self.__buf)
    def _consolePrint_(self):
      print(self._toString_())
      self._clear_()
      return(self)
  return StringBuffer
mosek_fusion_Utils_StringBuffer=__mk_mosek_fusion_Utils_StringBuffer()
def __mk_mosek_fusion_Utils_Tools():
  
  import random,ctypes,math
  class Tools:
    @staticmethod
    def __arraycopy(src,srcoffset,tgt,tgtoffset,size):
      if len(tgt) < tgtoffset+size or len(src) < srcoffset+size:
        raise IndexError("Copy slice out of range")
      tgt[tgtoffset:tgtoffset+size] = src[srcoffset:srcoffset+size]
  
    _arraycopy__3II_3III =  __arraycopy
    _arraycopy__3JI_3JII = __arraycopy
    _arraycopy__3_3II_3_3III = __arraycopy
    _arraycopy__3_3DI_3_3DII = __arraycopy
    _arraycopy__3DI_3DII = __arraycopy
    _arraycopy__3IJ_3IJJ = __arraycopy
    _arraycopy__3JJ_3JJJ = __arraycopy
    _arraycopy__3DJ_3DJJ = __arraycopy
  
    @staticmethod
    def __arrayclone(a): 
      if isinstance(a,numpy.ndarray):
        return a.copy()
      else:      
        return numpy.array(a)
  
    _arraycopy__3D = __arrayclone
    _arraycopy__3I = __arrayclone
    _arraycopy__3J = __arrayclone
    _arraycopy__3S = __arrayclone
  
    @staticmethod
    def __arraylength(a): return len(a)
  
    _arraylength__3Lmosek_4fusion_4Variable_2   = __arraylength
    _arraylength__3Lmosek_4fusion_4Constranit_2 = __arraylength  
    _arraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength  
    _arraylength__3S   = __arraylength  
    _arraylength__3I   = __arraylength  
    _arraylength__3J   = __arraylength  
    _arraylength__3D   = __arraylength  
    _arraylength__3_3D = __arraylength  
    _arraylength__3_3I = __arraylength  
    _uarraylength__3I  = __arraylength 
    _uarraylength__3J  = __arraylength 
    _uarraylength__3D  = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Variable_2   = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Constraint_2 = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength 
    _uarraylength__3_3S = __arraylength 
    _uarraylength__3_3D = __arraylength 
    _uarraylength__3_3I = __arraylength 
  
    @staticmethod
    def __matrixheight(m): return m.shape[0]
    @staticmethod
    def __matrixwidth(m): return m.shape[1]
    
    _matrixheight__3_3D = __matrixheight
    _matrixwidth__3_3D  = __matrixwidth
    _matrixheight__3_3Lmosek_4fusion_4Matrix_2 = __matrixheight
    _matrixwidth__3_3Lmosek_4fusion_4Matrix_2  = __matrixwidth
   
    @staticmethod   
    def _range_J (last): return numpy.arange(last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJ(first,last): return numpy.arange(first,last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJJ(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int64)
  
    @staticmethod   
    def _range_I (last): return numpy.arange(last,dtype=numpy.int32)
    @staticmethod   
    def _range_II(first,last): return numpy.arange(first,last,dtype=numpy.int32)
    @staticmethod   
    def _range_III(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int32)
  
    @staticmethod   
    def _zeros_I (num): return  numpy.zeros((num,),dtype=numpy.float64)
    @staticmethod   
    def _zeros_II (dimi,dimj): return  numpy.zeros((dimi,dimj),dtype=numpy.float64)
    @staticmethod   
    def _ones_I(num):  return  numpy.ones((num,),numpy.float64)
    
    __rand = random.Random()
    @staticmethod   
    def _randInt_I(max):
      return Tools.__rand.randint(0,max-1)
      
    @staticmethod   
    def _argsort__3J_3I_3JII(perm,val1,val2,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val1[lhs],val1[rhs]) or cmp(val2[lhs],val2[rhs]))
        perm[first:last] = p
  
    @staticmethod   
    def _argsort__3J_3I_3I(perm,val1,val2):    
      Tools._argsort__3I_3I_3III(perm,val1,val2,0,len(perm))
    
    @staticmethod   
    def _argsort__3J_3I(perm,vals):
      Tools._argsort__3I_3III(perm,vals,0,len(perm))
  
    @staticmethod   
    def _argsort__3J_3III(perm,val,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val[lhs],val[rhs]))
        perm[first:last] = p
  
    @staticmethod
    def _sort__3I_II (vals,first,last):
      if last-first > 1:
        tmp = vals[first:last]
        tmp.sort()
        vals[first:last] = tmp
  
    @staticmethod   
    def _makevector_DI(val,num): 
      r = numpy.zeros((num,), numpy.float64)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_II(val,num): 
      r = numpy.zeros((num,), numpy.int32)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_JI(val,num): 
      r = numpy.zeros((num,), numpy.int64)
      r[:] = val
      return r
    @staticmethod   
    def _repeatrange_III(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int32)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod   
    def _repeatrange_JJJ(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int64)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod
    def  _stringvalue_I(v): return str(v)
    @staticmethod
    def  _stringvalue_J(v): return str(v)
  
    @staticmethod
    def _toDouble_S(v):    
      return float(v)
  
    @staticmethod
    def _sqrt_D(v):
      return math.sqrt(v)
    
    @staticmethod
    def _toInt_S(v):
      return int(v)
  
  
    @staticmethod 
    def _argsort2(perm,v,first,last):
      l = sorted(perm[first:last],key=lambda i: v[i])
      perm[first:last] = l
    
    @staticmethod 
    def _argsort2x(perm,v0,v1,first,last):
      l = sorted(perm[first:last],key=lambda i: (v0[i],v1[i]))
      perm[first:last] = l
  
  
  
    @staticmethod 
    def _argsort__3J_3IJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
    
    @staticmethod 
    def _argsort__3J_3JJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
  
    @staticmethod 
    def _argsort__3J_3I_3IJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
    
    @staticmethod 
    def _argsort__3J_3J_3JJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
  
    @staticmethod
    def _bucketsort__3JJJ_3III(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        if perm_ct.strides[0] == 8:
          #print( perm_ct.strides[:], perm_ct.shape[:],perm_ct.get_data())
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
        if v_ct.strides[0] == 4:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int32)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3III_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
        del arg_perm,arg_v
  
        if copy_v: 
          v[:] = tmpv
          del tmpv
        if copy_perm: 
          perm[first:last] = tmpperm
          del tmpperm
  
      
    @staticmethod
    def _bucketsort__3JJJ_3JJJ(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
        #print( rperm,v)
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        
       
        if perm_ct.strides[0] == 8:
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
  
        if v_ct.strides[0] == 8:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int64)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3JJJ_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
  
        if copy_v: v[:] = tmpv
        if copy_perm: perm[first:last] = tmpperm
  
  
  
  
  return Tools
mosek_fusion_Utils_Tools=__mk_mosek_fusion_Utils_Tools()
def __mk_mosek_fusion_SolverInfo():
  from bisect import bisect_left
  import mosek
  class SolverInfo:
    dinfnames  = [ "biCleanDualTime","biCleanPrimalTime","biCleanTime","biDualTime","biPrimalTime","biTime","intpntDualFeas","intpntDualObj","intpntFactorNumFlops","intpntOptStatus","intpntOrderTime","intpntPrimalFeas","intpntPrimalObj","intpntTime","mioCliqueSeparationTime","mioCmirSeparationTime","mioConstructSolutionObj","mioDualBoundAfterPresolve","mioGmiSeparationTime","mioImpliedBoundTime","mioKnapsackCoverSeparationTime","mioObjAbsGap","mioObjBound","mioObjInt","mioObjRelGap","mioProbingTime","mioRootCutgenTime","mioRootOptimizerTime","mioRootPresolveTime","mioTime","mioUserObjCut","optimizerTime","presolveEliTime","presolveLindepTime","presolveTime","primalRepairPenaltyObj","qcqoReformulateMaxPerturbation","qcqoReformulateTime","qcqoReformulateWorstCholeskyColumnScaling","qcqoReformulateWorstCholeskyDiagScaling","rdTime","simDualTime","simFeas","simObj","simPrimalTime","simTime","solBasDualObj","solBasDviolcon","solBasDviolvar","solBasNrmBarx","solBasNrmSlc","solBasNrmSlx","solBasNrmSuc","solBasNrmSux","solBasNrmXc","solBasNrmXx","solBasNrmY","solBasPrimalObj","solBasPviolcon","solBasPviolvar","solItgNrmBarx","solItgNrmXc","solItgNrmXx","solItgPrimalObj","solItgPviolbarvar","solItgPviolcon","solItgPviolcones","solItgPviolitg","solItgPviolvar","solItrDualObj","solItrDviolbarvar","solItrDviolcon","solItrDviolcones","solItrDviolvar","solItrNrmBars","solItrNrmBarx","solItrNrmSlc","solItrNrmSlx","solItrNrmSnx","solItrNrmSuc","solItrNrmSux","solItrNrmXc","solItrNrmXx","solItrNrmY","solItrPrimalObj","solItrPviolbarvar","solItrPviolcon","solItrPviolcones","solItrPviolvar","toConicTime" ];
    iinfnames  = [ "anaProNumCon","anaProNumConEq","anaProNumConFr","anaProNumConLo","anaProNumConRa","anaProNumConUp","anaProNumVar","anaProNumVarBin","anaProNumVarCont","anaProNumVarEq","anaProNumVarFr","anaProNumVarInt","anaProNumVarLo","anaProNumVarRa","anaProNumVarUp","intpntFactorDimDense","intpntIter","intpntNumThreads","intpntSolveDual","mioAbsgapSatisfied","mioCliqueTableSize","mioConstructSolution","mioNodeDepth","mioNumActiveNodes","mioNumBranch","mioNumCliqueCuts","mioNumCmirCuts","mioNumGomoryCuts","mioNumImpliedBoundCuts","mioNumIntSolutions","mioNumKnapsackCoverCuts","mioNumRelax","mioNumRepeatedPresolve","mioNumbin","mioNumbinconevar","mioNumcon","mioNumcone","mioNumconevar","mioNumcont","mioNumcontconevar","mioNumdexpcones","mioNumdpowcones","mioNumint","mioNumintconevar","mioNumpexpcones","mioNumppowcones","mioNumqcones","mioNumrqcones","mioNumvar","mioObjBoundDefined","mioPresolvedNumbin","mioPresolvedNumbinconevar","mioPresolvedNumcon","mioPresolvedNumcone","mioPresolvedNumconevar","mioPresolvedNumcont","mioPresolvedNumcontconevar","mioPresolvedNumdexpcones","mioPresolvedNumdpowcones","mioPresolvedNumint","mioPresolvedNumintconevar","mioPresolvedNumpexpcones","mioPresolvedNumppowcones","mioPresolvedNumqcones","mioPresolvedNumrqcones","mioPresolvedNumvar","mioRelgapSatisfied","mioTotalNumCuts","mioUserObjCut","optNumcon","optNumvar","optimizeResponse","purifyDualSuccess","purifyPrimalSuccess","rdNumbarvar","rdNumcon","rdNumcone","rdNumintvar","rdNumq","rdNumvar","rdProtype","simDualDegIter","simDualHotstart","simDualHotstartLu","simDualInfIter","simDualIter","simNumcon","simNumvar","simPrimalDegIter","simPrimalHotstart","simPrimalHotstartLu","simPrimalInfIter","simPrimalIter","simSolveDual","solBasProsta","solBasSolsta","solItgProsta","solItgSolsta","solItrProsta","solItrSolsta","stoNumARealloc" ];
    liinfnames = [ "biCleanDualDegIter","biCleanDualIter","biCleanPrimalDegIter","biCleanPrimalIter","biDualIter","biPrimalIter","intpntFactorNumNz","mioAnz","mioIntpntIter","mioPresolvedAnz","mioSimplexIter","rdNumanz","rdNumqnz" ];
    dinfsyms   = [ mosek.dinfitem.bi_clean_dual_time,mosek.dinfitem.bi_clean_primal_time,mosek.dinfitem.bi_clean_time,mosek.dinfitem.bi_dual_time,mosek.dinfitem.bi_primal_time,mosek.dinfitem.bi_time,mosek.dinfitem.intpnt_dual_feas,mosek.dinfitem.intpnt_dual_obj,mosek.dinfitem.intpnt_factor_num_flops,mosek.dinfitem.intpnt_opt_status,mosek.dinfitem.intpnt_order_time,mosek.dinfitem.intpnt_primal_feas,mosek.dinfitem.intpnt_primal_obj,mosek.dinfitem.intpnt_time,mosek.dinfitem.mio_clique_separation_time,mosek.dinfitem.mio_cmir_separation_time,mosek.dinfitem.mio_construct_solution_obj,mosek.dinfitem.mio_dual_bound_after_presolve,mosek.dinfitem.mio_gmi_separation_time,mosek.dinfitem.mio_implied_bound_time,mosek.dinfitem.mio_knapsack_cover_separation_time,mosek.dinfitem.mio_obj_abs_gap,mosek.dinfitem.mio_obj_bound,mosek.dinfitem.mio_obj_int,mosek.dinfitem.mio_obj_rel_gap,mosek.dinfitem.mio_probing_time,mosek.dinfitem.mio_root_cutgen_time,mosek.dinfitem.mio_root_optimizer_time,mosek.dinfitem.mio_root_presolve_time,mosek.dinfitem.mio_time,mosek.dinfitem.mio_user_obj_cut,mosek.dinfitem.optimizer_time,mosek.dinfitem.presolve_eli_time,mosek.dinfitem.presolve_lindep_time,mosek.dinfitem.presolve_time,mosek.dinfitem.primal_repair_penalty_obj,mosek.dinfitem.qcqo_reformulate_max_perturbation,mosek.dinfitem.qcqo_reformulate_time,mosek.dinfitem.qcqo_reformulate_worst_cholesky_column_scaling,mosek.dinfitem.qcqo_reformulate_worst_cholesky_diag_scaling,mosek.dinfitem.rd_time,mosek.dinfitem.sim_dual_time,mosek.dinfitem.sim_feas,mosek.dinfitem.sim_obj,mosek.dinfitem.sim_primal_time,mosek.dinfitem.sim_time,mosek.dinfitem.sol_bas_dual_obj,mosek.dinfitem.sol_bas_dviolcon,mosek.dinfitem.sol_bas_dviolvar,mosek.dinfitem.sol_bas_nrm_barx,mosek.dinfitem.sol_bas_nrm_slc,mosek.dinfitem.sol_bas_nrm_slx,mosek.dinfitem.sol_bas_nrm_suc,mosek.dinfitem.sol_bas_nrm_sux,mosek.dinfitem.sol_bas_nrm_xc,mosek.dinfitem.sol_bas_nrm_xx,mosek.dinfitem.sol_bas_nrm_y,mosek.dinfitem.sol_bas_primal_obj,mosek.dinfitem.sol_bas_pviolcon,mosek.dinfitem.sol_bas_pviolvar,mosek.dinfitem.sol_itg_nrm_barx,mosek.dinfitem.sol_itg_nrm_xc,mosek.dinfitem.sol_itg_nrm_xx,mosek.dinfitem.sol_itg_primal_obj,mosek.dinfitem.sol_itg_pviolbarvar,mosek.dinfitem.sol_itg_pviolcon,mosek.dinfitem.sol_itg_pviolcones,mosek.dinfitem.sol_itg_pviolitg,mosek.dinfitem.sol_itg_pviolvar,mosek.dinfitem.sol_itr_dual_obj,mosek.dinfitem.sol_itr_dviolbarvar,mosek.dinfitem.sol_itr_dviolcon,mosek.dinfitem.sol_itr_dviolcones,mosek.dinfitem.sol_itr_dviolvar,mosek.dinfitem.sol_itr_nrm_bars,mosek.dinfitem.sol_itr_nrm_barx,mosek.dinfitem.sol_itr_nrm_slc,mosek.dinfitem.sol_itr_nrm_slx,mosek.dinfitem.sol_itr_nrm_snx,mosek.dinfitem.sol_itr_nrm_suc,mosek.dinfitem.sol_itr_nrm_sux,mosek.dinfitem.sol_itr_nrm_xc,mosek.dinfitem.sol_itr_nrm_xx,mosek.dinfitem.sol_itr_nrm_y,mosek.dinfitem.sol_itr_primal_obj,mosek.dinfitem.sol_itr_pviolbarvar,mosek.dinfitem.sol_itr_pviolcon,mosek.dinfitem.sol_itr_pviolcones,mosek.dinfitem.sol_itr_pviolvar,mosek.dinfitem.to_conic_time ];
    iinfsyms   = [ mosek.iinfitem.ana_pro_num_con,mosek.iinfitem.ana_pro_num_con_eq,mosek.iinfitem.ana_pro_num_con_fr,mosek.iinfitem.ana_pro_num_con_lo,mosek.iinfitem.ana_pro_num_con_ra,mosek.iinfitem.ana_pro_num_con_up,mosek.iinfitem.ana_pro_num_var,mosek.iinfitem.ana_pro_num_var_bin,mosek.iinfitem.ana_pro_num_var_cont,mosek.iinfitem.ana_pro_num_var_eq,mosek.iinfitem.ana_pro_num_var_fr,mosek.iinfitem.ana_pro_num_var_int,mosek.iinfitem.ana_pro_num_var_lo,mosek.iinfitem.ana_pro_num_var_ra,mosek.iinfitem.ana_pro_num_var_up,mosek.iinfitem.intpnt_factor_dim_dense,mosek.iinfitem.intpnt_iter,mosek.iinfitem.intpnt_num_threads,mosek.iinfitem.intpnt_solve_dual,mosek.iinfitem.mio_absgap_satisfied,mosek.iinfitem.mio_clique_table_size,mosek.iinfitem.mio_construct_solution,mosek.iinfitem.mio_node_depth,mosek.iinfitem.mio_num_active_nodes,mosek.iinfitem.mio_num_branch,mosek.iinfitem.mio_num_clique_cuts,mosek.iinfitem.mio_num_cmir_cuts,mosek.iinfitem.mio_num_gomory_cuts,mosek.iinfitem.mio_num_implied_bound_cuts,mosek.iinfitem.mio_num_int_solutions,mosek.iinfitem.mio_num_knapsack_cover_cuts,mosek.iinfitem.mio_num_relax,mosek.iinfitem.mio_num_repeated_presolve,mosek.iinfitem.mio_numbin,mosek.iinfitem.mio_numbinconevar,mosek.iinfitem.mio_numcon,mosek.iinfitem.mio_numcone,mosek.iinfitem.mio_numconevar,mosek.iinfitem.mio_numcont,mosek.iinfitem.mio_numcontconevar,mosek.iinfitem.mio_numdexpcones,mosek.iinfitem.mio_numdpowcones,mosek.iinfitem.mio_numint,mosek.iinfitem.mio_numintconevar,mosek.iinfitem.mio_numpexpcones,mosek.iinfitem.mio_numppowcones,mosek.iinfitem.mio_numqcones,mosek.iinfitem.mio_numrqcones,mosek.iinfitem.mio_numvar,mosek.iinfitem.mio_obj_bound_defined,mosek.iinfitem.mio_presolved_numbin,mosek.iinfitem.mio_presolved_numbinconevar,mosek.iinfitem.mio_presolved_numcon,mosek.iinfitem.mio_presolved_numcone,mosek.iinfitem.mio_presolved_numconevar,mosek.iinfitem.mio_presolved_numcont,mosek.iinfitem.mio_presolved_numcontconevar,mosek.iinfitem.mio_presolved_numdexpcones,mosek.iinfitem.mio_presolved_numdpowcones,mosek.iinfitem.mio_presolved_numint,mosek.iinfitem.mio_presolved_numintconevar,mosek.iinfitem.mio_presolved_numpexpcones,mosek.iinfitem.mio_presolved_numppowcones,mosek.iinfitem.mio_presolved_numqcones,mosek.iinfitem.mio_presolved_numrqcones,mosek.iinfitem.mio_presolved_numvar,mosek.iinfitem.mio_relgap_satisfied,mosek.iinfitem.mio_total_num_cuts,mosek.iinfitem.mio_user_obj_cut,mosek.iinfitem.opt_numcon,mosek.iinfitem.opt_numvar,mosek.iinfitem.optimize_response,mosek.iinfitem.purify_dual_success,mosek.iinfitem.purify_primal_success,mosek.iinfitem.rd_numbarvar,mosek.iinfitem.rd_numcon,mosek.iinfitem.rd_numcone,mosek.iinfitem.rd_numintvar,mosek.iinfitem.rd_numq,mosek.iinfitem.rd_numvar,mosek.iinfitem.rd_protype,mosek.iinfitem.sim_dual_deg_iter,mosek.iinfitem.sim_dual_hotstart,mosek.iinfitem.sim_dual_hotstart_lu,mosek.iinfitem.sim_dual_inf_iter,mosek.iinfitem.sim_dual_iter,mosek.iinfitem.sim_numcon,mosek.iinfitem.sim_numvar,mosek.iinfitem.sim_primal_deg_iter,mosek.iinfitem.sim_primal_hotstart,mosek.iinfitem.sim_primal_hotstart_lu,mosek.iinfitem.sim_primal_inf_iter,mosek.iinfitem.sim_primal_iter,mosek.iinfitem.sim_solve_dual,mosek.iinfitem.sol_bas_prosta,mosek.iinfitem.sol_bas_solsta,mosek.iinfitem.sol_itg_prosta,mosek.iinfitem.sol_itg_solsta,mosek.iinfitem.sol_itr_prosta,mosek.iinfitem.sol_itr_solsta,mosek.iinfitem.sto_num_a_realloc ];
    liinfsyms  = [ mosek.liinfitem.bi_clean_dual_deg_iter,mosek.liinfitem.bi_clean_dual_iter,mosek.liinfitem.bi_clean_primal_deg_iter,mosek.liinfitem.bi_clean_primal_iter,mosek.liinfitem.bi_dual_iter,mosek.liinfitem.bi_primal_iter,mosek.liinfitem.intpnt_factor_num_nz,mosek.liinfitem.mio_anz,mosek.liinfitem.mio_intpnt_iter,mosek.liinfitem.mio_presolved_anz,mosek.liinfitem.mio_simplex_iter,mosek.liinfitem.rd_numanz,mosek.liinfitem.rd_numqnz ];
    @staticmethod
    def _getdouinf(infname):
      idx = bisect_left(SolverInfo.dinfnames, infname)
      if idx != len(SolverInfo.dinfnames) and SolverInfo.dinfnames[idx] == infname:
        return SolverInfo.dinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getintinf(infname):
      idx = bisect_left(SolverInfo.iinfnames, infname)
      if idx != len(SolverInfo.iinfnames) and SolverInfo.iinfnames[idx] == infname:
        return SolverInfo.iinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getlintinf(infname):
      idx = bisect_left(SolverInfo.liinfnames, infname)
      if idx != len(SolverInfo.liinfnames) and SolverInfo.liinfnames[idx] == infname:
        return SolverInfo.liinfsyms[idx]
      else:
        return None
  return SolverInfo
mosek_fusion_SolverInfo=__mk_mosek_fusion_SolverInfo()
def __arg_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_alt_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v)
def __arg_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_alt_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedVariable)
def __arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedVariable_2__(v)
def __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return v is None or isinstance(v,mosek_fusion_NDSparseArray)
def __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v)
def __arg_match_Lmosek_4fusion_4SliceConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_SliceConstraint)
def __arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4SliceConstraint_2__(v)
def __arg_match__3_3D__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3D__(i) for i in v.flatten()])
def __arg_alt_match__3_3D__(v):
  return __arg_match__3_3D__(v) or __arg_match_listof__(v,__arg_alt_match__3D__)
def __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedConstraint)
def __arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelVariable)
def __arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelVariable_2__(v)
def __arg_match_Lmosek_4fusion_4LinkedBlocks_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinkedBlocks)
def __arg_alt_match_Lmosek_4fusion_4LinkedBlocks_2__(v):
  return __arg_match_Lmosek_4fusion_4LinkedBlocks_2__(v)
def __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinPSDDomain)
def __arg_alt_match_Lmosek_4fusion_4LinPSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinPSDDomain_2__(v)
def __arg_match__3_3Lmosek_4fusion_4Parameter_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Parameter_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Parameter_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Parameter_2__)
def __arg_match_Lmosek_4fusion_4SliceVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SliceVariable)
def __arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SliceVariable_2__(v)
def __arg_match__3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Expression) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Expression_2__)
def __arg_match_J__(v):
  return isinstance(v,numpy.int64) or isinstance(v,int) or isinstance(v,numpy.int32)
def __arg_alt_match_J__(v):
  return __arg_match_J__(v)
def __arg_match_Lmosek_4fusion_4Constraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_Constraint)
def __arg_alt_match_Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match_Lmosek_4fusion_4Constraint_2__(v)
def __arg_match__3J__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int64))
def __arg_alt_match__3J__(v):
  return __arg_match__3J__(v) or __arg_match_listof__(v,__arg_alt_match_J__)
def __arg_match__3_3J__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3J__(i) for i in v.flatten()])
def __arg_alt_match__3_3J__(v):
  return __arg_match__3_3J__(v) or __arg_match_listof__(v,__arg_alt_match__3J__)
def __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymRangedVariable)
def __arg_alt_match_Lmosek_4fusion_4SymRangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SymRangedVariable_2__(v)
def __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v)
def __arg_match_Lmosek_4fusion_4ConstraintCache_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConstraintCache)
def __arg_alt_match_Lmosek_4fusion_4ConstraintCache_2__(v):
  return __arg_match_Lmosek_4fusion_4ConstraintCache_2__(v)
def __arg_match__3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Variable) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricMatrix)
def __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v)
def __arg_match__3D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3D__(v):
  return __arg_match__3D__(v) or __arg_match_listof__(v,__arg_alt_match_D__)
def __arg_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicVariable)
def __arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicVariable_2__(v)
def __arg_match__3I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3I__(v):
  return __arg_match__3I__(v) or __arg_match_listof__(v,__arg_alt_match_I__) or isinstance(v,range)
def __arg_match__3_5D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3_5D__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_D__,2)
def __arg_match_LSystem_4StreamWriter_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4StreamWriter_2__(v):
  return __arg_match_LSystem_4StreamWriter_2__(v)
def __arg_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearVariable_2__(v)
def __arg_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangeDomain)
def __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4RangeDomain_2__(v)
def __arg_match_I__(v):
  return isinstance(v,numpy.int32) or isinstance(v,numpy.int64) or isinstance(v,int)
def __arg_alt_match_I__(v):
  return __arg_match_I__(v)
def __arg_match__3S__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == object and all([isinstance(i0,str) for i0 in v ])
def __arg_alt_match__3S__(v):
  return __arg_match__3S__(v) or __arg_match_listof__(v,__arg_alt_match_S__)
def __arg_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDDomain)
def __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearDomain)
def __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinkedInts_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinkedInts)
def __arg_alt_match_Lmosek_4fusion_4LinkedInts_2__(v):
  return __arg_match_Lmosek_4fusion_4LinkedInts_2__(v)
def __arg_match__3_5I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3_5I__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_I__,2)
def __arg_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_alt_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_match_LSystem_4CallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4CallbackHandler_2__(v):
  return __arg_match_LSystem_4CallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4Matrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_Matrix)
def __arg_alt_match_Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match_Lmosek_4fusion_4Matrix_2__(v)
def __arg_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_match__3Lmosek_4fusion_4Constraint_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Constraint) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match__3Lmosek_4fusion_4Constraint_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Constraint_2__)
def __arg_match_Lmosek_4fusion_4Parameter_2__(v):
  return v is None or isinstance(v,mosek_fusion_Parameter)
def __arg_alt_match_Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match_Lmosek_4fusion_4Parameter_2__(v)
def __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelConstraint)
def __arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return v is None or isinstance(v,mosek_fusion_Utils_StringBuffer)
def __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v)
def __arg_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDVariable)
def __arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDVariable_2__(v)
def __arg_match__3_3I__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3I__(i) for i in v.flatten()])
def __arg_alt_match__3_3I__(v):
  return __arg_match__3_3I__(v) or __arg_match_listof__(v,__arg_alt_match__3I__)
def __arg_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_BaseVariable)
def __arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4BaseVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Model_2__(v):
  return v is None or isinstance(v,mosek_fusion_Model)
def __arg_alt_match_Lmosek_4fusion_4Model_2__(v):
  return __arg_match_Lmosek_4fusion_4Model_2__(v)
def __arg_match_Lmosek_4fusion_4FusionException_2__(v):
  return v is None or isinstance(v,mosek_fusion_FusionException)
def __arg_alt_match_Lmosek_4fusion_4FusionException_2__(v):
  return __arg_match_Lmosek_4fusion_4FusionException_2__(v)
def __arg_match_Lmosek_4fusion_4ParameterImpl_2__(v):
  return v is None or isinstance(v,mosek_fusion_ParameterImpl)
def __arg_alt_match_Lmosek_4fusion_4ParameterImpl_2__(v):
  return __arg_match_Lmosek_4fusion_4ParameterImpl_2__(v)
def __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return v is None or isinstance(v,mosek_fusion_SolutionStruct)
def __arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v)
def __arg_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_alt_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Expression_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Expression_2__)
def __arg_match__3Lmosek_4fusion_4Parameter_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Parameter) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match__3Lmosek_4fusion_4Parameter_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Parameter_2__)
def __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Matrix_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v)
def __arg_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_alt_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_match_Lmosek_4fusion_4Variable_2__(v):
  return v is None or isinstance(v,mosek_fusion_Variable)
def __arg_alt_match_Lmosek_4fusion_4Variable_2__(v):
  return __arg_match_Lmosek_4fusion_4Variable_2__(v)
def __arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymLinearVariable)
def __arg_alt_match_Lmosek_4fusion_4SymLinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SymLinearVariable_2__(v)
def __arg_match_LSystem_4DataCallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4DataCallbackHandler_2__(v):
  return __arg_match_LSystem_4DataCallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4WorkStack_2__(v):
  return v is None or isinstance(v,mosek_fusion_WorkStack)
def __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(v):
  return __arg_match_Lmosek_4fusion_4WorkStack_2__(v)
def __arg_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_match_Lmosek_4fusion_4Expression_2__(v):
  return v is None or isinstance(v,mosek_fusion_Expression)
def __arg_alt_match_Lmosek_4fusion_4Expression_2__(v):
  return __arg_match_Lmosek_4fusion_4Expression_2__(v)
def __arg_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Variable_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicConstraint)
def __arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Matrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4ConeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConeDomain)
def __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ConeDomain_2__(v)
def __arg_match_Lmosek_4fusion_4SymmetricExpr_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricExpr)
def __arg_alt_match_Lmosek_4fusion_4SymmetricExpr_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricExpr_2__(v)
def __arg_match_D__(v):
  return isinstance(v,numpy.float64) or isinstance(v,float) or isinstance(v,int) or isinstance(v,numpy.int32) or isinstance(v,numpy.int64)
def __arg_alt_match_D__(v):
  return __arg_match_D__(v)
def __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_SymmetricMatrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4SymmetricMatrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__)
def __arg_match_Z__(v):
  return isinstance(v,bool) or isinstance(v,numpy.bool_)
def __arg_alt_match_Z__(v):
  return __arg_match_Z__(v)
def __arg_match_S__(v):
  return isinstance(v,str)
def __arg_alt_match_S__(v):
  return __arg_match_S__(v)
def __arg_match_listof__(v,f): return isinstance(v,list) and all([ f(i) for i in v])
import mosek
import mosek.fusion
import mosek.fusion.Utils
from . import fragments
